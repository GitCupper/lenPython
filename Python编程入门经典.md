# Python编程入门经典

![python log](https://i.loli.net/2019/04/25/5cc162f5430fa.jpg)

## 作者简介
James Payne居住在佛罗里达州马盖特市，他是Developer Shed公司的主编，从7岁起就开始写作和编程。James精通多门语言，已经撰写了400余篇文章，囊括了几乎每一种主流编程语言。James的工作是使用Python为金融业开发专有软件，在业余时间 他喜欢涉猎Django方向的知识。

## 致谢
我感谢在Developer Shed的同事：Jack和Jay Kin持续的敌意使我备受鼓舞；Charles Fagundes使我成为一名编辑，而不仅仅是一个作者；Keith Lee为我提供了编写代码的支持；特别要感谢Jenny Ruggieri，他使我得到了这份工作，所以有了这本书的面世。最后，还要感谢所有为这本书的前期版本付出艰辛劳动的人们，他们的工作是本书的基础。还要感谢编辑Carol Long、Jenny Watson、Ed Connor以及Chris McAvoy，他们帮助我在最终期限前完成本书。

我还想感谢Guido Van Rossum，没有他，也就没有Python语言可写。

## 前言
欢迎使用Python 3.1！
我使用Python已有10年左右，每一个新版本都使我越来越喜欢这门语言。版本3.1也不例外。如果您是Python的初学者，不必担心，我会一路引领着您。相反，如果您是一名希望尝试新版本的Python老手，可以不必在已掌握的知识上浪费时间，而是直接学习所需要的知识，因为本书的结构十分清晰。

之所以写这本书，是因为我热爱Python。我非常 喜爱它！我想和您一起分享我对Python的热爱。您可能也会像我一样越来越喜爱它。

### 本书读者对象
如果您具备计算机知识，并且想学习一门有趣的程序语言来更好地控制计算机，那么本书适合您。

如果您是系统管理员，希望学习一门优秀的语言来更好地管理和配置系统和网络，那么本书适合您。

如果您已经了解Python，但是想知道版本3.1中有哪些很酷的新功能，那么本书适合您。

总之，本书适合于所有热衷于使用功能最丰富且十分易用的最新版本Python 3.1进行编程的诸。

### 本书主要内容
本书主要介绍Python 3.1。Python 3.1发布于2009年，是Python程序语言的最新主版本。由于Python是一门跨平台的语言。本书中的内容和示例适用于任何平台（除非特别指出的例外情况）。在可能独立于平台的情况下，本书中的示例都尽量设计成跨平台的。

此外，由于Python 3.1相对较新，并非所有支持库都被更新到可以在Python 3.x下工作。在这种情形下，如果某些理论需要详细解释，本书将使用Python 2.6代替Python 3.1。

### 本书结构
就像所有入门书籍一样，本书首先对语言进行了介绍。从这里开始，会接触到语言的核心，进而接触到更加高级的专门主题。本书分为如下4个部分。

#### 第I部分——初步了解Python
如标题所示，第I部分让您初步了解Python。

##### 编程基础和字符串
本章首先介绍Python，探讨Python是什么，为什么它如此有用和强大。另外，还探讨Python的开发历史和最新的版本，后者正是本书的讨论重点。您会了解到Python所涉及的范围，以及Python可能参与的应用开发领域。最后，您将开始操作自己的第一种数据类型：字符串。

##### 数值与运算符
本章会介绍数值和运算符的基本知识。您将会学习不同类型的数值，如何执行简单的和复杂的公式，以及如何使用各种运算符。还将学到运算符的优先级以及数值的格式化。

##### 变量
编程语言最终帮助程序员管理不同类型的信息，换言之，就是管理数据。理解数据类型并且知道Python如何表示它们对于Python编程非常必要。本章将帮助您理解在Python中表示不同数据类型的最佳方式。

#### 第II部分——Python语言和标准库
当然，使用一门语言最需要的是了解语言本身，熟悉它的语法和模块。本部分首先介绍数据类型和变量，并逐步介绍其他概念，直到获得开发功能完善的Python程序所需的全部知识。

注意，应该按顺序阅读本部分的章节，因为每一章都建立在前一章的基础之上。

##### 做出决策
最终，程序将需要在某个位置做出决策：是选择这条路径，还是选择另一条路径？如果选择那条路径，将会发生什么？在本章中将学到如何比较数据，例如判断某个值是否比另一个值大，并且将学习如何利用循环来完成重复性的任务。

##### 函数
本章将介绍函数编程，这将帮助您扩展Python知识。函数允许使用者利用强大的概念，例如参数传递和代码重用。本章将介绍如何利用函数使编写的代码更加高效和灵活。

##### 类和对象
本章将介绍对象的概念。您将学习如何定义类和如何在类中创建对象和编写方法，还将学到有关对象作用域的知识。

##### 组织程序
当程序变大时，需要把它们分成单独的几部分。本章将讨论Python模块，并探索包的概念。包并不复杂，它仅是若干模块的集合。

##### 文件和目录
日常编程中一个重要的部分是学习如何处理文件和目录。文章着重介绍通常如何创建、修改和处理文件。另外，还将介绍如何从文件中获得数据，以及如何与各种各样的目录交互。

##### Python语言的其他特性
本章将介绍Python语言提供的其他特征，包括如何使用列表做出决策，如何使用字典进行字符串替换，以及一些有特色的模块。

##### 创建模块
通过允许重用代码片段，模块能够帮助节省时间。它能减少发生错误的机率，因为当前用到的模块可能之前已经被测试和使用过很多次。本章将介绍如何创建自己的模块，以及如何导入并处理已存在的模块，这些已经存在的模块使得Python在应用中功能非常强大。

##### 文本处理
在编程过程中，可以利用文本做很多事情，而且本质上，文本是与用户进行有效沟通的关键。毕竟，如果没有文本，就只能使用图片了。本章将介绍如何用多种方法处理文本，包括利用正则表达式、搜索文件以及搜索特定类型的文件等。

#### 第III部分——开始使用Python
现在您已经知道了Python是什么，以及如何利用这门语言进行工作，接下来应该做什么呢？本部分探究了您会遇到或者想了解的许多编程主题。可以顺序阅读本部分的各章，也可以按其他任意顺序阅读。因为它们是彼此独立的。

##### 测试
在把程序交付给用户之前，对程序进行测试，这是保证它能正常工作的唯一途径。本章不仅会介绍正确测试程序的一些基本概念，还会介绍一些可用的测试工具和测试框架。

##### 使用Python编写GUI
目前为止，本书中的程序都是通过命令行方式工作。本章将介绍GUI编程的概念。您将使用Tkinter创建几个GUI程序，Tkiner是Python程序员最常用的GUI工具包。

##### 访问数据库
数据库存储了程序可以使用的各种信息。它也可以作为存储信息的地方，以便日后可以从中检索出特定任务所需要数据。本章将介绍各种类型的数据库以及如何利用它们进行工作。

##### 使用Python处理XML
XML是处理Internet数据的强大工具。本章将介绍XML的基础知识，包括模式与DTD之间的区别、基本的语法、如何创建和验证XML以及一些高级的主题（例如使用lxml）。

##### 网络编程
Internet已经潜移默化地进入了我们的日常生活，并逐渐变成必需品，而不是一种特权。本章将介绍如何使用程序发送E-mail，以及如何允许用户通过Web进行交流。

##### 用C扩展编程
本章深入介绍如何使用C语言编程，包括如何利用C的框架和模块，C的基础知识，以及如何从Python向C传递参数，并在之后将值返回给Python。

##### 数据编程
本书的开始部分简单介绍了数值，现在是进一步钻研的时候了。本章将深入介绍整形、浮点型、复数和数组的全部知识，以及如何使用内置的数学函数和模块。

##### Django简介
Django是用Python编写的Web应用程序框架，它利用了模型－视图－控制器模式。Django最初被用来管理新闻Web站点，但由于简单易用而变得流行起来，它使得程序员可以用简单的方式创建复杂的Web站点，包括以数据库为中心的Web站点。本章将介绍Django的基础知识。

##### Web应用程序和Web服务
本章将介绍Web应用程序和Web服务的基础知识，例如REST架构，以及如何处理HTTP请求和响应。

##### 集成Java与Python
本章将介绍Java的基础知识，这样可以在研究如何结合Python和Java之前，打好坚实的基础。还将介绍各种帮助在Python中使用Java的模块，以及如何创建简单但有效的应用程序。

#### 第IV部分：附录
本书结尾的附录可以进一步扩展您对Python的了解，激发您对Python的学习兴趣。
* 习题答案
* 在线资源
* Python 3.1的新特性
* 术语表

### 使用本书的条件
使用本书的有一些条件。在此给出下面列出的推荐，因为Python本身可在多种不同的平台上运行。然而，本书的前几章假定您可以使用GUI，例如在Windows、Mac OS X、UNIX和Linux上的X Window等系统上可用的GUI。自然地，一些章节（例如介绍GUI的那一章）也需要GUI，而如果有网络连接，涉及网络的那些章节会更有意义。

下面是建议的最低配置需求：
* 一台PC机，运行Linux、BSD UNIX或Windows系统，频率在500MHz以上；或者运行Mac OS X版本10.2或更新版本的G3或更新的Macintosh。
* 至少256M内存。
* 所用平台具有图形用户界面。
* 对所用计算机有必要的权限，以安装必要的软件。
* 可以访问TCP/IP网络，例如Internet或者校园网。
* 可以通过Internet下载所需软件。

### 源代码
在阅读本书提供的代码时既可以亲自输入所有代码，也可以使用随书提供的代码文件。本书所有代码均可以从[http://www.wrox.com](http://www.wrox.com)（或[http://www.tupwk.com.cn/downpage](http://www.tupwk.com.cn/downpage)）网站下载。进入该网站后，请根据本书的书名查找本书（读者既可以使用搜索框进行查找，也可以使用书名列表进行查找），然后单击本书详细内容页面上提供的Download Code链接，就可以下载本书提供的所有代码。

**注意：**
由于许多书籍名称与本书类似，因此也可以通过ISBN进行查找，本书英文版的ISBN为：978-0--470-41463-7。
下载代码后，可以利用一种压缩工具解压代码。此外，还可以通过访问网站[http://www.wrox.com/dynamic/books/download.aspx](http://www.wrox.com/dynamic/books/download.aspx)中提供的Wrox代码下载页面来获取本书提供的代码，也可以下载Wrox出版的其他书籍提供的代码。

### 勘误表
为了避免本书文字和代码中存在的错误，我们已经竭尽全力。然而，就如世界上不存在完美无缺的事物，本书仍然可能存在错误。如果您在我们编写的书籍中发现了诸如拼写错误或代码缺陷等问题，请告诉我们，我们对些表示感谢。利用勘误表反馈错误信息，可以为其他读者节省大量时间，同时，我们也能够受益于您的帮助，编写出质量更高的专业著作。

如果需要参考本书的勘误表，请在网站[http://www.wrox.com](http://www.wrox.com)中用搜索框或书名列表查找本书书名。然后，在本书的详细内容页面上，单击Book Errata链接。在随后显示的页面中，可以看到与本书相关的所有勘误信息，这些信息是由读者提交、并由Wrox的编辑们加上的。通过访问[www.wrox.com/misc-pages/booklist.shtml](www.wrox.com/misc-pages/booklist.shtml)，还可以看到Wrox出版的所有书籍的勘误表。

如果没有在Book Errata页面上找到自己发现的错误，那么请转到页面[www.wrox.com/contact/techsupport.shtml](www.wrox.com/contact/techsupport.shtml)，针对您所发现的每一项错误填写表格，并将表格发给我们，我们将对表格内容进行认真审查，如果确实是我们书中的错误，那么我们将在该书的Book Errata页面上标明该错误信息，并在该书的后续版本中改正相关错误。

### 关于p2p.wrox.com
如果您希望能够与作者进行讨论，或希望能够参与读者的共同讨论，那么请加入[p2p.wrox.com](p2p.wrox.com)的论坛。这个论坛是一个基于Web的系统，您可以在论坛发表与Wrox出版的书籍有关的技术信息，并与其他读者和技术用户进行讨论。论坛提供了订阅功能，可以将与您所选主题相关的新帖子定期发送到您的电子邮箱。Wrox的作者、编辑、业界专家以及其他读者都会参与论坛中的讨论。

您可以在[http://p2p.wrox.com](http://p2p.wrox.com)参与多个论坛的讨论，这些论坛不仅能够帮助您列好地理解本书，还有助于您更好地开发应用程序。如果希望加入论坛，请按照以下步骤执行：
> (1)进入[http://p2p.wrox.com](http://p2p.wrox.com)页面，单击Register链接。
> (2)阅读使用条款，然后单击Agree。
> (3)填写必要的信息（以及想要提供的可选信息），然后单击Submit。
> (4)随后会收到一封电子邮件，邮件中说明了如何验证账号并完成整个加入过程。

**注意：**
`要阅读论坛信息，无须加入P2P。但是如果需要发表主题或发表回复，那么必须加入论坛。`

成功加入论坛后，就可以发表新主题了。此外，还可以回复其他主题。您在任何时间都可以阅读论坛信息。如果需要论坛将新的信息发送到自己的电子邮箱，那么可以单击论坛列表中论坛名称旁的Subscribe to this Forum图标完成该功能设置。

如果需要获得更多与Wrox P2P相关的信息，请阅读P2P FAQs，这样可以获得大量与P2P和Wrox出版的书籍相关的具体信息。阅读FAQs时，请单击P2P页面上的FAQs链接。

## 第I部分——初步了解Python

### 第1章 编程基础和字符串
本章简单地介绍Python编程实践。Python是一门丰富的语言，包含许多特性，因而学好基础知识是深入学习Python的前提条件。第1章～第3章通过易于理解的段落和简单的示例介绍了常见的编程思想。

对Python感兴趣的有经验的编程人员可以略读本章，并留意其中的示例，直到每3章为止，都可以借助于已有的对其他语言的知识阅读这些章节。

本章将介绍：
* 编程的一些指导原则。
* 关于初步接触程序语言Python的一些说明。
本章末的练习提供了对初步学到的基础知识进行实践的机会。

#### 1.1 编程与使用计算机的区别
编程时第一件需要了解的事情就是控制计算机。有时，计算机并没有按照人们的意愿工作，当它第一次没能如您所愿后，在第二次、第三次仍然会做与第一次相同的事情，直到对它进行修改。

个人计算机发发展已背离了可靠性原则，并朝不可信的软件套软件的方向发展。这就导致人们认为计算机就您一头具有恶意且任性的野兽，当试图让它完成某些事的时候，它会不断地增加人们的额外的工作量并折磨着使用者。然而，学过编程之后，就会知道如何应对这种情况，也许还会发现自己比所有软件的某些编写者还要聪明。

使用Python这种解释型的语言编程，意味着并不需要了解太多的计算机内部细节，如硬件、内存或者长长的0/1串。这时编程就与平常阅读和写作一样，只不过是用一种不同的简单的语言来书写。Python是一门语言，就像所讲的英语或其他语言一样，它对讲同种语言的人而言是有意义的。学习程序语言比学习人类语言甚至更简单，因为化并不是用于讨论、争论、打电话、表演、拍电影以及任何形式的日常交流活动。它们用来制订规则，并确保规则被执行。计算机已被塑造成异常灵活的工具，被广泛地用于人们日常生活中的各种商业活动和任务，但它们依旧是由可理解、可控制的基本部件组成的。

##### 1.1.1 编程的一致性
尽管计算机已消然地囊括了各式各样的设计理念，并日趋复杂。但其基本原理仍然相对简单。定义计算机如何工作的内部机制从上世纪50年代晶体管被第一次用于计算机起，就没有发生过太大的变化。

在那个时代，这种简单的核心意味着计算机可以而且应该具有高度一致性。对于程序员而言，这意味着，在任何时候让计算机跳高（比喻，并非真能跳高），就必须告诉它要跳多高，落在哪里，这样它才能完成跳跃动作，并且在指定的时间内，它将会一次次地重复相同的动作。如果没有改动程序，程序就不应随意地停止或改变工作方式。

##### 1.1.2 程序的可控性
编制一台计算机与编制一个计划是截然不同的。现实生活中，当要求他人做事时，有时候不得不做一番斗争以确保他们按照自己的意愿行事。例如，假如您计划了一个30个的聚会，并指定其中的两个人负责带土豆和蘸酱，但他们却带了饮料，这就失去了控制。

计算机则不存在这种问题，它会严格按照指示工作。如您所料，这意味着必须注意一些细节，以确保计算机确实做了要求它做的事。

Python语言的一个目标就是实现模块化编程，这就使得可以通过每一个子项目作为一个部件，并通过确保部件以易于理解的方式运行来实现更大的项目。这也是面向对象编程的主要目标。这种编程模式的主要原理是通过编制可靠的部件，使这些部件组装之后依然可以运行，且易于理解和使用。这就给予了程序员对程序每一部分运行方式的控制力，使得当要解决的问题发生变化时，知道如何扩展已有的程序。

##### 1.1.3 程序要应对变化
程序运行于计算机之上，并用于解决现实问题。现实世界中，计划和环境总是频繁地改变。这些不断变迁的环境使程序员很难有机会编写出技巧性、实用性和灵活性均趋于完美的程序。通常，只能达到其中的两个目标。这些不得不应对的变化应当都会程序员如何 更加小心地编写程序。如果足够小心，就可以编写出这样的程序，当用户的要求超出它的能力范围，它可以很友好地退出，并且通知它的使用者自己已终止工作。最好可以编出能够指出失败位置并解释失败原因的程序。Python提供了许多有用的特征，使得程序员可以描述出导致程序无法正常工作的原因。

##### 1.1.4 小结
综上所述，这些初步的规则意味着您即将被引进编程的大门，在一个自己控制的环境里，告诉计算机要做的工作。还会意识到，意外时有发生，但这些错误是可以通过某些机制加以控制的，这些机制可以让您知道如何对导致错误的条件进行处理，包括如何让程序从问题中恢复并继续运行。

#### 1.2 准备工作
在开始用Python编程之前，首先要下载并安装Python 3.1访问[www.python.org/download](www.python.org/download)并选择Python的最新版本。这会进入一个说明页面，告诉如何下载最适合本地计算机的Python版本。例如，如果正在运行Windows操作系统，该页面可能会建议下载Windows X86 MSI Installer(3.0)。

程序是以源代码的形式编写的。源代码中包含了使用程序语言编写的指令，当计算机读到源代码并对其进行处理时，程序里的指令将会变成计算机执行的操作。

就像作家和编辑有编写杂志、书籍以及在线出版物的专用工具一样，程序员也需要专门的工具。作为Python的初学者，最合适的编程工具莫过于Python IDLE图形用户界面了。

下载结束后，双击以运行程序。最好接受Python的所有默认提示。这个过程大概需要几分钟，具体时间取决于所使用的系统。

安装完毕之后，也许想测试Python是否被正确地安装。单击Windows的Start菜单，找到All programs，会看到Python 3.0的图标已经出现在菜单中，选择IDLE（Python GUI），等待程序加载。

一旦IDLE启动，输入“Test, test, testing”，并按下回车键。如果Python运行正常，它会返回
```
 'Test, test, testing'
```
这些字母都是蓝色的，并且带单引号（稍后将解释原因）。恭喜，您已成功安装了Python，并且正式步入了成为编程大师的征途。

##### 1.2.1 在非Windows系统上安装Python 3.1
如果使用Mac并运行Mac OS X操作系统，很幸运，它已经预装了Python。不过，它安装的可能不是最新版本的Python。为了安全性以及兼容性的目的，建议访问[www.python.org/download/mac](www.python.org/download/mac)，检查所用的Mac OS X版本是否适合正在安装的Python版本。

装有Linux系统的计算机可能已经安装好Python，但同样可能不是最新版本。这里仍然建议去Python的官方Web站点找到最新版本（当然，要适合所用的系统）。Web站点[www.python.org/download](www.python.org/download)上介绍了如何下载适合您的计算机的Python版本。

##### 1.2.2 使用Python Shell
在开始编写程序之前，需要学习如何使用Python Shell试验程序。现在，可以认为Python Shell是一种查看运行中的Python代码的方式。通过Shell可以进入Python的一个运行实例中，并可以向其中填写代码；同时，Python会执行要求它做的任何工作，并会显示它是如何对程序的环境做出响应的。由于程序通常是在一定的上下文环境——由程序员根据自己的需求量身打造——中运行，使用Shell的好处是它可以让程序员在自己创建的上下文环境中进行实验。

成功安装Python 3.1后，可以开始使用Shell的基本功能做一些实验。例如，可以输入：
``` python
 >>> "Hello World. You will never see this."
```
注意刚才输入Shell的语句实际上什么都不做，Python的环境也没有任何变化。Python会判断输入的语句让它做什么。在本例中，仅需要Python读取所输入的文本。

尽管从技术上说Python没有对输入的文本执行任何操作，但它会给出某种指示，表明自己已读过输入的语句。Python通过显示输入的文本（字符串）表明它已经读过了。字符串是Python的一种数据类型，在Python中，每种数据类型都有不同的显示方式。在逐步深入地阅读本书的过程中，读者会看到Python是如何显示每种不同的数据类型的。

#### 1.3 开始使用Python——字符串
此时，您可以自由使用Shell的基本功能进行实验。输入一些文本，并用引号括住它们。初学者可以输入如下语句：
``` python
>>> "This text really won't do anything"
"This text really won't do anything"
```
您应该立刻注意到，当输入一个引号（"）时，Python Shell改变了之后输入的所有字符的颜色，走到输入第二个引号以结束当前输入的语句。当然，前面的解释是成立的。它什么都不做：它 会改变Python的环境，正在运行的Python实例仅判断输入的语句是否让Python做一些事情。本例中，仅仅让它读入所写的文本，但这些并不会改变环境。

然而，可以看到Python表示它看到了输入。它以字符串的形式显示了输入，即用引号把输入的文本括起来。当学习了其他数据类型后，会发现Python显示不同数据类型的方式是不同的。

##### 1.3.1 字符串概述
字符串是Python语言的一种数据类型。顾名思义，数据类型是指某种特定类型的数据所适合的类别。输入到计算机中的数据会被划分为某种数据类型，不管它们是数值还是字母。定义数据类型使得计算机可以断定如何处理输入的数据。例如，如果想让程序在屏幕上显示数学公式 1+1 ，必须告诉它输入的是文本。否则，程序会将输入解释为数学公式，并进行相应的计算。

在后续的章节中，读者将会了解到越来越多的不同的数据类型，并理解定义数据类型的重要性。目前，知道字符串是由任意字符构成的数据类型即可，一个字符呆能是一个字母、数值、符号或标点符号。因此，下面所列都是字符串的示例。
``` python
 "Hello, how are you?"
 "1+1"
 "I ate 4 bananas"
 "!@#$%^&*()"
```

##### 1.3.2 为什么需要引号
当向Python输入一个字符串时，首先要输入一个引号。至于应该使用单引号（'）、双引号（"）还是三个引号（'''），要取决于想完成的目标。大多数情况下会使用单引号，因为它最容易输入（不需要按下Shift键）。然而，请记住，单引号和双引号以及三层引号是等价的。

尝试输入一些字符串。每当输入一个语句后，按下回车键让Python计算输入的语句。

@(<Inbox>)[用不同的引号输入字符串, 用加号串联字符串, 更多字符串格式, 对不同的数值使用type, 创建虚数, 在字符串中包含不同的数字, 在字符串中将%符号转义, 基本算术, 使用取余运算, 打印结果, %f格式说明符, 使用数学运算, 使用数字格式, 出错, 将数字格式化为八进制和十六进制, 给名称赋值, 创建和使用元组, 通过一个元组访问另外一个元组, 查看列表中的元素, 创建字典]

输入如下字符串，记住引号的类型（单引号或双引号）和行的末端（到达行的末端时使用回车键）：
``` python
 >>> "This is a string using a double quote"
 'This is a string using a double quote'
 >>> 'This is a string with a single quote'
 'This is a string with a single quote'
 >>> """This string has three quotes
 look at what it can do !"""
 'This string has three quotes\nlook at what it can do!'
 >>>
```
在上面的示例中，尽管每个句子看起来都不一样，但计算机用同样的方式解释它们：作为字符串。下面将介绍使用3种不同引号的真正目的。

##### 1.3.3 为什么有3种类型的引号
有3种类型的引号的原因很简单。假定就像刚才所做的那样，要在句子中用一个缩写。如果向Shell中输入语句“I can't believe it's not butter.”，不会有什么问题，但是当实际上程序用到刚才输入的 字符串时，就会得到出错的消息。为了解释这种现象，下一节将介绍`print()`函数。

##### 1.3.4 使用print()函数
Python（以及其他程序语言）中的函数是开发人员用来节省时间以及使程序更有效率的工具。他们将可以重复使用的代码存储在函数中，然后在需要的时候调用这些函数，而不是一遍遍地编写相同的代码。目前不要太担心函数，在后面会对它们进行更详细的介绍。

`print()`函数用来在屏幕上打印文本。在Python Shell中尝试如下的示例：
``` python
 >>> print("Hello World!")
```
按下回车键后，可得到如下输出：
``` python
 Hello World!
```
 这里有几个地方需要注意。首先，当进入`print()`函数时，会弹出如图1-1所示的窗口，显示函数中各种可用的选项。其次，后续行中的文本再次显示为蓝色，但这次，文本周围并无引号。这是因为与之前的示例有所不同，这一次Python实际上对数据做了一些操作。
 ![图1-1](https://i.loli.net/2019/04/25/5cc1669f34d24.png)
 图 1-1

 恭喜，您已经编写了自己的第一个程序。

##### 1.3.5 理解不同的引号
 现在知道了如何使用`print()`函数，可以练习使用本章前面提到的各种不同类型的引号了。尝试之前的示例：
``` python
 >>> print('This is a string using a single quote!')
 This is a string using a single quote!
 >>> print("This is a string using a double quote!")
 This is a string using a double quote!
 >>> print("""This string has three quotes!
 Look at what it can do!""")
 This string has three quotes
 Look at what it can do!
```
可以看到，在示例所示的这些情况中单引号（'）和双引号（"）是可以互换的。然而，若想使用缩写，例如don't，或者想引用某人的言论，观察会发生什么：
``` python
 >>> print("I said, "Dont't do it")
```
当按下回车键执行该函数时，会得到错误消息：`SyntaxError: invalid syntax(<pyshell#10>, line 1)`。您也许会感到奇怪，单引号和双引号不是可以互换吗？大部分情况下是这样的。然而，将它们混合在一起时，经常会出现语法错误，表示错误地输入了代码，并且Python不会知道您的意图何在。

实际上，Python看到输入的第一个双引号后，把它解释为字符串的开头。当它在单词`Don't`之前碰到双引号时，会将该引号看做字符串结束符。因而，后面的字母对Python是没有意义的，因为它们不是当前字符串的一部分。直到遇到字母t之前的那个单引号时，字符串才重新开始。

有一个简单的解决办法，叫做转义。再试一下前面的代码，在字符串中加入一个转义字符：
``` python
 >>> print("I said, \"Dont't do it")
 I said, "Don't do it
```
这一次，代码可以工作了。当Python见到反斜杠（\），也就是转义字符时，知道应当把双引号看做一个字符，而不是某种数据类型的指示符。但是，也许您已经注意到了，这行代码还存在最后一个问题。看到输出结果最后丢失了一个双引号吗？为了使用Python将语句末尾的双引号打印出来，只需要再增加一个转义字符以及一个双引号即可，如下所示：
``` python
 >>> print("I said, \"Dont't do it\"")
 I said, "Don't do it"
```
最后，花点时间讨论一下三引号。之前简单介绍过它的用法。从该示例可看出，利用三引号可以输入多行文本，在输入结束三引号之前这些文本不会被处理。这种技术在不想将大量数据打印到一行以及想在代码中换行时非常有用。接下来的示例使用这种方法写了一首诗：
``` python
 >>> print("""Roses are red
 Violets are blue
 I just printed multiple lines
 And you did too!""")
 Roses are red
 Violets are blue
 I just printed multiple lines
 And you did too!
```
还可以利用换行（\）转义字符在多行中打印文本，换行符是最常用到的转义字符。这里对其做一简单介绍，在后续章节中会深入地讨论它。尝试如下代码：
``` python
 >>> print("Roses are red \n Violets are blue \n
 I just printed multiple
 lines \n And you did too!")
 Roses are red
 Violets are blue
 I just printed multiple lines
 And you did too!
```
可以看到，结果是一样的。采用哪种方法取决于自己，但是换行符可能更有效率并且更易于理解。

#### 1.4 串联两个字符串
每个程序员都会遇到要把两个或多个字符串连接在一起的情况，这叫做串联（concatenation）。例如，假设有一个包含了雇员的名和姓的数据库。某些时候可能希望半这些名字作为完整的记录打印，而不是将名和姓分开。Python中，每个这样的项都会被看做一个单独的字符串，如下所示：
``` python
 >>> "John"
 'John'
 >>> "Everyman"
 'Everyman'
```

@(**试一试**)[用加号串联字符串]

有许多将不同的字符串串联起来的方法。第一种是数学方法：
``` python
 >>> "John" + "Everyman"
 'JohnEveryman'
```
也可以不用+号，而采用下面这种方法：
``` python
 >>> "John" "Everyman"
 'JohnEveryman'
```
从这些示例可以看出，字符串被串联起来了；然而，Python逐字读这个语句，因而两个字符串之间没有空格（请记住：Python现在将它们看做一个字符串，而不是两个！）。如何处理这种情况？有两种解决方法。第一种是在第一个字符串后加入一个空格，如下所示：
``` python
 >>> "John " "Everyman"
 John Everyman
```
然而，并不推荐使用这种方法，因为将来需要阅读这段代码时，很难确定是否存在John的后面加了空格。另外一种方法是简单地使用一个分隔符，例如：
``` python
 >>> "John" + " " + "Everyman"
 'John Everyman'
```
使用这种方法而不是简单地输入一个空格的其他原因与数据库存储有关，第14章中将讨论这方面的内容。请注意，可以使用任意的分隔符，例如：
``` python
 >>> "John" + "." + "Everyman"
 'John.Everyman'
```
##### 用print函数连接字符串
默认情况下，当要在一句话中打印多个字符串时，print()函数会非常周全地插入空格。这里没有必要使用空格分隔符。相反，只需要用逗号将不同的字符串隔开即可。
``` python
 >>> print("John", "Everyman")
 John.Everyman
```

#### 1.5 用不同的方法串联字符串
另外一种指定字符串的方法是使用格式说明符。它通过插入一个特定的字符序列工作，这个字符序列被Python解释为占位符，并将由程序员提供的值 替换。初看起来，这种方法很复杂，不是非常有用，但格式说明符可以控制要显示的信息的格式，还可以提供许多有用的技巧。

@(**试一试**)[用加号串联字符串]

在最简单的情形下，可以对朋友John Q.做同样的事情：

##### 示例说明
%s是针对字符串的格式说明符。在本书对数据类型进行不断讨论的过程中，还会遇到更多的格式说明符，它们分别对应于特定的数据类型。在字符串中，每个格式说明符都担当相应类型的占位符。字符串外面的%符号表明它后面的所有值会被插入到字符串中相应的格式说明符处。

注意圆括号，它告诉字符串后面的序列包含用于填充格式说明符的值。

一种简单的理解方式是%s是一个存储器，存放着圆括号中的值。如果想处理更多的值，只需加入另外一个格式说明符即可，例如：
``` python
 >>> "John %s%s" %("Every", "Man")
 John Everyman
```
这些序列是Python编程的一部分，同样地，在本书的后续章节中会对其做更详细的介绍。目前，只需知道字符串中的每一个格式说明符在提供给它的序列中都必须有一个元素与之对应即可。序列中的每一项都是用逗号分隔开的字符串。

如果是向其中存放数据，为什么要把它们叫做格式说明符呢？原因是它们有多种功能，作为存储器只是其功能之一。下面的示例不仅说明了如何向格式说明符中存放数据，还说明了如何用它指定要显示的数据格式。

@(**试一试**)[更多字符串格式]

这个示例告诉格式说明符处理多个字符。尝试如下代码，并观察结果：
``` python
 >>> "%s %s %10s" % ("John", "Every", "Man")
 'John Every           Man'
 >>> "%-5s %s %10s" % ("John", "Every", "Man")
 John     Every          Man
```
##### 示例说明
在第一行代码中，单词Man出现时，离前面的单词很远，这是因为在最后一个格式说明符中添加了10，表示一个长度为10的字符串。如果字符串没有10个字符（它仅包含3个字符，即M-a-n），它就会在前一个单词与Man中间加入7个空格。

在输入的第二行代码中单词Every被空格隔开的方式与其他单词不同。原因与第一行代码相同，只不过这次空格是在左边，而不是右边。将负号放在格式说明符的右边，这个格式会出现在单词的右边。如果使用了一个非负的数值，它出现在左边。

#### 1.6 本章小结
本章学习了如何安装Python，以及如何使用Python GUI(IDLE)，这个GUI是用Python编写的程序，专门用于编辑Python程序。除了编辑文件，这个Shell还允许用Python的简单编程语句进行实验。

本章通过使用Shell介绍了有关字符串处理的基本知识，包括字符串串联，如何使用格式说明符对字符串进行格式化，甚至如何在同样的%s格式说明符中存储字符串。另外，还学习了如何使用多种类型引号，包括单引号、双引号和三引号，并且了解了\n换行转义字符的含义。

最后，学习了第一个函数print()，并且编写了自己的第一个程序Hello World，初学编程时第一个编写Hello World程序在程序员中间是一个历史悠久的传统，这与演奏吉他首先要学习“Smoke on the Water”一样——它们都是必学的第一课。

##### 本章要点：
* 编程的一致性。所有程序都是为了特定的用途而创建的，程序的使用者不仅希望程序能够实现预定的用途，而且希望程序每次的工作方式都相同。如果用户单击一个按钮，有一个打印对话框弹出，那么这个按钮应当总以相同的方式工作。
* 编程的可控性。程序员控制着自己的应用程序可以执行以及不可以执行的操作。即使程序的某些方面对于普通的观察者而言是随机的，但实际上它们也是由程序员创建的参数控制的。
* 程序要应对变化。通过不断的测试，可以确保程序对用户做出适当的响应，即使用户让程序做一些其能力范围之外的事情。
* 字符串是一种数据类型，简单讲，是一类数据。这些字符串允许以多种方式与用户进行交互，例如，向窗口打印文本，接受用户输入的文本等等。一个字符串可由任意的字母、数值或者特殊字符组成。

#### 1.7 习题
1. 在Python Shell中，输入字符串：“Rock a by baby, `\n\ton the top, \t\when the windblows\n\t\t\t the cradle will drop”`。可以使用不同数目的\n和\t转义序列进行实验，看看它们的数目对屏幕上的显示有什么影响。甚至可以尝试把它们放在不同的位置。可能的输出是什么？

2. 在Python Shell中，使用与练习1中相同的字符串，但是这一次使用print()函数显示该字符串。再一次尝试不同数目的\n和\t转义序列。结果会有什么不同？

### 第2章 数值与运算符
人们天生使用数值。婴儿从开始爬行到最终站起来都使用数值估计距离。随着时间 的推移，人们扩大了数值的使用范围，开始更加有意识地使用数值，例如购买饮料或制定每月的预算。不论是一岁还是九十岁，都对数值有一定程序的了解。实际上，数值是一个如此熟悉的概念，以至于很难注意到在不同的上下文中有多种使用数值的方式。

本章介绍数值以及Python处理数值的一些方法，包括基本算术以及针对不同类型数值的特殊的字符串格式说明符。

本章将介绍：
* Python使用的各种基本数值类型。
* 使用数值的方法。
* 如何显示以及混合各种类型的数值。

#### 2.1 不同类型的数值
如果使用过电子制表软件，会注意到制表软件并不把数值看做单纯的数值，而是看做不同类型的数值。电子制表软件根据不同的单元格格式，用不同的方法显示数值。例如，当处理美元数据时，电子制表软件将1美元显示为1.00。然而，如果想知道自己的车行驶的英里数，很可能以十分之一英里为单位记载，例如10.2英里。当说出想为一个新房子付多少钱时，很可能想到最接近的千位数。在数值的大端，电表账单以千瓦时为单位记录了读表数，千瓦时是指每小时1000瓦。

这对Python意味着，当想使用数值时，有时需要意识到并不是所有的数值都是相关联的（就像本章中讲到的虚数一样），并且有时必须谨慎地决定使用什么样的数值以及要用这些数值做什么。然而，一般情况下，有两种使用数值的方式：第一种是告诉Python重复一个特定的动作，第二种是用数值代表现实世界中的事物（即在程序中尝试对现实世界中的事物建模）。在Python中进行计数时，很少需要将数值看做简单数值之外的其他事物。然而，当尝试解决现实世界中的问题，例如涉及货币、科学、汽车、电等的问题，会发现自己更加清楚如何使用数值。

##### Python中的数值
Python提供了三种类型的可用数值：整型、浮点型和虚数。

在之前的版本中，Python用不同的方法处理大数。介于`-2 147 483 648`和`+2 147 483 647`之间的数被认为是整型。更大的数被提升为长整型。现在这两种类型已经合并，所以整型用于表示整数，无论这个整数是正数还是负数。

要确定数值的分类，可以使用Python中内置的一个特殊函数type。当使用type时，Python会告诉正在使用数据的类型。下面用几个示例进行说明。

@(**试一试**)[对不同的数值使用type]

在Python Shell中可以输入不同数值，type将指出Python如何看待这些数值：
``` python
 >>> type(1)
 <class 'int'>
 >>> type(2000)
 <class 'int'>
 >>> type(999999999999)
 <class 'int'>
 >>> type(1.0)
 <class 'float'>
```
##### 示例说明

尽管日常生活中，`1.0`与`1`相同，但Python自动将`1.0`看做一个浮点数；没有`.0`，数值`1`被当作整数`1`来处理（在小学学到的整数），这是另一种数值类型。

本质上，浮点数与整数的特殊区别在于浮点数有小数部分。像1.01、2.34、0.02324这样的数，以及其他包含小数部分的任意数值都被当作浮点数（虚数例外，它们有单独的规则）。这种数值类型可以用来处理货币或者具有可分性质的事物，例如汽油或者一对袜子（经常发现只剩下一只袜子，是不是这样？）。

##### 棘手的数值
工程领域、金融领域以及其他领域的专家需要处理非常大以及非常小的数（小到有一堆小数位），他们需要比内置类型（例如浮点型）更高的精度和一致性。如果要在编程中探索这些学科，应该使用可用的模块，第7章将介绍模块，它们用来处理与感兴趣的领域有关的问题。至少，在需要使用高精度浮点数时，有必要研究如何使用为处理这些数值编写的模块，这些模块的使用方法不同于默认行为。

Python提供的最后一种数值类型是面向工程师和数学家的。它就是虚数，在学校中应该学习过这种数。虚数定义为`-1`的平方根。尽管叫做虚数，它在对现实工程情形进行建模以及其他领域（例如物理和纯数学领域）都有许多实际的应用。虚数被内置到Python中，因此可以被经常使用计算机解决问题的用户方便地使用。如果您恰巧是这类用户，就会高兴地发现自己并不孤单，Python可以帮助您完成自己的目标。

@(**试一试**)[创建虚数]

除了不能与浮点数混合之外，虚数与浮点数很相似。虚数尾部有一个字母`j`：
``` python
 >>> 12j
 12j
```
##### 示例说明
当在数值之后使用字母j，并且数值和字母不是这字符串（即不在引号中）时，Python知道要将输入的数值看做虚数。出现在字符串以外的字母都必须有特殊含义，例如，这个修饰符指定了数值的类型，或者是一个已命名变量（见第3章），或者是另外一个特殊名称。否则，一个字母单独出现会导致出错！

可以将虚数与非虚数结合起来，创建一个复数：
``` python
 >>> 12j + 1
 (1+12j)
 >>> 12j + 1.01
 (1.01+12j)
 >>> type (12j + 1)
 <class 'complex'>
```
可以看到，当试图混合虚数以及其他数值时，它们没有相加（相减、相乘或相除），而是以创建复数的方式保持独立。复数有实部和虚部，但是如何使用它们超出了本章的讨论范围，如果需要使用它们，可以在学习第6章以后探索复数模块（再一次出现这个词！）。模块的名称是cmath，代表complex math。复数将在第19章做进一步讨论。

#### 2.2 程序文件
现在，您应该可以比较熟悉地使用Python Shell，并在其中编写不同代码。前面用它实现示例，但现在将以一种不同的方式使用它。不同于简单地输入那些在GUI关闭之后会消失的单行代码，现在将创建和保存实际的文件，这些文件可以被再次打开和使用。

本章后续部分鼓励使用Python Shell和记事本创建自己的文件。

@(**试一试**)[创建虚数]

向记事本中输入下面的文本：
``` python
 print("This is a basic string")
 print("We learned to join two strings using " + "the plus operation")
```
现在已经向编辑器中添加了代码，尝试保存它。选择File菜单的Save As命令（如图 2-1 所示。）

![图2-1](https://i.loli.net/2019/04/25/5cc1670bb0496.png)

图 2-1

此时将出现一个弹出菜单，提示输入文件名和文件的存储目录。Python文件使用`.py`扩展名，因此要始终确保将`.py`加到文件名之后，否则记事本会将文件保存为其默认类型`.txt`。将这个文件命名为`Test.py`。接下来，定位到Python的安装目录。通常，安装路径以`C:/Python31/`开头。单击`Save`按钮，就把文件保存到了指定位置。

** 提示 **
在选择文件名并保存文件之后，可以重新打开它。要运行`Test.py`，在Python Shell中选择`File | Open`，选定要运行的文件（此处是`Test.py`）。Python编辑器将打开。单击`Run`，选择`Run Module`（见图 2-2），然后满怀期待地关注自己的第一个运行的程序。

![图2-2](https://i.loli.net/2019/04/25/5cc169019a79d.png)

图 2-2

要注意一些情况。首先，初次打开`Test.py`文件时，Python使用不同的颜色突出显示代码。这使得函数和数据类型（以及其他许多与编程有关的方面）更易于辨认。例如，`print()`函数的颜色是紫色的，而包含值的字符串是绿色的。

运行这个模块时，不再看到代码，而是看到它的结果在屏幕上以蓝色文本写出：
``` python
 This is a basic string
 We learned to join two strings using the plus operator
```
用不同的字符串再多做几次这样的操作，把它们保存在不同的文件中。每个会话现在都是可用的，之后可以引用它们。

##### 2.2.1 使用不同的类型
除了基本的整形外，其他数值类型也可能增长到具有过多的数位，从而变得难以阅读和理解。所以，经常看到这些数值在生成之后，以类似于科学计数法的格式出现。Python也允许以这种格式输入数值，所以这是一条双向路。使用非常大的整型数和浮点型数有许多障碍。这个主题涉及很多细节，并且不是学习Python必须理解的。如果想对一般意义上的浮点数有更多了解，并且了解它们对计算机而言意味着什么，[http://docs.sun.com/source/806-3568/ncg_goldberg.html](http://docs.sun.com/source/806-3568/ncg_goldberg.html)是一篇非常优秀的参考文化，尽管其中的解释只对了解计算机和数值的人有意义。然而，不要因此就不去阅读，它也许是您将来某个时刻想了解的知识。

最常用的是整型和浮点型。从某些地方（例如日期、时间或者某人的年龄信息等）得到数值的情况很常见。当以数值的形式得到数据后，还需要显示数据。

通常的方法是将数值放到字符串中。可以使用第1章中用到的格式说明符方法。直觉上，可能认为应当能够使用`+`将数值包含到一个字符串中，但实际上这是不行不通的，因为它们是不同的类型，而`+`运算符只能用于同类型数据：例如，两个字符串，两个数值，或者两个其他对象和类型等。有一个例外是浮点数和整型数可以相加。除此以外，应当认为不同类型的数据是不能用`+`运算符结合起来的。

您可能会感到奇怪，为什么字符串的格式说明符中可以有数值，但是`+`却不可以。原因是`+`运算符依赖于要相加的实际项中包含的信息。在Python中使用的任何东西都可以看做具有属性的对象，并且所有的属性结合在一起定义了这个对象。每个对象最重要的属性是它的类型，现在对于类型，最重要的是理解，一些自然而然可以理解的操作（例如`+`操作）只能用于两个可兼容类型的对象。大部分情形下，除了数值以外，应该把可兼容类型看做同一类型。

** 提示 **

如果确实想对数值和字符串执行`+`操作（这经常是自己可以决定的风格问题），可以使用一个内置函数`str`，该函数在可行的情况下把数值转换为字符串。这样就可以完成将字符串和数值相加，从而形成一个单独的字符串这样的操作。可以对大多数对象使用`str`函数，因为大多数对象都有一个作为字符串显示的方法。然而，为了保持一致，现在仍然使用字符串格式说明符。

@(**试一试**)[在字符串中包含不同的数字]

在第1章中使用格式说明符将两个字符串连接在一起时，用到了格式说明符`%s`，它的含义是“一个字符串”。由于数值和字符串有不同的类型，必须使用不同的说明符将数值包含到字符串中：
``` python
 >>> "Including an integer works with %%d like this: %d" % 10
 'Including an integer works with %d like this: 10'
 >>> "An integer converted to a float with %%f: %f" % 5
 'An integer converted to a float with %f: %f: 5.000000'
 >>> "A normal float with %%f: %f" % 1.2345
 'A normal float with %f: 1.234500'
 >>> "A really large number with %%E: %E" % 6.789E10
 'A really large number with %E: 6.789000E+10'
 >>> "Controlling the number of decimal places shown: %.02f" % 25.101010101
 'Controlling the number of decimal places shown: 25.10'
```
如果不知道在哪里使用格式说明符，注意最后一个示例看起来与打印货币数值的方法很相似，实际上，任何处理元和分的程序都至少要有这种处理数值和字符串的能力。

** 示例说明 **

任何时候，当为字符串提供格式说明符时，可能会有一些选项可以用来控制该说明符如何显示与它相关联的值。在第1章中已经看到与`%s`相关的选项，该选项可以控制显示的字符数。数值说明符也是一种 约定，指出特定类型的数值应该如何显示。当使用任意数值格式说明符时，这些约定控制着显示的结果。

@(**试一试**)[在字符串中将%符号转义]

之前已经给出了另外一个小窍门。如果想在程序中打印字符串`%d`，可以在Python字符串中连续使用两个`%`符号。这仅当在同一字符串中还有其他Python可以替换的有效格式说明符时才是需要的。
``` python
 >>> print("The %% behaves differently when combined with other letters, like this: %%d %%s %%f %d" % 10)
 The % behaves differently when combined with other letters, like this: %d %s %f 10
```

** 示例说明 **

注意，Python注意字母的组合，它将在一个字符串中既有格式说明符又有双百分号时正确地工作。

##### 2.2.2 基本算术
在程序中使用数值进行基本算术运算的情况是很常见的。加法、减法、除法和乘法都是内置的。加法和减法通过`+`和`-`号执行。

@(**试一试**)[基本算术]

在Python Shell提示中可以输入基本的算术表达式，将它当作一个计算器来使用。像计算器一样，Python接受一组操作，当按下`Enter`键后，它将计算输入的表达式，并给出结果：
``` python
 >>> 5 + 300
 305
 >>> 399 + 3020 + 1 + 3456
 6876
 >>> 300 - 59994 + 20
 -59674
 >>> 4023 - 22.46
 4000.54
```

** 示例说明 **
简单的算术运算起来和预期的一样。除了`+`和`-`，乘法通过`*`执行，除法通过`/`执行。由于浮点数整数的区别，乘法和除法在Python中并没有想象的那么直截了当。

在Python早先的版本中，当数值变大时，将从整型被提升为长整型。然而，Python 3.1中合并了这两种类型，所以不再需要做这样的提升。观察下面的数值以及当这些数值达到一定大小时Python是如何提升它们的：
``` python
>>> 2000403030 * 392381727
784921594607432810
>>> 2000403030 * 3923817273929
7849215963933911604870
>>> 2e304 * 3923817273929
inf
>>> 2e34 * 3923817273929
7.8476345478579995e+46
```
注意，尽管Python可以处理非常大的数，但是一些操作的结果仍会超过Python的容纳能力。Python在遇到无法处理的大数时将返回inf，这是infinity（无穷大）的缩定。

在Python 3.1之前，除法更值得注意。在没有帮助的情况下，Python不能够通过除法将一种数转化为另一种数。只有当至少有一个操作数是浮点数（数后有一个小数点）时才显示浮点型结果。如果两个普通的整型或者长整型数（无论是其中的哪种情况，都缺少小数部分，包括`.0`）相除，余数将被舍弃。这个问题已经被解决了，目前的Python将显示小数，除非告诉它不要这样做。观察如下输出：
``` python
 >>> 44 /11
 4.0
 >>> 5.0 / 2.5
 2.0
 >>>324/101
 3.2079207929792981
 >>> 324.5/102.9
 3.1535471331389697
```
可以看到，如果将一个整数与另外一个整数相除，将显示一个浮点数，即使在没有余数的情况下也是如此。同样地，一个整数除以一个浮点数将返回一个浮点数。然而要注意，即使整型被显示为浮点型，如前面示例中的`4.0`和`2.0`，但实际上它仍旧是整型。不过，`324/101`的结果被转换成一个浮点数。

@(**试一试**)[使用取余运算]

Python还有一个基本运算应当注意：取余运算。Python一个新增的功能是允许查看一则除法的完整结果（如前面的公式`324/101`中所示）。以前，如果想知道余数，必须要用取余运算符，因为Python只显示结果的整数部分。对于`324/101`，Python将显示3。不过在某些情况下，仍然仅需要除法结果的余数部分。为了确定这部分结果，必须要用取余运算符，符号是`%`。不必困惑，`%`只有在用于数值的时候才代表取余数。当使用字符串时，它仍然表示格式说明符的含义。同样的操作在不同的上下文中有不同的含义，这叫做重载，是一种非常有用的功能，但是当某些操作通过设计而具有不同行为时请不要惊讶。
``` python
 >>> 5 / 3
 1.666666666666667
 >>> 5 % 3
 2
```

** 示例说明 **

上面的代码表示`5`除以`3`得`1.666666666666667`，而在第二个示例中，当`5`除`3`时余数为`2`。取余运算符一个非常有用的任务是确定某个数是否可以被另外一个数整除，例如，决定序列中的某些项是否可以均匀地填充到另外一个序列中（第3章会介绍更多关于序列的知识）。这里有一些示例可以尝试：
``` python
 >>> 123 % 44
 35
 >>> 334 % 13
 9
 >>> 625 % 4
 0
```

##### 2.2.3 一些惊喜
当处理普通的浮点值时要小心，例如钱数。Python中的一些地方很令人迷惑。例如，当以看似直接的数学方式操作某些数时，得到的结果后面将有一些多余的值，如下所示：
``` python
 >>> 4023 - 22.4
 4000.599999999999
```
尾部的9会令人烦恼，但它们仅仅反映了Python的高精度。然而，当打印或者执行数学运算时，这个我实际上将得到精确的结果。

@(**试一试**)[打印结果]

尝试实际打印出结果，将上面具有不同寻常结果的数学公式的结果显示给用户，例如，在某个程序内部就可能采取这种做法：

``` python
 >>> print("%f" % (4023 -22.4))
 4000.600000
```

** 示例说明 **
前面介绍浮点数除法时提到，在Python 3.0中会输出整个公式。在计算公式`5/3`时，会得到`1.666666666667`。但是也许并不想向用户显示这么长的一串数值。可以用`%f`格式𧪈符将答案截短。

@(**试一试**)[%f格式说明符]

尝试下面的代码，观察Python处理浮点运算的不同方法，以及如何利用格式化方法操作结果：
``` python
 >>> print("%f" % (5/3))
 1.666667
 >>> print("%.2f" % (5/3))
 1.67
 >>> print("%f" % (415 * 20.2))
 8383.000000
 >>> print("%0.f" % (415 * 20.2))
 8383
```
浮点数非常容易让人糊涂。对浮点数的完整讨论超出了本书的范围，但是如果熟悉计算机和数值并且想更多地了解浮点数，可以阅读[http://docs.sun.com/source/806-3568/ncg_glodberg.html](http://docs.sun.com/source/806-3568/ncg_glodberg.html)上的论文。论文里的解释应该可以帮助完善这里的讨论。

#### 2.3 使用数值
如前面的示例所示，可以利用诸如格式说明符的方法将数值包含到字符串中，并用`print()`函数显示出来。重要的一点是必须确定如何显示这些数值，以便它们可以表示想让它们表示的含义，这要取决于对应用程序的了解程度。

##### 2.3.1 求值顺序
进行数学运算时，可能会看到`4*3+1/4-12`这样的表达式。面临的一个问题是确定如何求这种表达式的值，以及自己求值的方法是否与Python的求值方法相同。最安全的做法总是把数学表达式用括号括起来，这就是使得先求哪些数学运算的值变得清楚。

Python以如下方式对这些基本的数学运行求值：先计算乘法和除法，后计算加法和减法，但即使这样也有令人困惑的时候。

@(**试一试**)[使用数学运算]

当考虑一组数学运算时，将它们写下来（或者用键盘输入）看起来最直接，然而以后查看这些运算时容易感到迷惑。尝试如下示例，设想它们没有括号：
``` python
 >>> (24 * 8)
 192
 >>> (24 * (8 + 3))
 264
 >>> (24 * (8 + 3 + 7.0))
 432.0
 >>> (24 * (8 + 3 + 7.0 + 9))
 648.0
 >>> (24 * (8 + 3 + 7.0 + 9))/19
 34.10526305789474
 >>> (24 * (8 + 3 + 7 + 9)) / 19
 34.10526315789474
 >>> (24 * (8 + 3 + 7 + 9))%19
 2
```
在示例中要注意，使用浮点数时，整个公式会改为使用浮点数，而去掉所有浮点数会导致Python将所有数都看做整型，除非结果是浮点型的。

** 示例说明 **

上面的示例以类似于正常求值顺序的方式组合在一起，但是使用圆括号可以肯定哪组代数运算将首先被求值。最里面的运算最先被求值，最外面的运算最后被求值。在一结圆括号内，以正常顺序求值。

##### 2.3.2 数值格式
当准备在字符串中包含数值时，有很大的灵活性。下面的“试一试”部分给出了一些示例。

为了显示钱数，使用格式说明符将小数点后的位数限制为两位。

@(**试一试**)[使用数字格式]

例如，尝试下面的示例。这里把一个数值作为钱数打印：
``` python
 >>> print("$%.02f" % 30.0)
 $30.00
```
也可以用类似的格式表示小于1美分的值，例如当列出单独销售的小件商品时。如果要打印的数值多于即将打印的位数，看看Python将怎么做：
``` python
 >>> print("$%.03f" % 30.00123)
 $30.001
 >>> print("$.03f" % 30.00163)
 $30.002
 >>> print("%.03f" % 30.1777)
 30.178
 >>> print("%.03f" % 30.1113)
 30.111
```

** 示例说明 **
正如所见，如果指定的格式比要求Python显示的精度更高，Python不会截断当前的数。它将适当地进行数学上的四舍五入操作。

##### 2.3.3 可能会发生的错误
输入这些示例时，可能会犯错。显然，输入一个不同的数时，Python帮不了任何忙，得到的结果肯定会与本书不同。然而，对于作为格式说明符输入的字母对Python没有意义的情况，或者在提供给一个字符串格式说明符的序列中没有足够多的数值时，Python会试图给出尽可能多的信息，指出发生了什么问题，开发人员可以根据这些信息修复错误。

@(**试一试**)[出错]

为了理解错误发生后，接下来会发生什么，这里给出一些可以尝试的示例。从第4章开始将介绍它们完整的含义，但此时应当知道：
``` python
 >>> print("%.03f" % (30.1113, 12))
 Trackback (most recent call last):
   File"<input>", line 1, in ?
 TypeError: not all arguments converted during string formatting
```

** 示例说明 **

在上述代码中，序列中的元素（总共两个）多于字符串中的格式说明符（仅一个），因此Python给出一条帮助消息。这个错误将导致正在运行的程序停止运行，因此这通常是一个出错条件，或者称为异常。这里，词`arguments`指的是格式说明符，但通常用来代表使某个对象工作所需要的参数。当调用需要指定若干值的函数时，每个期望的值就叫做一个参数。

这是程序员认为理所当然的事；这种专门的技术语言可能不会立刻显得有意义，但是熟悉它之后就会感觉正确了。尽管为了减少困惑，在本书的前10章中，将把`arguments`当作参数，因为没有人会有争议，它们仅仅是用于设置在特定时刻要用到的条件。编程时，`arguments`和`parameters`是可以互换的。

下面列出了另外一个可能发生的错误：
``` python
 >>> print("%.03f, %f %d" % (30.1113, 12))
 Trackback (most recent call last):
   File"<input>", line 1, in ?
 TypeError: not enough arguments for format string
```
现在知道了Python中argument所代表的含义，错误消息的含义就是很显明了。代码中使用了一个格式说明符，但在伴随的序列中并没有一个值可以与之匹配，因此，没有足够多的参数。

如果尝试将字符串和数值相加，也将会出错：
``` python
 >>> "This is a string" + 4
 Trackback (most recent call last):
   File"<pyshell#13>", line 1, in <module>
 TypeError: Can't convert 'int' object to str implicitly
```
错误消息不难理解，因为前面已经介绍了执行这种操作的条件。不过下面给出了清晰的表述：Python清楚地告诉您哪些事它被告知去做但却做不了，因此需要自己解决问题（提示：可以使用str函数）。
```python
 >>> "This is a string""" + str(4)
 'This is a string4'
```

##### 2.3.4 几个不寻常的例子

Python还为数值提供了另外一个值得了解的特性，以便在遇到时可以理解它。通常我们使用十进制，即基数为10的计数系统。它包含0～9共10个数字。大于9的数字由0～9的各种组合表示。然而，计算机通常用八进制（octal)以及十六进制（hexadecimal）表示它们实际处理的二进制数。这些系统给程序员提供了一种了解数据字节的简单方法，数据经常由一到两个8位组成。

另外，不管是八进制还是十六进制都不能显示负数。用这种方法描述的数值叫做无符号数，与有符号数对应。`+`号和`-`是不同的。通常地，数值被认为是正数，但如果一个数是有符号的，它也可以是负数。如果一个数值是无符号的，它一定是正数。如果要求以无符号格式字符串显示负数，将得到预想不到的结果。

@(**试一试**)[将数字格式化为八进制和十六进制]

```Python
 >>> print('Octal uses the letter "o" lowercase. %d %o' % (10, 10))
 Octal uses the letter "o" lowercase. 10 12
```
将数值10提供给字符串时，第二个数却打印为12，看起来这像是个错误。然而八进制仅仅有8个数值（0～7），因此`0～10`用八进制表示依次是`0、1、2、3、4、5、6、7、10、11、12`。
```Python
 >>> print('Hex uses the letter "x" or "X". %d %x %X' % (10, 10, 10))
 Hex uses the letter "x" or "X". 10 a A
```
还有另外一个地方需要解释。十六进制使用`0～15`的数字，但是因为`9`这之后就没有数字了，所以十六进制用了字母`a～f`。如果使用格式说明符`%x`，这些字母是小写的；如果使用`%X`，它们则是大写的。因此，十进制的`0～19`用十六进制表示为：`0、1、2、3、4、5、6、7、8、9、a、b、c、d、e、f、10、11、12、13`。

#### 2.4 本章小结
本章介绍了Python中的数值，但是没有涵盖数值的所有方面。我们看到并使用了3种 Python内置的数字：整型数、浮点型数以及虚数。本章还介绍了如何用字符串格式说明符在字符串中包含数值，并且使用不同风格格式化了这些数值。

要重点记住，数值的格式（数值在字符串中的显示方式）并不会改变其值。即使打印成整型，浮点数仍然是浮点数，反之亦然。

本章执行了主要的内置的数学运算：加、减、乘、除以及取余。还介绍了如果整型和浮点型混合，结果为浮点型，如果两个整型数相除，可能也将适当地返回一个浮点型数。如果将整型或者浮点型数与虚数结合起来做数学运算，结果将是一个复数，复数分别有实部和虚部。本章还示范了`type`函数，该函数可以确定数值的类型。

最后，人们通常使用十进制数，而Python很容易将数值转换为八进制或者十六进制。

** 本章要点： **
* Python中有3种数值类型。它们分别是：整型数，即整数（正数和负数）；浮点型数，即带小数值的数；虚数，即`-1`的平方根，经常用于工程和物理计算。
* 当用于字符串时，`+`操作符可以将两个或多个字符串串联。例如，语句`print("Hello," + "how are you?")`的结果是一句话：“Hello, how are?”。
* 可以使用`str`函数将数值转换为字符串。
* 将两个整形数相除有时可能得到一个浮点型数（例如，3/2）。用一个浮点数除一个整型数，总会得到一个浮点数。
* 取余运算符（`%`）用来返回一则除法中的余数。例如，`5%2`将返回`1`.
* 计算中使用括号可以帮助确保以正确的顺序求值。

#### 2.5 习题
在记事本中完成前3个习题，并将结果保存于文件`ch2_exercises.py`中。在Python中，可以打开文件，选择Run Moudle运行它们。
1. 在Python Shell中，将`5`和`10`相乘。并尝试其他数值。
2. 打印数字6~14的八进制形式。
3. 打印数字9~19的十六进制形式。
4. 尝试从Python解释器中引出其他错误，例如故意将`print`拼错为`pinrt`。注意，在Python Shell的文件上工作时，它以不同方式显示`print`和`pinrt`。

### 第3章 变量
在前两章中，您学习了Python如何 看待字符串、整型、浮点型和虚数，以及如何创建和显示它们。本章将给出更多的示例，说明这些数据类型的用法。

本章将介绍：
* 使用名称存储已经了解的以及即将介绍的类型。
* 如何处理还未学习的不同类型的对象，如变量以及不同的新类型，学习本章后您将更加熟悉列表、无组和字典。
* 引用的概念及示例。
* 学习本章的重点是，应当新手输入示例代码并且更改它们，观察会发生什么。

#### 3.1 引用数据——使用数据的名称
在程序中总是地写字符串和数值是非常困难的，因为这迫使程序员记住所有的字符和数值等。计算机的内存使得它可以比人记住更多的细节，利用计算机的这种能力是编程中一个很大的部分。然而，为了更灵活简单地使用数据，可以给数据命名，之后可以用名称引用这些数据。

@(**试一试**)[给名称赋值]

这些名称一般叫做变量，表明它们引用的数据可以变化，而名称保持不变。您会看到变量也叫做名称（name），这是Python的叫法。
``` python
 >>> first_string = "This is a string"
 >>> second_string = "This is another string"
 >>> first_number = 4
 >>> second_number = 5
 >>> print("The first variables are %s, %s, %d, %d" % (first_string, second_string, first_number, second_number))
 The first variables are This is a string, This is another string, 4, 5
```

** 示例说明 **

可以用等号（=）将一个值（字符串或整型数）与名称关联。所用的名称并不与所指的数据直接相关（如果将一个数据命名为“number”，并不意味着它实际保存了一个数值。）
``` python
 >>> first_string = 245
 >>> second_number = "This isn't a number"
 >>> print(first_string)
 245
 >>> print(second_number)
 "This isn't a number"
```
注意，仅希望将一个变量的值打印出来时并不需要使用引号。如果在`print()`函数中将一个变量用引号括起来，函数会打印出这个变量的名称，而不是它的内容，这是因为程序把它看做一个字符串而不是一个变量。命名数据的好处是可以赋予它一个有着某种含义的名称。给数据起一个有意义的名称非常有必要，它可以说明数据所包含的内容，或者数据在程序中的使用方式 。如果打算清点家里所有的灯泡，您也许希望有一段程序包含壁橱中的灯泡数量，另外还有一段程序包含正在使用的灯泡的数量：
``` python
 >>> lightbulbs_in_closet = 10
 >>> lightbulbs_in_lamps = 12
```
使用灯泡时，把它们从壁橱中移到灯中，还可以给今年已经扔掉的灯泡数起一个名称，这样在年终，就会知道买了多少灯泡，瑞在有多少，以及使用过多少；当想知道还有多少灯泡时，只需要引用`lightbulbs_in_closet`或者`lightbulbs_in_lamps`即可。

当名称与其存储的值相关联时，就创建了一个非正式的索引，这样就可以查询并且记住信息存储的位置，从而便于在程序中使用它们。

##### 3.1.1 使用名称修改数据
如果数据是一个数值或者是一个字符串，可以通过已经知道的一些可用的操作修改它们。

@(**试一试**)[给名称赋值]

我们学过的关于数值和字符串的所有操作都可用于变量名，这样可以像处理它们所引用的数值那样处理它们：
``` python
 >>> proverb = "A penny saved"
 >>> proverb = proverb + " is a penny earned"
 >>> print(proverb)
 A penny saved is a penny earned
 >>> pennies_saved = 0
 >>> pennies_saved = pennies_saved + 1
 >>> print(pennies_saved)
 1
 print(pennies_saved + 1)
 2
```
** 示例说明 **
无论何时，在等号的右端使用已命名的值时，即使同样的名称出现在等号的左端，Python仍将这些名称看做它们所引用的值。当Python遇到这样的情况时，它首先对右边的名称求值并计算结果，然后将结果赋给左边的名称。这样，名称同时出现在等号两端时就不再引起混乱，Python会执行正确的操作。

##### 3.1.2 复制数据
给数据起的名称仅仅是个名称，是表示要访问的数据的一种方法。这意味着可以用多个名称引用同一个数据：
``` python
 >>> pennies_saved=1
 >>> pennies_earned = pennies_saved
 >>> print(pennies_earned)
 1
```
当再次使用`=`号时，就给名称赋予了一个已创建的新值，而另一个名称仍然指向原来的值。
``` python
 >>> pennies_saved = pennies_saved + 1
 >>> print(pennies_saved)
 2
 >>> print(pennies_earned)
 1
```

##### 3.1.3 禁用的名称以及一些规则
Python把一些名称作为特殊的内置词，它保留这些词用于特殊用途以防止出现多义性。下面列出了Python的保留词，不可以将它们用作数据的名称：
``` python
 and, as, assert, break, class, continue, def, del, elif, else,
 except, exec, False, finally, for, from, global, if, import, in,
 is, lambda, not, None, or, pass, print, raise, return, try, True,
 while, with, yield
```
另外，数据的名称不能以数值或者多数非字母的字符开头（例如逗号、加减号和斜杠等），但下划线例外。下划线是合法的，甚至在某些情形下有特殊含义（特别是用于类和模块时，详见第6章以及后续章节）。

在本章后面的讨论中将会看到许多这样特殊的保留字。在使用Python完成各式各样的任务时，它们非常重要。

#### 3.2 使用更多的内置类型
除了字符串和数值之外，Python还提供了另外4种重要的基本类型：无组、列表、集合和字典。这4种类型有许多共同点，因为它们都允许在一个名称下面组织多条数据。因为具有这种组织性，每个类型都允许在它们中查找元素。这些组织在一起的数据通过圆括号`()`、方括号`[]`和花括号`{}`表示。
> 在写程序或者读别人的程序时，如果看到一组元素，注意所使用的括号的类型是很重要的。`{}`、`[]`和`()`的区别非常重要。

##### 3.2.1 元组——不可更改的数据序列
在第1章和第2章中为字符串中的多个格式说明符赋值时，看到了元组（tuple）的应用。元组是值的序列，其中每个值都可以被单独访问，元组是Python的基本类型。在创建时就可以识别出元组，因为它们被圆括号包围：
``` python
 >>> print("A %s %s %s %s" % ("string", "filled", "by a", "tuple"))
 A string filled by a tuple
```

@(**试一试**)[创建和使用元组]

元组包含对数据的引用，例如对字符串和数值的引用。然而，虽然它们引用数据，但是仍然可以像其他类型的数据一样为它们命名：
``` python
 >>> filler = ("string", "filled", "by a", "tuple")
 >>> print("A %s %s %s %s" % ("string", "filled", "by a", "tuple"))
 A string filled by a tuple
```
注意，可以通过在`print()`函数中简单地调用元组，打印出其中的数据。尝试如下代码并观察结果：
``` python
 >>> filler = ("string", "filled", "by a", "tuple")
 >>> print(filler)
 ('string', 'filled', 'by a ', 'tuple')
```
可以看到，组成元组的4个部分被返回。这种技术在每次想查看组成元组的单个部分时非常有用。

** 示例说明 **
从上面的示例可以看出，filter（包含字符串的元组）的处理方式好像是它的元素都呈现出来并且被字符串用来填充格式说明符，因为元组的处理方式就好像输入一个序列来满足给定的格式规范。

可以访问元组中的单个值。每个元素引用的值可以通过该语言的解除引用特性直接访问。通过在元组的名称后放置方括号并且从零起计算出要引用的元素的位置，可以解除元组中对值的引用。因此，元组中第一个元素的位置是`0`，第二个元素的位置是`1`，第三个元素的位置是`2`，以此类推走到最后一个元素：
``` python
 >>> a = ("first", "second", "third")
 >>> print("The first element of the tuple is %s" % a[0])
 The first element of the tuple is first
 >>> print("The second element of the tuple is %s" % a[1])
 The second element of the tuple is first
 >>> print("The third element of the tuple is %s" % a[2])
 The third element of the tuple is first
```
元组知道它所包含的元素的数目，可以使用内置函数`len`得到这个数目：
``` python
 >>> print("%d" % len(a))
 3
```
这将返回元组中元素的数目（此处是3），因此需要记住`len`函数从`1`开始计数，但当访问元组时，由于元组从`0`开始计数，所以必须在比`len`返回的数小`1`的位置停止访问。
``` python
 >>> print(a[len(a) - 1])
 Third
```
元组中的一个元素也可以是对另外一个元组的引用。换句话说，可以创建嵌套元组：
``` python
 >>> b = (a, "b's second element")
 >>> print(b)
 (('first', 'second', 'third'), "b's second element")
```
现在可以通过在第一组方括号后面加上另外一组方括号来访问元组a中的元素，访问a中的第二个元素与访问第一个元素的方法相同，仅需再添加一组方括号即可。

@(**试一试**)[通过一个元组访问另外一个元组]

重新创建元组a和b，以便观察如何通过一个元组访问另外一个元组。嵌套的序列有时也被称具有多维，因为它们是两层，可以想象纵向和横向延伸，就像图纸或者电子表格上的二维风格一样。再增加第三层元组可被认为是三维的，像一堆积木一样。可视化超过三维的多维数据会令人头痛，将它们看做多层的嵌套的数据会好一些。
``` python
 >>> a = ("first", "second", "third")
 >>> b = (a, "b's second element")
 >>> print("%s" %b[1])
 b's second element
 >>> print("%s" % b[0][0])
 first
 >>> print("%s" % b[0][1])
 second
 >>> print("%s" % b[0][2])
 third
```

** 示例说明 **
在每种情形下，代码的工作原理仿佛是先遵循元组b的第一个元素的引用，之后遵循第二层元组中的每个值的引用（第二层的元组最初来源于元组a）。如同执行了如下操作一样：
``` python
 >>> a = ("first", "second", "third")
 >>> b = (a, "b's second element")
 >>> layer2 = b[0]
 >>> print(layer2[0])
 'first'
 >>> print(layer2[1])
 'second'
 >>> print(layer2[2])
 'third'
```
注意，元组从被创建起就存在一个奇怪的地方。若要创建包含一个元素的元组，必须在该元素之后加一个逗号：
``` python
 >>> single_element_tuple = ("the sole element",)
```
否则，将会创建一个字符串，在之后试图访问它时容易混淆。

元组可以包含各种类型的数据，但在创建之后，就不能再改变。元组是不可变的，Python中还有几个类型是不可变的（例如，字符串在创建之后是不可变的，那些看起来改变它们的操作实际上创建了新的字符串）。

元组是不可变的，因为它们用来存储一组有序的事物，这些事物在使用时是不可以更改的。试图更改元组中的元素将导致Python报错，就像第2章末尾的错误一样。
``` python
 >>> a[1] = 3
 Traceback (most recent call last):
   File "<stdion>", line 1, in ?
 TypeError: object does not support item assignment
 >>> print("%s" % a[1])
 second
```
在试图给元组中的元素赋值时，可以看到Python返回的错误是`TypeError`，意思是该类型并不支持此操作（等号会引起元组执行一个动作）。在这个示例中，试图使用元组`a`中的第二个元素引用一个整型数`3`，但这个却作将不会发生。相反，`a`保持不变。

如果试图引用元组中并不存在的元素，将发生一个不相关错误。如果试图引用`a`中的第四个元素，将得到一条错误（记住，由于元组从`0`开始对它的元素计数，因此要用数字`3`来引用第四个元素。）
``` python
 >>> a[3]
 Traceback (most recent call last):
   File "<pyshell#27>", line 1, in <module>
   a[3]
 IndexError: tuple index out of range
```
注意，这是一个`IndexError`错误，并且对错误的解释也已给出（尽管它没有告诉超出范围的索引值，但确实可以知道自己试图用元组中并不存在的索引值访问其中的一个元素）。要在程序中修复该错误，必须找出试图访问的值以及元组中元素的数目。相对于不提供错误提示的语言，Python使用找出这些错误变得容易。

##### 3.2.2 列表——可以更改的数据序列
列表如同元组，是包含从`0`开始引用的元素的序列。列表用方括号创建：
``` python
 >>> breakfast = ["coffee", "tea", "toast", "egg"]
```

@(**试一试**)[查看列表中的元素]

列表中的单个元素的访问方法与元组类似。像元组一样，列表中的元素从`0`开始引用，并且访问顺序也是从`0`开始直到末端。
``` python
 >>> count = 0
 >>> print("Today's breakfast is %s" % breakfast[count])
 Today's breakfast is coffee
 >>> count = 1
 >>> print("Today's breakfast is %s" % breakfast[count])
 Today's breakfast is tea
 >>> count = 2
 >>> print("Today's breakfast is %s" % breakfast[count])
 Today's breakfast is toast
 >>> count = 3
 >>> print("Today's breakfast is %s" % breakfast[count])
 Today's breakfast is egg
```

** 示例说明 **
当顺序访问列表中的多个元素时，有必要使用一个名称来存储目前在列表中所处的位置。在简单的示例中，应当采取这种做法以形成一种 习惯，实际中则总是会这样做。通常，用循环方法查看序列中的每一个元素（第4章将详细讨论循环）。

本例中手动完成了对`count`引用的值加`1`的工作，以遍历早餐列表中的每个元素，列出本周中4在的特色早餐。因为递增计数，不论`count`引用的数是什么，它都是早餐列表中被访问的元素索引。

使用列表与使用元组主要的区别在于，元组在创建后不可以修改，列表在任何时刻者可以被修改：
``` python
 >>> breakfast[count] = "sausages"
 >>> print("Today's breakfast is %s" % breakfast[count])
 Today's breakfast is sausages
```
不仅可以修改列表中已经存在的元素，还可以向列表中添加需要的元素。可以用列表类型的内置方法`append`向列表末端添加元素。利用`append`方法每次只能向列表末端添加一个元素：
``` python
 >>> breakfast.append("waffles")
 >>> count = 4
 >>> print("Today's breakfast is %s" % breakfast[count])
 Today's breakfast is waffles
```
如果希望一次性地向列表末端添加多个元素，例如一个元组或者其他列表的内容，可以使用`extend`方法。添加的列表并不是整体地作为原有列表的一个元素，相反，其中的每个元素将被复制到原来的列表中。
``` python
 >>> breakfast.extend(["juice", "decaf", "oatmeal"])
 >>> print(breakfast)
 ['coffee', 'tea', 'toast', 'egg', 'waffle', 'juice', 'decaf', 'oatmeal']
```
同元组一样，不可以请求列表以外的元素，但是出错消息与元组略有不同，因为错误消息将指出是列表索引超出范围，而不是元组索引超出范围。
``` python
 >>> count = 8
 >>> print("Today's breakfast is %s" % breakfast[count])
 Trackback (most recent call last):
   File "<pyshell#18>", line 1, in <module>
   print("Today's breakfast is %s" % breakfast[count])
 IndexError: list index out of range
```
列表的长度也通过`len`函数确定。就像元组一样，长度从`1`开始，而列表的第一个元素的位置从`0`开始。总是记住这一点非常重要。

##### 3.2.3 字典——以名称索引的分组数据
字典类似于列表和元组。它是包含一组数据的另外一种容器。然而，元组和列表以数字顺序索引，字典却用选择的名称索引。这些名称可以是字母、数值、字符串或者符号，自己认为合适即可。

@(**试一试**)[创建字典]

字典用花括号创建。刚开始，可以创建最简单的字典，即空字典，并通过逐行指定名称和值对它进行实例化。
```python
 >>> menus_specials = {}
 >>> menus_specials["breakfast"] = "Canadian ham"
 >>> menus_specials["lunch"] = "tuna surprise"
 >>> menus_specials["dinner"] = "Cheeseburger Deluxe"
```

** 示例说明 **
当初次为`menus_specials`赋值时，用花括号创建了一个空字典。一旦字典被定义并且通过名称引用，将开始使用如下方式对其实例化：将希望作为索引的名称放在方括号内，将通过该索引引用的值放在等号的右端。因为值由所选择的名称索引，所以可以使用上述形式给已经定义的任意字典分配索引和值。

使用字典时，索引和值都有特殊的名称。字典中索引的名称叫做键，对应的值叫做值。为了创建一个完全指定（或者可以认为它是完全形成的）的字典（一开始就指定了键和值的字典），必须在花括号之间指定每个键以及和它对应的值，并以冒号分隔它们。例如，另外一天的特色菜可以一次性定义：
``` python
 >>> menu_specials = {"breakfast" : "sausage and eggs",
 ... "lunch" : "split pea soup and gralic bread",
 ... "dinner": "2 hot dogs and onion rings"}
```
为了打印出某个字典中所有的键与值，只需将字典的名称作为`print()`函数的参数，如下面的代码所求。为了访问字典中的值，可以将键放在方括号中。如果键是字符串，需要将键放在引号中。如果键是数值（可以用数值创建字典，这样的字典十分类似于列表和元组），仅使用数值就可以了。
``` python
 >>> print(menu_specials)
 {'lunch':'split pea soup and garlic bread', 'breakfast':'sausage and eggs',
 'dinner': '2 hot dogs and onion rings'}
 >>> print("%s" % menu_specials["breakfast"])
 sausage and eggs
 >>> print("%s" % menu_specials['lunch'])
 split pea soup and garlic bread
 >>> print("%s" % menu_specials["dinner"])
 2 hot dogs and onion rings
```
如果键是一个字符串，但是在方括号中意外地没有将键放在引号中，Python就试图将它看做一个名称，需要解除对它的引用来找到键。大部分情况下，这将引起`NameError`异常，除非凑巧找到了一个与该字符串相同的名称，但这时又可能得到一个`IndexError`错误。

@(**试一试**)[创建字典]

如果知道如何询问，字典可以告诉您它所有的键，或者所有的值。`keys`方法要求字典以视图的方式返回所有键，以便用户查找所需的键，`values`方法也将以视图的形式返回所有的值。
``` python
 >>> hungry=menu_specials.keys()
 >>> print(list(hungry))
 lunch
 breakfast
 dinner
 >>> starving=menu_specials.value()
 >>> print(list(starving))
 split pea soup and garlic bread
 sausage and eggs
 2 hot dogs and onion rings
```

** 示例说明 **
`key`和`values`方法都返回视图，可以像其他常规的视图一样使用这些视图并为其赋值。如果从`keys`方法得到视图中的项，可以使用视图中的项（也就是键），得到字典中与之匹配的值。注意，尽管一个特定键可以找出一个值，但是不能从一个值开始可靠地找到与该值关联的键。当根据书籍的仅有的值试图寻找键时，需要彻底测试该值所有可能的键，尽管如此，仍可能存在两个不同的键与相同的值关联的情况。

字典的工作原理是每个键都是不同的（不可以有完全相同的两个键），但是可以有多个重复的值：
``` python
 >>>menu={"breakfast": "spam", "lunch": "spam", "dinner": "Spam with a side of Spam"}
 >>>print(menu)
 {'lunch':'spam', 'breakfast':'spam', 'dinner':'Spam with a side of Spam'}
 >>> menu.get("lunch")
 'spam'
 >>> menu.get("breakfast")
 "spam"
```
可见，Python允许在不同的键下有多个值。然而，尝试如下代码并观察会发生什么，这段代码试图用同样的名称创建不同的键：
``` python
 >>>menu2={"breakfast": "spam", "breakfast":"ham", dinner":"Spam with a side of Spam:"}
 >>>menu2.get("breakfast")
 'ham'
```
这里发生了什么呢？尽管没有得到错误消息，代码中仍然有错误。当输入第二个叫做“breakfast”的键时，Python替换了相同名称的第一个键的值。

##### 3.2.4 像列表一样处理字符串

Python给字符串提供了一个有趣的特性。有时，能够将字符串当作单个字符的列表那样处理很有帮助。在字符串的末端有无关字符并不罕见。人们也许没有识别出它们，但计算机遇到它们时会挂起。仅需要看字符串的首字符就知道如何处理该字符串的情况也很常见。例如，如果有一个姓与名的列表，您可以使用与列表相同的语法查看名与姓的第一个字符。这种看待字符串的方法叫做分片（slicing），是Python比较有趣的一个特性。
``` python
 >>>last_names=["Douglass", "Jefferson", "Williams", "Frank", "Thomas"]
 >>> print("%s" % last_names[0])
 Douglass
 >>> print("%s"% last_names[0][0])
 D
 >>> print("%s" % last_names[1])
 Jefferson
 >>> print("%s"% last_names[1][0])
 J
 >>> print("%s" % last_names[2])
 Williams
 >>> print("%s"% last_names[2][0])
 W
 >>> print("%s" % last_names[3])
 Frank
 >>> print("%s"% last_names[3][0])
 F
 >>> print("%s" % last_names[4])
 Thomas
 >>> print("%s"% last_names[4][0])
 T
```
例如，可以根据字符串的字母顺序将字典中的元素以姓的首字母分组。并不需要做任何复杂的操作，只需要检查包含名字的字符串以哪个字母开头，并以此对名字归档即可。
``` python
 >>> by_letter = {}
 >>> by_letter[last_name[0][0]] = last_name[0]
 >>> by_letter[last_name[1][0]] = last_name[1]
 >>> by_letter[last_name[2][0]] = last_name[2]
 >>> by_letter[last_name[3][0]] = last_name[3]
 >>> by_letter[last_name[4][0]] = last_name[4]
```
通过使用字符串的分片功能，字典`by_letter`仅包含所有姓的首字母。因此，`by_letter`是根据每个姓的首字母索引的字典。也可以令`by_letter`中的每个键引用一个列表，并使用列表`append`方法创建以相同字母开头的一列名字（当然，前提是您希望拥有一个索引了更大的一组名字的字典，其中每个名字都以相同的字母开头）。

** 非常有用的字符串分片 **
如果刚刚接触编程，字符串分片最初看上去是一个不同寻常的特性。使用过C或者C＋＋这样的低级语言的程序员学习过如何将程序中的字符串看做特殊的列表（在Python中也可以对列表分片，如后面所示），对他们而言，这个我很自然。对于读者而言，一旦学习了如何在列表上控制元素上控制元素的重复，它将是一个非常方便的工具。

##### 3.2.5 特殊类型
Python包含几个特殊类型。前面已经介绍过它们，但在此仍有必要单独介绍：`None`、`True`和`False`都是特殊的内置值，可以在不同的时刻发挥作用。

`None`较特殊，因为仅有一个`None`。无论使用了多少镒，它都只是一个名称，除了它本身以外没有任何其他对象可与之匹配。如果函数没有可以返回的值，即当函数没有可以响应的动作时，它将返回`None`。

`True`和`False`是数值`0`和`1`的特殊表示。这就防止了在其他语言中比较常见的混乱，即一个语句的真值是任意的。例如，在Unix Shell中（Shell不仅是与系统交互的平台，也是一门程序语言），`0`是真，其他值都是假。而在C和Perl中，`0`是假，其余值是真。

然而，在这些情形中，没有内置的名称可以区分这些值。Python通过显示地命名这些值，使得区分这些值变得更容易。名称`True`和`False`可用于基本的比较，您将看到许多这样的示例。在第4章中将介绍这些比较如何显著地影响程序，实际上，它们可以用来在程序中做决策。
``` python
 >>> Ture
 True
 >>> False
 False
 >>> True == 1
 True
 >>> Ture == 0
 False
 >>> False == 1
 False
 >>> False == 0
 Ture
 >>> false > 0
 False
 >>> False < 1
 True
```

#### 3.3 序列的其他共有属性
元组和列表是两种类型的序列。前面也已介绍过，在某些情形下，可以像序列那样访问字符串。字符串是有意义的，因为可以将字符串中的字母看做一个序列。

尽管字典代表一组数据，但它们不是序列，因为它们没有一个从头至尾的特定顺序，而这是序列的一个特性。

##### 3.3.1 引用最后一个元素
所有的序列类型都提供了一些捷径，使得它们用起来更加方便。经常需要知道一个序列最后一个元素的内容，有两种方法可以得到该信息。一种方法是获取列表中元素的个数，之后使用该数直接访问值：
``` python
 >>> last_anmes = ["Douglass", "Jefferson", "Williams", "Frank", "thomas"]
 >>> len(last_names)
 5
 >>> last_element = len(last_names) - 1
 >>> print("%s" % last_names[last_element])
 Thomas
```
然而，这个方法分为两步。作为程序员，重复地在程序中输入这些代码非常耗时，Python提供了一个捷径，使得可以通过使用数值`-1`访问一个序列的最后个元素，使用数值`-2`访问倒数第二个元素，通过使用从数`-1`到负的列表长度（在`last_name`列表中是`-5`），可以将列表的顺序颠倒过来。
``` python
 >>> print("%s" % last_names[-1])
 Thomas
 >>> print("%s" % last_names[-2])
 Frank
 >>> print("%s" % last_names[-3])
 Williams
```

##### 3.3.2 序列的范围
您可以获取序列的一部分，从中提取一个片段，创建可以单独使用的一个副本。创建这些分级的方法叫做分片（与对字符串进行相同操作时所用的术语相同）。当从一个列表或者元组中创建一个片段时，得到的片段与创建该片段的数据类型一致，从字符串分片的示例中已经看到了这一点。例如，从列表中创建的片段是一个列表，从元组中创建的片段是一个元组，字符串的片段还是字符串。

@(**试一试**)[将序列分片]

前面已经学过如何将字符串分片，下面试着用同样的方法对元组、列表和字符串进行分片，并看看结果是什么：
``` python
 >>> slice_me = ("The", "next", "time", "we", "meet", "drinks", "are", "on", "me")
 >>> sliced_tuple = slice_me[5:9]
 >>> print(sliced_tuple)
 ('drinks', 'are', 'on', 'me')
 >>> slice_this_list = ["The", "next", "time", "we", "meet", "drinks", "are", "on", "me"]
 >>> sliced_list = slice_this_list[5:9]
 >>> print(sliced_list)
 ['drinks', 'are', 'on', 'me']
 >>> slice_this_string = "The next time we meet, drinks are on me"
 >>> sliced_string = slice_this_string[5:9]
 >>> print(sliced_string)
 'ext '
```
** 示例说明 **

在每种情形下，用冒号指定序列的一个片段指示Python创建一个新的序列，新序列恰好包含了片段中的元素。

##### 3.3.3 通过附加序列增长列表
假设希望将两个表连接在一起。我们还没看到专门用于这个目的的方法。不能用`append`方法将一个序列附加到另一个序列的末端，这样得到的结果是向列表中增加了一个分层的序列。
``` python
 >>> living_room = ("rug", "table", "chair", "TV", "dustbin", "shelf")
 >>> apartment = []
 >>> apartment.append(living_room)
 >>> apartment
 [('rug', 'table', 'chair', 'TV', 'dustbin', 'shelf')]
```
如果打算根据元组`living_room`的内容创建一个新的列表，并使用该列表创建包含`apartment`中所有元素的列表，以上所示并不是希望看到的结果。

为了复制一个序列中的所有元素，可以使用列表和元组的`extend`方法，而不是`append`方法，`extend`方法将给定序列中的每个元素插入到调用它的列表中。
``` python
 >>> apartment = []
 >>> apartment.extend(living_room)
 >>> apartment
 ['rug', 'table', 'chair', 'TV', 'dustbin', 'shelf']
```

##### 3.3.4 使用列表临时存储数据
经常需要从其他来源获取数据，例如，用户输入的数据或者另外一台计算机上的信息。为此，最好将这些数据存放在一个列表中，这样就可以在随后按照数据进入列表的顺序对其进行处理。

然而，在处理完 数据之后，不再需要将这些数据保存在于列表中，因为不再需要它们。特定时间有效的信息（例如证券报价信息、天气预报或者新闻标题等）都属于这类信息。

为了防止列表变得笨重，可以使用`pop`方法在处理完列表的一个数据之后，将其引用从列表中删除。当删除引用之后，它原来在列表中占据的位置会填上后续元素，列表减少的元素个数等于已经弹出的元素个数。

@(**试一试**)[从列表中弹出元素]

需要告诉`pop`方法所要操作的元素。如果告知它处理元素`0`，它将弹出列表中的第一项，向`pop`传递参数`1`告诉它使用位置`1`的项（列表中的第二个元素），依此类推。`pop`所操作的元素与使用方括号访问的列表元素具有相同的索引（记住，列表中第一个元素的位置为`0`）：
``` python3
 >>> todays_temperatures = [23, 32, 33, 31]
 >>> todays_temperatures.append(29)
 >>> todays_temperatures
 [23, 32, 33, 31, 29]
 >>> morning = todays_temperatures.pop(0)
 >>> print("This mornings temperature was %.02f" % morning)
 This mornings temperature was 23.00
 >>> late_morning = todays_temperatures.pop(0)
 >>> print("Todays late morning temperature was %.02f" % late_morning)
 Todays late morning temperature was 32.00
 >>> noon = todays_temperatures.pop(0)
 >>> print("Todays noon temperature was %.02f" % noon)
 Todays noon temperature was 33.00
 >>> todays_temperatures
 [31, 29]
```

** 示例说明 **

当弹出一个值时，如果操作是在秸的右端，可以将删除的元素赋给左边的值，或者仅在合适的情形下使用该值。如果没有将弹出的值赋给其他变量，也没所有使用它，它将被丢弃。

通过只使用`pop`填充字符串格式，也可以避免使用中间名称，因为`pop`将返回列表中的指定元素，可以像已经指定了一个数值或者引用一个数值的名称那样使用该元素：
``` python
 >>> print("Afternoon temperature was %.02f" % todays_temperatures.pop(0))
 Afternoon temperature was 31.00
 >>> todays_temperatures
 [29]
```
如果没有告诉`pop`要删除列表中的哪个元素（在上面的示例中是`0`），它将删除列表中的最后一个元素，而不是这里所示的第一个元素。

##### 3.3.5 处理集合
在Python中，集合与字典类似，只是它仅包含键，而没有与键相关联的值。本质上，集合是不包括重复数据的数据集。在从数据集删除重复数据时，集合非常有用。

有两种类型的集合：可变集合与不可变集合（frozenset）。两者的不同之处在于，对于可变集合，可以增加、删除、或者改变它的元素，而不可变集合的元素在它们被初始设定之后就不能再被更改。

@(**试一试**)[删除重复的元素]

本例中执行了赋值操作，并且通过把这些值赋给一个集合删除了重复的地元素：
``` python
 >>> alphabet = ['a', 'b', 'b', 'c', 'a', 'd', 'e']
 >>> print(alphabet)
 ['a', 'b', 'b', 'c', 'a', 'd', 'e']
 >>> alph2 = set(alphabet)
 {'a', 'c', 'b', 'e', 'd'}
```

** 示例说明 **
该示例接受数据集`alphabet`作为输入，并将其转换为一个集合。因为集合不允许重复的值，多余的字符`b`和`a`被删除。之后`alphabet`被赋给`alph2`，并且被打印以显示结果。

#### 3.4 本章小结

本章介绍了如何操作Python提供的多种核心类型。这些类型是元组、列表、字典、集合以及三种特殊类型：`None`、`True`和`False`。本章还介绍了可以将字符串当作序列处理的特殊方法。元组和列表是另外两种序列类型。

元组是从`0`开始以固定数值顺序索引的一个数据序列。元组中的引用在元组被创建后不能再改变，也不能再增加或者删除元素。然而，如果元组包含可变元素的数据类型，例如列表，该数据类型的元素是可以改变的。元组在序列中的数据不会改变时很有用，例如，当希望地阻止数据被意外改变时。

列表是另一种序列，除了它的元素可被修改之外，它与元组类似。列表的长度可以改变，以容纳使用`append`方法新增加的元素，另外也可以通过`pop`方法缩减列表的长度。如果希望将一个序列中的数据附加到一个列表中，可以使用列表的`extend`方法一次性将序列中的所有元素添加到列表中。

字典是另外一种有索引的数据分组。列表和元组以数值为索引，而字典通过所选的值索引。如果想研究这些索引（叫做键），可以调用`keys`方法。为了研究被引用的数据（叫做值），可以使用`values`方法。这两个方法都返回列表。

集合是项集（0个或者多个项），不允许包含重复的值。理论上，它们与字典类似，不过它们只包含键，而没有与键相关联的值。集合的一个用途是从数据集中去除冗余的值。它们也很擅长模仿有穷的数学集合。

其他的数据类型还有`True`、`False`和`None`。`True`和`False`是看待`1`和`0`的特殊方式，但当希望测试某件事为真还是为假时，显式地使用名称`True`和`False`总是正确的做法。`None`是Python内置的只与它自己相等的特殊值，当函数不能返回任何值（例如`True`、`False`、字符串或者其他值）时得到的返回值就是`None`。

** 本章要点 **

* 变量是用来引用数据的名称。
* 利用语法：变量名称＝“某值“，可以创建一个变量。
* 可以通过将一个变量赋给另一个变量来复制它的值：变量名称＝要复制的变量名称。
* 元组存储多个数据并且不可以更改。
* 列表也是数据序列，与元组不同的是，可以改变它们的值。
* 字典与列表和元组类似。它是另外一种数据容器类型。元组和列表以数值顺序索引，而字典通过所选择的名称索引。这些名称可以是字母、数值、字符串或符号，适合自己需要即可。

#### 3.5 习题
在Python Shell中完成如下任务：
1. 使用超市奶制品部的4个元素创建一个列表`dairy_section`。
2. 打印由`dairy_section`列表的第一个和最后一个元素组成的字符串。
3. 创建元组`milk_expiration`，它包含3个元素：最近一罐牛奶的过期日期的年、月和日。
4. 以字符串“This milk carton will expire on 12/10/2009”的形式输出元组`milk_expiration`中的值。
5. 创建空字典`milk_carton`。添加如下的键/值对。可以虚构值，也可以使用一罐真正的牛奶：
> * `expiration_date`：将它设为`milk_expiration`元组。
> * `fl_oz`：将它设为您所住所的牛奶罐的尺寸。
> * `Cost`：将它高为这罐牛奶的价格。
> * `brand_name`：将它高为使用的牛奶的品牌名称。
6. 打印字典`milk_carton`中所有元素的值，使用字典中的值，而不要使用元组`milk_expiration`中的数据。
7. 根据`milk_carton`的价格，显示如何计算6罐牛奶的价格。
8. 创建列表`cheeses`。列出可以想到的所有奶酪。将该列表附加到列表`dairy_section`中，并且相看`dairy_section`的内容。之后从中删除`cheeses`列表。
9. 如何计算`cheeses`列表中奶酪的个数？
10. 打印每个奶酪名称的前5个字母。

## 第II部分 Python语言和标准库

### 第4章 做出决策

到目前为止，我们学习了如何直接操作数据，以及如何通过与数据绑定的名称操作它们。对如何手动操作这些数据类型有了基本的理解后，就可以开始实践所学到的关于数据类型的知识，并使用数据做出决策。

本章将介绍Python如何利用`True`和`False`做出决策，以及如何根据一个条件是`True`还是`False`做出更复杂的决策。

本章将介绍：
* 如何创建可以使用循环重复相同操作的情形，以自动逐步遍历列表、元组和字典。
* 如何协同使用字典、列表和元组，以探究字典中的内容。
* 如何使用异常处理编写程序，以应对可能在程序内部处理的问题。

#### 4.1 比较两个值是否相等
第3章中出现了`True`和`False`，但没有介绍如何使用它们。`True`和`False`是比较两个值、问句以及执行其他一些操作的结果。然而，可以被赋值和命名的任何事物都可以用一组返回`True`和`False`的比较运算来比较。

@(**试一试**)[比较两个值是否相等]

用两个等号测试是否相等。记住，单个等号将数据绑定到一个名称，与这里希望执行的操作不同，这里将得出`True`和`False`：
``` python
 >>> 1 == 1
 True
 >>> 1 == 2
 False
```

** 示例说明 **

当进行相等性比较时，Python比较双等号两端的值。如果数值不同，结果为`False`。如果数值相同，结果为`True`。

即使数值类型不同，Python仍然能够比较它们并且给出正确的答案：
``` python
 >>> 1.23 == 1
 False
 >>> 1.0 == 1
 True
```
也可以用双等号来测试两个字符串的内容是否相同，甚至可以将该测试限定在字符串的某个局部范围内（回忆上一章中介绍的分片，它复制了所引用的字符串的部分内容，因此实际上比较的两个字符串代表了分片所涵盖的内容）：
``` python
 >>> a = "Mackintosh apples"
 >>> b = "Black Berries"
 >>> c = "Golden Delicious apples"
 >>> a == b
 False
 >>> b == c
 False
 >>> a[-len("apples"):-1] == c[-len("apples"):-1]
 True
```
在Python中，序列也可以用双等号比较。Python认为，如果每个序列中同一位置的每个元素都相同，那么两个序列相等。因此，如果有两个序列中分别包含4项，这4项的数据相同，但顺序不同，那么这两个序列不相等：
``` python
 >>> apple = ["Mackintosh", "Golden Delicious", "Fuji", "Mitsu"]
 >>> apple_trees = ["Golden Delicious", "Fuji", "Mitsu", "Mackintosh"]
 >>> apples == apple_trees
 False
 >>> apple_tree = ["Mackintosh", "Golden Delicious", "Fuji", "Mitsu"]
 >>> apples == apple_trees
 True
```
另外，字典也可以比较。像列表一样，一个字典中的每个键与值（一组）必须与另外一个字典中的键与值一一对应，其中第一个字典中的键与第二个字典中的键相等，第一个字典中的值也与第二个字典中的值相等：
``` python
 >>> tuesday_breakfast_sold = {"pancakes":10, "french toast":4, "bagels":32, "omelets":12, "eggs and sausages":13}
 >>> wednesday_breakfast_sold = {"pancakes":8, "french toast":5, "bagels":22, "omelets":16, "eggs and sausages":22}
 >>> tuesday_breakfast_sold == wednesday_breakfast_sold
 False
 >>> thursday_breakfast_sold = {"pancakes":10, "french toast":4, "bagels":32, "omelets":12, "eggs and sausages":13}
 >>> tuesday_breakfast_sold == thursday_breakfast_sold
 True
```

#### 4.2 比较两个值是否不相等
有一个运算与相等比较相反。如果将感叹号和等号一起使用，可以要求Python比较两个值是否不相等（使用与相等比较同样的规则），如果不相等，得到`True`值。

@(**试一试**)[用加号串联字符串]

尝试如下示例，观察Python如何对这些比较求值：
``` python
 >>> 3 == 3
 True
 >>> 3 != 3
 False
 >>> 5 != 4
 True
```
** 示例说明 **

如果一对数用`==`比较时得到`True`值，在这晨将得到`False`；如果两个数在用`==`比较时得到`False`，在这里将得到`True`。

这些规则同样适用于更加复杂的类型，如序列和字典：
``` python
 >>> tuesday_breakfast_sold != wednesday_breakfast_sold
 True
 >>> tuesday_breakfast_sold != thursday_breakfast_sold
 False
```
像数值一样，这些类型当用`==`比较为`True`时，在用`!=`比较时将为`False`。

#### 4.3 比较两个值的大小
相等性比较并不是找出希望知道的信息的唯一方法。有时，希望了解某物的数量是否大于另外一个，或者某个值是否小于另外一个值。Python提供了大于和小于运算，可以用`>`和`<`进行调用。这些符号与数学书上介绍的符号相同，用于比较左边的值是否大于（>）或者小于（<）右边的值。

@(**试一试**)[比较大于和小于]

``` python
 >>> 5 < 3
 False
 >>> 10 > 2
 True
```

** 示例说明 **

左边的值与右边的值进行比较。也可以比较字母。在某些条件下，这些比较运算也许会得出意外的结果，例如尝试比较字母和数值（这个问题在许多情形下不会发生，所以您的期望与Python的期望不尽相同）。字母表中字母的值大概以这样的方式排序：大写的“A”是最小的字母，之后“B”，之后是“C”一直到“Z”。随后是小写字母，其中“a”是最小的小宝字母，“z”是最大的小写字母。然而，“a”大于“Z”：
``` python
 >>> "a" > "b"
 False
 >>> "A" > "b"
 False
 >>> "A" > "a"
 >>> "b" > "A"
 True
 >>> "Z" > "a"
 False
```
如果希望比较两个包含多个字符的字符串，Python将观察每个字母，走到找到一个不同的字母为止。比较的结果将取决于不同的字母。如果两个字符串完全不同，第一个字母就将决定结果：
``` python
 >>> "Zebra" > "aardvark"
 False
 >>> "Zebra" > "Zebrb"
 False
 >>> "Zebra" < "Zebrb"
 True
```
通过使用字符串的特殊方法`lower`，可以避免比较两个相似单词由于大小写不同而引起的问题，`lower`方法可以将调用它的字符串中的所有字母都变为小写，然后返回一个新字符串。还有一个对应的`upper`方法。它们适用于Python中的所有字符串：
``` python
 >>> "Pumpkin" == "pumpkin"
 False
 >>> "Pumpkin".lower() == "pumpkin".lower()
 True
 >>> "Pumpkin".lower()
 'pumpkin'
 >>> "Pumpkin".upper() == "pumpkin".upper()
 True
 >>> "pumpkin".upper()
 'PUMPKIN'
```
注意，也可以用如下方式编写上述代码：
``` python
 >>> "Pumpkin".lower() == "pumpkin"
 True
```
由于“pumpkin”已经是小写的，就没有必要再改变它，尽管这样做可能更安全。例如。如果某人错误地输入了一个字符串，将字符串中的某个字母大写，将两者都进行大小写转换可以避免一些错误。观察如下代码：
``` python
 >>> "Pumpkin".lower() == "puMpkin"
 False
 >>> "Pumpkin".lower() == "puMpkin".lower()
 True
```
当通过名称引用字符串时，仍旧可以访问字符串通常具有的所有方法：
``` python
 >>> gourd = "Calabash"
 >>> gourd
 'Calabash'
 >>> gourd.lower()
 'calabash'
 >>> gourd.upper()
 'CALABASH'
```

** 大于等于和小于等于 **

大于和小于各有一个有用的变体，即大于等于和小于等于。以某种方式将两个符号结合使用时显得很有意义：
``` python
 >>> 1 > 1
 False
 >>> 1 >= 2
 False
 >>> 10 < 10
 False
 >>> 10 <= 10
 True
```

#### 4.4 对真值和假值取反
在创建一种情形并比较其结果时，有时希望知道结果是否为真，有时希望知道结果是否不为真。Python提供了一个操作来实现相反的情形：使用单词`not`将会对它后面的值取反。

@(**试一试**)[对测试的结果取反]

``` python
 >>> not True
 False
 >>> not 5
 False
 >>> not 0
 True
 >>> Not True
 SyntaxError: invalid syntax (<pyshell#30>, line 1)
```
注意最后一行代码中的错误。一定不要将`not`运算符大写，否则将得到一条与此处类似的错误消息。

** 示例说明 **
`not`运算符用于任何得出`True`或者`False`结果的测试中。然而，第3章中提到，任何非零值都被看做`True`，因此可以在预期之外或者不一定有意义的情形下使用`not`：
``` python
 >>> not 5 > 2
 False
 >>> not "A" < 3
 True
 >>> not "A" < "z"
 False
```

#### 4.5 观察多个比较运算的结果
也可以将多个运算的结果合并，这使得程序可以通过多个运算求真值，做出更加复杂的决策。

一种组合是`and`运算，它的含义是：“如果左边的运算、值或者对象为`True`，接着对右边求值。如果左边不为`True`，就停止运算并且输出结果`False`，不再继续运算。”

``` python
 >>> True and True
 True
 >>> False and True
 False
 >>> True and False
 False
 >>> False and False
 False
```
另外一种组合运算是`or`运算。使用`or`告诉Python对左边的表达式求值，如果它为`False`，Python将继续对右边的表达式求值。如果它为`True`，Python将停止对更多的表达式求值：
``` python
 >>> True or True
 True
 >>> True or False
 True
 >>> False or True
 True
 >>> False or False
 False
```
您也许想基于希望发生的动作将多个这样的运算放在一起。这些情形下，从最最左边的`and`或者`or`开始求值，根据之前的规则继续对后续运算求值——换言之，直到在`and`运算中求出`False`值，或者在`or`运算中求出`True`值。

** 如何做出决策 **
Python有一种非常简单的做出决策的方法。用于做出决策的保留字是`if`，它后面跟着一个判断条件是否为真的测试，该测试以冒号结束，所以在这里可以看到它被写作`if ... :`。它可用于求值为`True`和`False`的任何情形，表示“如果某条件为真，执行以下操作”：
``` python
 >>> if 1 > 2:
 ...    print("No it is not!")
 ...
 >>> if 2 > 1:
 ...    print("Yes it is!")
 ...
 Yes, it is!
```
仅当`if`和冒号之间的语句的值为`True`时，缩进的语句才会被Python访问并求值。`if`语句中的缩进表明接下来的代码虽然是程序的一部分，但只有在合适的条件发生时才被执行。对于`if ... :`语句，合适的条件是指当比较运算的结果为`True`时。

您已经看到了`Python`在代码表现中最具有特色的一面，这也是大部分人在使用Python时容易发表评论的一个方面。

在Python程序中看到冒号时，它指出Python进入了程序中与其余部分相对独立的一部分。此时，缩进变得很重要。Python通过缩进知道一个特定的代码块与周围的代码保持独立。所用的空格数很重要，面向Python的代码编辑器总是帮助保持正在编写的代码具有正确的缩进。空格数很重要，因此应该使用编辑器确定缩进，并且不要手动改变空格数。

后面将看到更多的与冒号成对出现的关键字；在这些情形下，需要注意缩进。当程序改变了缩进，导致Python无法理解时，它会显示一个错误。

也可以将一个`if ... :`语句放在另外一个`if ... :`语句中，以做出比使用`and`和`or`更加复杂的决策，因为使用`if ... :`可以在对缩进的`if ... :`语句求值之前执行任意一组需要的语句。

@(试一试)[在测试中嵌套测试]

尝试如下示例，其中一个`if ... :`语句出现在另一个当中：
``` python
 >>> omelet_ingredinents = {"egg":2, "mushroom":4, "pepper":1, "cheese":1, "milk":1}
 >>> fridge_contents = {"egg":10, "mushroom":20, "pepper":3, "cheese":2, "tomato":4, "milk":15}
 >>> have_ingredients =[False]
 >>> if fridge_contents["egg"] > omelet_ingredinents["egg"]:
 ...    have_ingredients[0] = True
 ... have_ingredients.append("egg")
 ...
 >>> print(have_ingredients)
 [True, 'egg']
 >>> if fridge_coutents["mushroom"] > omelet_ingredients["mushroom"]:
 ...    if have_ingredients[0] == False:
 ...        have_ingredients[0] = True
 ...    have_ingredients.append("mushroom")
 ...
 >>> print(have_ingredients)
 [True, 'egg', 'mushroom']
```

** 示例说明 **

当一个条件经`if ... :`测试之后，如果还有下一级缩进，Python将继续对在该缩进中放置的代码求值。如果第一个`if ... :`不为真，它下面的任何代码都不会被求值，而将被完全跳过。

然而，如果第一个`if ... :`语句为真，同级的第二个条件将被计算。比较的结果仅决定它下面缩进的代码是否即将被执行。同级别的以及上层代码不会停止，除非有一些特殊的事件发生，例如，一个错误或者一个阻止程序继续运行的条件。

如从`print()`函数看见的那样，当Python检查发现冰箱里的鸡蛋和蘑菇多于煎蛋卷配方所需的鸡蛋和蘑菇时，就会将这两项添加到`have_ingredients`变量中。

为了完成示例，可以输入如下代码（如果希望用计算机表示一个煎蛋卷的话）：
``` python
 >>> if fridge_contents["pepper"] > omelet_ingredients["pepper"]:
 ...    if have_ingredients[0] == True:
 ...        have_ingredients[0] = False
 ...    have_ingredients.append("pepper")
 ...
 >>> if fridge_contents["cheese"] > omelet_ingredients["cheese"]:
 ...    if have_ingredients[0] == False:
 ...        have_ingredients[0] = True
 ...    have_ingredients.append("cheese")
 ...
 >>> if fridge_contents["milk"] > omelet_ingredients["milk"]:
 ...    if have_ingredients[0] == True:
 ...        have_ingredients[0] = False
 ...    have_ingredients.append("milk")
 ...
 >>> if have_ingredients[0] == True:
 ...    print("I have the ingredients to make an omelet!")
 ...
 I have the ingredients to make an omelet!
```
可以以`if ... :`开头，使用`elif ... :`创建一个测试链。`elif ... :`仅当前面的条件不满足时，才允许测试多个条件。如果使用一系列的`if ... :`语句，它们将被执行。如果在`if ... :`后面使用一个`elif ... :`语句，那么`elif ... :`仅在`if ... :`语句返回`False`时被求值。
``` python
 >>> milk_price = 1.50
 >>> if milk_price < 1.25:
 ...    print("Buy two cartons of milk, they're on sale")
 ... elif milk_price < 2.00:
 ...    print("Buy one carton of milk, prices are normal")
 ... elif milk_price > 2.00:
 ...    print("Go somewhere else! Milk costs too much here")
 ...
 Buy one carton of milk, prices are normal
```
还可以插入一个贯穿`（fall-throught）`语句来处理之前的所有测试都滑的返回`True`的情形：
`else:`语句。如果`if ... :`和`elif ... :`语句都没有值为`True`的测试条件，`else:`语句将被调用：
``` python
 >>> OJ_price = 2.50
 >>> if OJ_price < 1.25:
 ...    print("Get one, I'm thirsty.")
 ... elif OJ_price <= 2.00:
 ...    print("Ummm... sure, but I'll drink it slowly.")
 ... else:
 ...    print("I don't have enough money. Never mind.")
 ...
 I don't have enough money. Never mind.
```

#### 4.6 循环
您已经看到有很多次都需要检查和比较序列或字典中的每个元素。手动完成这项工作异常乏味，而且难免出错，即使是一个打字飞快的打字员也不例外。而且，如果手动输入这些代码，将不可避免地发生输入错误，并且当正在计算的某些变量或者值在其他地方被更改时，手动输入的代码很难相应地做出改变。

为了执行重复的任务，Python提供了两种循环运算。两者很相似，实际上，它们几乎是等同的，但是每一种运算都从不同的角度考虑问题，因此应该同时掌握这两种运算。

##### 4.6.1 重复执行操作
可以启动和控制重复任务的两种运算是`while`和`for`。`while`运算测试一个条件的真值，因此表示为`while ... :`。`for`运算使用一个列表中的所有值，因此表示为`for ... in ... :`。

`while ... `运算首先检查它要测试的条件（位于`while`与`:`之前的`...`），如果条件为`True`，它将首次对其缩进的语句求值。当它到达缩进的代码块（该代码块也可以包含其他的缩进代码块）的末尾时，将再一次对测试条件求值，看其是否仍旧为`True`。如果是，再一次重复动作；然而，如果为`False`，Python将离开缩进的部分，并继续计算程序中`while ... :`之后的部分。如果在测试条件中用到了名称，在第一次循环和下一次循环之间（再下一次，等等），这个名称引用的值可能会发生变化，直到某些可以让程序停止的因素出现。

@(试一试)[使用while循环]

``` python
 >>> i = 10
 >>> while i > 0:
 print("Lift off in:")
 print(i)
 i = i - 1

 Lift off in:
 10
 Lift off in:
 9
 Lift off in:
 8
 Lift off in:
 7
 Lift off in:
 6
 Lift off in:
 5
 Lift off in:
 4
 Lift off in:
 3
 Lift off in:
 2
 Lift off in:
 1
```
** 示例说明 **
之前的代码创建了一个名为`i`的变量，并且给它赋值`10`（注意，该变量可以使用任何合法的名称）。接下来，创建了`while`循环，表明“当`i`的值大于`0`时，执行如下操作”。之后让Python打印语句`Lift off in:`，并输出`i`的当前值。最后，每次循环都将`i`减`1`，导致该序列一次又一次地执行，直到`i`的值等于`0`。

如之前所求，用`for ... in ... :`形式的循环可以实现相同的结果，它和`while ... :`非常相似，但省略了一些步骤。在第一部分`for ...`中，同样赋予一个变量名称（再一次使用`i`，这种做法很常见，因为`i`是`index`的缩写）。在第二部分`in ... :`中，提供了一个序列，例如一个列表、元组或者这里所用的`range`，可以取出`range`中的每个元素并将它的值赋给第一部分给定的变量名称：
``` python
 >>> for i in range(10, 0, -1):
 print("T-minus: ")
 print(i)
 ...
 T-minus:
 10
 T-minus:
 9
 T-minus:
 8
 T-minus:
 7
 T-minus:
 6
 T-minus:
 5
 T-minus:
 4
 T-minus:
 3
 T-minus:
 2
 T-minus:
 1
```
可以看到，这个循环与`while`循环的工作方式类似，得到了几乎相同的结果（如果没有改变打印的文本的话，它将返回与`while`完全一致的结果）。这个版本的`for`循环稍微有点复杂。如下代码所示为一个简单的版本：
``` python
 >>> for i in range(10):
 print(i)
 ...
 1
 2
 3
 4
 5
 6
 7
 8
 9
```
这里简单地告诉`for`循环不停地迭代以重复整个过程，直到`i`等于`10`。因为使用了`range`，它自动给变量加`1`，导致程序运行一次之后又循环了`9`次。

##### 4.6.2 终止循环

术语“无穷循环”指的是一段永远重复的代码。一个简单的例子是设置`while ... :`语句，让它测试一个永远为`True`的条件。例如，仅使用`True`就可以实现这种效果。观察如下代码即可，不要直接输入它们：
``` python
 >>> while True:
 ...    print("You're going to get bored with this quickly")
 ...
 You're going to get bored with this quickly
 You're going to get bored with this quickly
 You're going to get bored with this quickly
 You're going to get bored with this quickly
 You're going to get bored with this quickly
```
上面的代码会一直继续下去，走到中断它。初看起来让某个操作一直重复不太方便，但有时可能希望如此，例如，在程序中使用一段循环代码等待用户输入，当用户输入完毕后，返回等待。

然而，有时希望知道某些特定的条件是否满足，例如，一天的某个恰当的时间是否到来，水是否用完，是否没有足够的鸡蛋做煎蛋卷等等，这时循环可以被打断，即使在`while ... :`顶部没有显式的测试，或者`for ... in ... :`中正在使用的列表没终点。

可以使用`break`语句退出无穷循环。尝试下面的代码，并确保缩进与这里显示的缩进匹配：
``` python
 >>> age = 0
 >>> while True:
 how_old=input("Enter your age: ")
 if how_old=="No":
     print("Don't be ashamed of your age!")
     break
 num=int(how_old)
 age=age+num
 print("Your age is :")
 print(age)
 print("That is old!")
 ...
 Enter your age: 1
 Your age is :
 1
 That is old!
 Enter your age: 2
 Your age is :
 3
 That is old!
 Enter your age: -3
 Your age is :
 0
 That is old!
 Enter your age: 50
 Your age is :
 50
 That is old!
 Enter your age: No
 Don't be ashamed of your age!
 >>>
```
在上面的程序中，`while`总是等于`True`，因此，如果不加处理的话，`while True`语句将一直循环下去。为了解决这个问题，给用户提示了一些信息，这里提示的是年龄。只要他们输入一个数，程序就会将输入的数加到他们的年龄中，显示一个总的年龄，使得看起业他们都变老了（除非他们很机智，输入一个负数，这种情况下他们才会变年轻！）。如果他们仅仅输入数值，程序将一直运行下去。然而，如果他们输入一个字符串`No`，程序将打印“Don't be ashamed of your age!”，然后退出循环。

注意`print`语句和`break`语句的位置。如果将`print`放在`break`之后而不是之前，那么程序每次循环时它都执行，而不是仅在退出循环的时候执行。因此要注意语句放置的位置！

如果使用`break`，它仅从最近的一个循环中退出。如果有一个`while ... :`循环，它包含一个缩进的`for ... in ... :`循环，`for ... in ... :`中的`break`将不会退出`while ... :`循环。

`while ... :`和`for ... in ... :`循环在末端都可以有一个`else:`语句，但它仅在循环不是由`break`语句退出时才会被运行。这种情形下，`else:`叫做`done`或者`on_completion`之类的名称可能更合适一些，但是`else:`是一个较方便的名称，因为前面已经见到过它，并且它也不难记住。

@(试一试)[循环时使用else]

``` python
 >>> for food in ("pate", "cheese", "crackers", "yogurt"):
 ...    if food == "yogurt":
 ...        break
 ... else:
 ...     print("There is no yogurt!")
 ...
 >>> for food in ("pate", "cheese", "crackers"):
 ...    if food == "yogurt":
 ...        break
 ... else:
 ...     print("There is no yogurt!")
 ...
 There is no yogurt!
```

** 示例说明 **
每个示例中，都有一个测试判断是否还有酸奶。如果有，`while ... :`会用一个`break`终止。然而，在第二个循环中，列表中没有酸奶，因此当循环到达列表尾部时将终止，`else:`条件会被调用。

循环还有另外一个常用的特征：`continue`语句。使用`continue`可以告诉Python并不希望循环终止，而是希望跳过当前循环的剩余部分，如果当前是在`for ... in ... :`循环中，条件和列表要被重新求值以进行下一轮循环。

@(试一试)[用continue继续循环]

``` python
 >>> for food in ("pate", "cheese", "rotten apples", "crackers", "whip cream", "tomato soup"):
 ...    if food[0:6] == "rotten":
 ...        continue
 ...    print("Hey you can %s" % food)
 ...
 Hey, you can eat pate
 Hey, you can eat cheese
 Hey, you can eat crackers
 Hey, you can eat whip cream
 Hey, you can eat tomato soup
```

** 示例说明 **
因为使用了一个`if ... :`测试来判断`food`列表中每一项的第一部分是否包含字符串“rotten”，所以“rotten apples”元素会被`continue`跳过，而共余的内容将被打印出来，表示可以安全食用。

#### 4.7 处理错误

第2章和第3章中已经介绍了Python如何报告错误。错误通常包含大量与发生的错误和失败的原因有关的信息：
``` python
 >>> fridge_contents = {"egg":8, "mushroom":20, "pepper":3, "cheese":2, "tomato":4, "milk":12}
 >>> if fridge_contents["orange juice"] > 3:
 ...    print("Sure, let's have some juice!")
 ...
 Traceback (most recent call last):
   File "<pyshell#3>", line 1, in <module>
     if fridge_contents["orange juice"] > 3:
 KeyError: 'orange juice'
```
噢！目前冰箱中没有橘子法，但如果不用终止程序就能知道这一信息会好一些。

前面已经介绍了一种找出字典中出现的所有键的方法，可以使用字典的`keys`方法，然后在返回的键列表中搜索，以判断某个希望的键是否出现。然而，没有理由不采用捷径。上述代码中的最后一行显示的错误是：
``` python
 KeyError: 'orange juice'
```

这说明Python遇到错误与字典`fridge_contents`中的键相关。可以利用Python指出的错误让程序防范这一类错误。可以用特殊词`try:`告诉Python要做好出错的准备。

** 使用try：语句 **

`tyr:`语句设立了这样一种情形，其中`try:`语句后面可以跟一个`except:`语句。每个`expect:`语句都处理错误，错误也被正式地称作异常，当Python对`try:`语句中的代码求值时会抛出异常，而不是使用程序失败。首先使用`except:`处理一种类型的错误，例如在试图检查冰箱时得到 的`KeyError`错误。

有多种类型的异常，每个异常的名称都反映了发生的问题，并且也有可能同异常所发生的条件。因为字典有键与值，`KeyError`表示正在向字典请求的的键不存在。类似地，一个`TypeError`表明Python期待某种类型的数据（例如，一个字符串或者一个整型值），但是提供给它的却是另外一种不能满足要求的类型。

另外，当异常发生时，可以访问原本在交互运行程序的时候程序停止时会看到的消息。

学到更多知识后，在需要的条件下，您将能够定义自己的异常类型。

只有一行代码用于处理错误，这看起来很受限制，但第5章将介绍如何编写自己的函数，这样可以更加灵活地处理错误。
``` python
 >>> fridge_contents = {"egg":8, "mushroom":20, "pepper":3, "cheese":2, "tomato":4, "milk":13}
 >>> try:
 ...    if fridge_contents["orange juice"] > 3:
 ...        print("Sure, let's have some juice!")
 ... except KeyError:
 ...    print("Awww, there is no juice. Let's go shopping!")
 ...
 Aww, there's no juice. Lets go shopping
```
您也许发现需要打印关于错误本身更多的信息，这些信息是可以访问的。

@(试一试)[创建异常以及对异常的说明]

``` python
 >>> fridge_contents = {"egg":8, "mushroom":20, "pepper":3, "cheese":2, "tomato":4, "milk":13}
 >>> try:
 ...    if fridge_contents["orange juice"] > 3:
 ...        print("Sure, let's have some juice")
 ... except (KeyError) as error:
 ...     print("Woah! there is no %s" % error)
 ...
 Woah! There is no 'orange juice'
```

** 示例说明 **

因为在字典`fridge_contents`中没有键“orange juice”，Python抛出了一个`KeyError`异常，说明没有这样的键。除此之外，还指定了名称`error`，Python将用它引用一个字符串，该字符串包含了Python可以提供的错误信息。我们通过`as`关键字将`KeyError`的值赋给`error`。在这种情形下，字符串与已请求但未在字典`fridge_contents`中出现的键有关（这里是“orange juice”）。

有时也许会用相同的方式处理多种错误，在这种情况下，可以用一个元组包含有关的所有异常类型：

``` python
 >>> fridge_contents = {"egg":8, "mushroom":20, "pepper":3, "cheese":2, "tomato":4, "milk":13}
 >>> try:
 ...    if fridge_contents["orange juice"] > 3:
 ...        print("Sure, let's have some juice")
 ... except (KeyError, TypeError) as error:
 ...    print("Woah! There is no %s" % error)
 ...
 Woah! There is no 'orange juice'
```
如果需要处理一个异常，但是希望以什么都不做的方式处理它（原因可能是故障不严重），Python允许通过特殊词`pass`忽略这种情形：
``` python
 >>> fridge_contents = {"egg":8, "mushroom":20, "pepper":3, "cheese":2, "tomato":4, "milk":13}
 >>> try:
 ...    if fridge_contents["orange juice"] > 3:
 ...        print("Sure, let's have some juice")
 ... except (KeyError) as error:
 ...     print("Woah! There is no %s" % error)
 ... except (TypeError):
 ...     pass
 ...
 Woah! There is no 'orange juice'
```
还有一个`else:`语句可以放在`try:`代码块的末端。在没有捕获到任意异常时，它将被执行。如前所述，`else`这个名称的描述性可能不如“in case it all works”或“all_clear”这样的名称，但是到现在已经可以看到，`else:`可以处理各种情况的一种灵活的机制，表示“如果某事发生，则如何处理”。在需要时，随时可以使用它。

#### 4.8 本章小结

本章介绍了Python提供的做出决策的方法。任意得出`True`或者`False`结果的运算，都可以用`if ... :`语句中来判断一个程序是否要对一段缩进的代码求值。

缩进在Python中扮演着重要的角色。即使在交互的Python Shell中，缩进中的空格数也很重要。

本章讨论了在循环中使用序列和字典中元素的知识。通过使用循环，可以对一个列表的每个元素执行运算并且根据每个列表元素做出决策。

Python提供了两种 类型的循环，分别是`while ... :`循环和`for ... in ... :`循环。它们持续执行相似的工作，走到某个条件导致它们结束。两者的区别在于允许它们对缩进的代码块求值的条件不同。`while ... :`循环在它的测试中只测试是`True`还是`False`，而`for ... in ... :`循环将接受在`in ... :`部分提供的序列，序列中的第一个到最后一个元素将被赋给`for ...`部分中提供的值。

这两种类型的重复循环在它们的测试条件满足之前，可以通过`break`语句退出。Break语句导致正在执行的循环停止，不再对循环的代码块中其余的代码求值。然而，如果执行一个`break`语句，循环中可选的`else:`条件将不被执行。除了`break`之外，还有一个`continue`语句，它将跳过当前循环的剩余部分，然后返回到循环的顶部并对下一个测试条件求值。

本章还介绍了其他类型的做出决策的方法，即处理Python用来报错的异常。如果没有处理异常，错误会导致程序在出错的地方停下来。然而，如果将可能会导致错误的代码缩进并放到`try:`的下面，就可以阻止程序退出，甚至可以处理错误并且使程序继续运行。在`except ... :`语句中指定预计会碰到的错误，其中，提供的第一个值定义了错误的类型（如果提供的是错误类型的元组，就是多个错误类型）；也可以选择在该值的后面提供词`as`，以及用来引用包含错误信息的数据的名称。

** 本章要点： **

* 可以用两个等号（==）测试相等性。如果答案是`True`，则返回`True`。如果是`False`，则返回`False`。双等号也可以用来判断两个变量是否保存相同的数据。
* 如果希望知道两个值是否不等，可以使用不等运算符（`!=`）。在这种情形下，`True`表示被比较的两个值不相等，`False`表示被比较的值是相等的。
* 为了比较两个值的大小，可以分别使用大于（`>`）和小于(`<`)运算符。如果需要知道一个值是否大于等于或者小于等于另外一个值，可以使用大于等于运算符（`>=`）或者小于等于运算符（`<=`）。
* 如果希望程序根据一个值为`True`还是为`False`做出决策，可以使用`if`语句，它简单地表明，如果这个值为`True`，就执行下面的操作。为了让程序在一个值为`True`时执行一种操作，而在该值为`False`时执行另一种操作，可以使用`if ... elif ...`语句。
* 有时需要将一个特定的动作循环很多次。使用`while`循环时，只要条件为`True`，就会一直重复或者抚今追昔某个动作，或者照字面意思讲，当该条件为`True`时执行如下操作。
* 如果需要将某个动作循环指定的次数，可以使用`for`循环，它用一个循环计数器指定要将一个给定的动作重复多次。
* `try:`语句后面可以跟一个`except:`语句。每个`except:`语句都处理错误，错误的正式名称是“异常”。Python在计算`try:`语句中的代码时会抛出异常，而不是简单地失败。

#### 4.9 习题
在Python Shell的代码编辑器中执行下列任务：
1. 用一系列的`if ... :`语句，通过创建5个单独的测试计算从`0～4`的数值是`True`还是`False`。
2. 用一个`if ... :`语句创建一个测试，指出某个值是否包含在`0～9`之间（可以是`0`或者`9`），如果是，则打印一条信息。
3. 使用`if ... :`、`elif ... :`、`else:`，创建一个测试，检查一个名称引用的值是否在一个序列的前两个元素中。用`if ... :`测试序列的第一个元素，用`elif ... :`测试序列中第二个元素的值，然后使用`else:`语句打印一条消息，指出正在查询的元素是否存在于序列中。
4. 创建一个字典，它包含一个虚构的电冰箱中的食物，将字典命名为`fridge`。食物的名称作为键，每个食物项的值是一个字符串，描述了该食物。创建一个名称，引用包含食物名称的字符串。将该名称叫做`food_sought`。对于字典`fridge`中的每个键和值，用`for ... in ... :`循环测试冰箱中包含的每个键，将习题3中的测试修改为简单的`if ... :`测试（这里不需要`elif ... :`或者`else:`）。如果找到一个匹配，打印出包含这个键与值的消息，并使用`break`退出循环。在`for`循环的末端用一个`else ... :`语句打印当元素没有找到时的消息。
5. 修改习题3，使用`while ... :`循环创建一个单独的叫做`fridge_list`的列表，这个列表将包含`fridge.keys`给出的值。同样地，使用叫做`current_key`的变量，引用循环中由`fridge_list.pop`得到的当前元素的值。记住将`fridge_list.pop`放到`while ... :`循环的最后一行，这样循环将正常结束。在`while`循环的末尾使用与习题3的末尾相同的`else:`语句。
6. 用一个不存在的键查询习题3中创建的字典`fridge`，引起一个错误。在这样的情况下，`KeyError`可被用来判断您希望的值是否存在于列表中。修改习题3的解决方法，使用`try:`代码块而不是`for ... in ... :`。

### 第5章 函数
目前，每次希望完成一项任务时，需要输入所有的程序代码来完成工作。如果需要再次做相同的工作，可以将整个程序重新输入一遍或者将代码放在一个循环中。循环在重复操作时非常有用，但是只是略做了一些小修改，就在程序的不同部分重复写相同的循环，这并不是明智的做法。

Python的函数可以将代码段聚集到方便的分组中，在需要的时候可以再次调用它们。

本意将介绍：
* 如何创建和使用函数。
* 给出一些指导原则，帮助思考如何创建和组织程序以使用函数。
* 如何编写函数，使随后可以询问它们的工作方式和实现的功能。

#### 5.1 将程序放在单独的文件中
当本书中的示例变长时，输入整个代码块开始变成负担。一个错误将导致要重新输入整块代码。在遇到多于40行的代码要输入时，您不会再想输入相同的代码。

程序员将所写的程序作为源代码存入文件，这些文件可以被方便地打开、编辑和运行。

为了更加方便，从现在开始，您应当在Python的代码编辑器中输入正在使用的程序，并将本书的示例都放到一个文件中，以便以后引用和运行这些示例。一个可靠的建议是将该目录命名为“Learning Python”，之后能够以程序出现的章节命名它们。

可以执行两种操作使程序易于运行。所有Python文件的第一行应该如此：
``` python
 #!/usr/bin/env python 3.1
```
如果遵循本书附录中的说明，这行代码使得UNIX和Linux系统可以运行这些脚本。第二件要做的重要的事情是给所有的Python文件起一个以`.py`为扩展名的名称。在Windows系统上，这将给操作系统提供信息，以便使用操作系统将这些文件当作Python文件启动，而不是仅把它们当作普通的文本文件。例如，如果把前面章节的示例放到自己的文件中，会有一个包含如下文件的文件夹：
```
chapter_1.py
chapter_2.py
chapter_3.py
chapter_4.py
chapter_5.py
```
将第一个程序保存到文件后，代码编辑器开始以不同的颜色和样式显示程序中的某些部分以强调它们。内置的函数和保留字以一种方式处理，字符串以另外的方式处理，而一些关键字又会采用另外一种处理方式。然而，文件中的大部分文本都还是普通的黑色和白色，如图5－1所示。
![图5-1](https://i.loli.net/2019/05/04/5ccd6a69f37a3.png)
使用这些文件后，只输入一次示例即可。当输入一个例子并且保存它之后，可以用`python -i <filename>`运行它。`-i`告诉Python读取程序文件，然后允许您继续与Python交互，而不是立刻退出（这是Python通常的做法）。在代码编辑器中，可以通过从`File`菜单选择`Run with Interpreter`自动完成这种设置。

@(试一试)[利用`-i`在Python中运行程序]

为了说明如何利用`python -i`或者`Run with Interpreter`，向名为`ch5-demo.py`的文件中输入如下代码：
``` python
 #!/usr/bin/env python 3.1
     a = 10
 b = 20

 print("A added to B is %d" % (a + b))
```
当用`-i`选项调用Python时，将处于一个如下所示的Python交互会话中：
``` python
 A added to B is 30
 >>>
```

** 示例说明 **

文件`ch5-demo.py`中的代码被计算后，可以继续操作`a`与`b`的值，也可以对它们进行扩展，就像手动输入一样。当示例变长时，这将节省时间。后面的一些代码可能首先在Shell中展示，但是可以保存以便以后运行。另外一些出现在文件中的代码，可以保存和运行。之所以使用文件展示程序，原因可能是书中讨论的内容没有很好地表现一种思想，所以最好使您做一些额外的工作 ，一次又一次地输入相同的代码，或者实际与程序交互。也可能是因为程序太长，在需要对其测试时，使用文件就不用一次次地重复输入。

#### 5.2 函数：在一个名称下聚焦代码
大多数现代程序语言都提供了将代码聚焦在一个名称下的功能，不论何时使用这个名称，它包含的代码将被调用和运算，从而不需要每次都重新输入它们。

为了创建一个包含代码的命名函数，可以使用`def`，它可以定义一个代码功能块。

@(试一试)[定义一个函数]

尝试将下面的代码保存到第5章的文件`ch5.py`中。
``` python
 def in_fridge():

     try:
         count = fridge[wanted_food]
     except KeyError:
         count = 0
     return count
```

** 示例说明 **

当调用`ch5.py`（在代码编辑器中按下`F5`）时，若其中只定义了`in_fridge`函数，则不会看到任何输出。然而，该函数将定义，并且可以从已创建的交互式Python会话中调用。

为了使用`in_fridge`函数，必须确保有一个包含各种食物名称的`fridge`字典。另外，必须有一个名为`wanted_food`的字符串。使用`in_fridge`时，可以通过该字符串询问是否有某种食物。因此，在交互式的会话中，可以用该函数做如下的事情：

``` python
 >>> fridge = {'apples':10, 'oranges':3, 'milk':2}
 >>>wanted_food = 'apples'
 >>> in_fridge()
 10
 >>> wanted_food = 'oranges'
 >>> in_fridge()
 3
 >>> wanted_food = 'milk'
 >>>in_fridge()
 2
```
这不仅有用，而且十分有意义，可以减少工作量。在一个名称下聚焦代码块意味着可以简化代码，从而以更快的速度完成更多的工作。输入量减少了，出错的机率也就降低了。

函数是任意现代程序语言的核心部分，它们也是利用Python解决问题的关键。

编写程序时，函数可以看做是一个问与答的过程。当它们被调用时，经常会问它们一个问题：“有多少个？”“什么时候？”“这个存在吗？”“这个可以改变吗？”等。作为响应，函数会返回包含答案的值，例如`True`、一个序列、一个字典，或者其他类型的数据。如果不是这些值，返回的答案将是一个特殊值`None`。

即使一个函数主要做一些简单的工作，通常会有一个隐含问题需要知道。当函数完成任务后，“它成功了吗？”或者“它是如何工作的？”之类的问题通常是您调用函数的方式。


##### 5.2.1 选择名称
把函数写好的第一个指导原则是函数的名称能够反映其用途。这些名称应当指出函数的功能，如Python中的函数`print`、`type`和`len`。

当确定一个名称时，应当考虑如何在程序中调用它。如果命名一个函数，日后您以及其他人调用它时，都能很自然地理解它，这将非常好。几周之内忘记函数的具体细节是很正常的，因此日后返回来用它时，函数的名称就成为回忆它的功能的主要手段。

##### 5.2.2 在函数中描述函数
在待定函数名称之后，应当再给函数添加一个描述。Python可以用简单并有意义的方式完成这件事情。

如果将一个字符串作为函数的第一部分内容，而没用名称引用它，Python将它存储在函数中，以便以后可以引用它。这个字符串通常叫做`docstring`，是`documentation string`（文档字符串）的缩写。

函数的文档字符串用于描述函数。很少有计算机软件做了良好的说明。然而，通常情况下，由于Python提供了简单的文档字符串特性，相对于用缺乏友好和有帮助的约定的其他语言编写的程序，Python程序中有更多可用的信息。

文档字符串中文本并不必像其他代码那样遵循缩进规则，因为它仅仅是一个字符串。输入完文档字符串后，即使它可能看起来破坏了缩进，函数的后续部分也仍然必须保持正确的缩进，记住这一点非常重要。
``` python
 def in_fridge ():
   """This is a function to see if the fridge has a food.
   fridge has to be a dictionary defined outside of the function.
   the food to be searched for is in the string wanted_food"""
   try:
     count = fridge[wanted_food]
   except KeyError:
     count = 0
   return count
```
文档字符串通过函数中的名称引用，仿佛函数是字典一样。这个名称是`__doc__`，它的用法是在函数名称之后加一个英文句点，再加上`__doc__`。注意，在`doc`前后各有两个下划线（_）。

@(试一试)[显示`__doc__`]

现在应当退出上个示例进入的交互式会话，然后重新调用`ch5.py`，因为现在`in_fridge`中加入了文档字符串。此后，可以执行如下操作：
``` python
 >>> print("%s" % in_fridge.__doc__)
 This is a function to see if the fridge has a food.
 fridge has to be a dictionary defined outside of the function.
 the food to be searched for is in the string wanted_food
```

** 示例说明 **
如其他类型一样，函数也有一些属性，可以通过在函数名称后加句点，再加属性名称来使用。`__doc__`是一个字符串，像其他字符串一样，在一个交互式会话中很容易把它打印出来以便引用。

函数还有其他信息（它保存的这组信息可以使用内置函数`dir`查看）。

`dir`显示您感举的对象（例如函数）的所有属性，包括Python内部使用的属性：
``` python
 >>> dir()
 ['__annotations__', '__builtins__', '__doc__', '__loader__', '__name__', '__package__', '__spec__']
```
可以使用获得`in_fridge.__doc__`引用的数据同样的表示方法访问这些属性，但是通常并不南要直接使用其中的大部分属性，尽管使用`type`内置函数研究Python如何描述这些元素是很好的练习。

##### 5.2.3 不同的位置相同的名称
函数的一个特殊属性在于它是您见到的对引用数据的名称进行划分的第一个示例。这意味着如果函数之外有一个名称，该名称引用一个特定值，这个值可以是字符串、数值、字典、序列或者函数。这些数据享有共同的空间。

例如，如果创建了一个字符串名称，然后在下一行创建了一个字典，并用相同的名称引用这个字典，那么这个名称将不再引用字符串，而是仅引用字典：
``` python
 >>> fridge = "Chilly Ice Makers"
 >>> print(fridge)
 Chilly Ice Makers
 >>> fridge = {'apples':10, 'oranges':3, 'milk':2}
 >>> print("%s" % fridge)
 {'apples':10, 'oranges':3, 'milk':2}
```
这很合理，但是在函数中使用名称时会有所不同。函数创建了一个新的空间，其中名称可以被重新使用和创建，而不会影响到程序的其他作用域中的相同名称。所以在编写函数时，完全不用担心其他地方或者其他函数中已经用过同样的名称。

因此，编写函数时，函数有自己的一些名称，其他的函数也有自己的名称，它们是分开的。即使两个函数中某个名称完全相同，由于它们在不同的函数中，所以是完全独立实体，引用的是不同的值。

如果即将在一个已知的情形中使用一个函数，并可以确保它要用的名称已被定义，而且引用了正确的数据，函数就可以通过已经定义的名称访问这个全局数据。Python的这种能力来源于它将一个名称的可见性分隔到不同的概念区域内。每一个这样的区域叫做一个作用域。

最上面一层作用域中的任何名称在一个低层次作用域中可再次被使用，而不影响上层名称引用的数据：
``` python
 >>> special_sauce = ['ketchup', 'mayonnaise', 'french dressing']
 >>> def make_new_sauce():
 ... """This function makes a new special sauce all its own"""
 ...    special_sauce = ["mustard", "yogurt"]
 ...    return special_sauce
 ...
```
此处，最上层作用域中有一个`special_sauce`，函数`make_new_sauce`中也有一个`special_sauce`。当运行时，可以看到全局作用域中的名称没有改变：
``` python
 >>> print("%s" % special_sauce)
 ['ketchup', 'mayonnaise', 'french dressing']
 >>> new_sauce = make_new_sauce()
 >>> print(sepcial_sauce)
 ['ketchup', 'mayonnaise', 'french dressing']
 >>> print(new_sauce)
 ['mustard', 'yogurt']
```
记住，不同的函数完全可以定义相同名称的变量，该名称在两个函数中都有意义，但却引用不同的值，彼此不会产生冲突。

##### 5.2.4 添加注释
Python有一个额外的特性可以帮助记录自己的程序。输入到程序中的全部内容，即使目前为止它还未改变程序的行为（如文档字符串），Python也会处理它。即使不被使用的字符串，Python也会创建它，以便将来使用。

除了不需要的字符串，每门程序语言都有在代码中添加注释的功能，注释不会对程序有影响。它们是供代码使用者阅读的，而不是为Python准备的。

任何地方，一行里有`#`字符且它不出现在字符串中，Python将忽略它后面的所有内容，而开始对下面一行语句求值，并从此处开始读取剩余部分的程序。

@(试一试)[添加注释]

如果交互式地测试注释，可以看到Python读它们时与读字符串不同：
``` python
 >>> "This is a string"
 'This si a string'
 >>> # This is a comment
 >>>
 >>> "This is a string" # with a comment at the end
 'This is a string'
    >>> print("# Here is a pound sign within a string, being treated as a string!")
 # Here is a pound sign within a string, being treated as string!
```

** 示例说明 **
当注释单独出现时，Python忽略它并且返回，询问一下个请求，试着提示输入一个它可以计算的语句。当注释与可以计算的代码出现在同一行时，即使仅仅是个字符串，Python也知道您已经给了它指令。

注释通常出现在程序文件中。您不太可能不厌其烦地在交互式会话中输入注释，但这是在程序文件中使用它们的方法。

另外，如果想测试一个程序的变化，在会引起错误的一行（或多行）代码之前放置注释符号使其失效非常有用。然而要小心。注释会影响Python严格关注的缩进。必须非常仔细地将函数中的注释放在适当的缩进级别，因为如果不这样做，Python将注释看做结束了该函数或`if ... :`代码块，或者其他引起缩进的单位，这肯定不是希望出现的情况！

将注释保持在同样的缩进级别，可以使注释更容易阅读，因为注释用于哪部分代码是显而易见的。

##### 5.2.5 要求函数使用提供的值
在`in_fridge`示例中，函数使用的是全局作用域的值。函数`in_fridge`仅在已经定义的值上做运算，这些值的名称对于整个程序都可见。这种行为只在较小的程序中有效。

当接触到包含成百上千或更多行代码（程序的长度经常以它包含的代码行数来衡量）的大程序时，就不能再依靠特定名称的全局可用性，因为这些名称可能在您没参与时按照其他人的决定被更改掉了。相反，可以指定函数在每次被调用时处理提供给它的值。

这些值是规范或者参数，程序依靠它们完成工作。当函数被调用时，这些参数可以是引用了数据的名称，也可以是静态数据，例如像5一样的一个数或者一个字符串。所有情况下，实际数据将进入被调用函数的作用域，而不是全局作用域。

本书中的许多示例有不同的改进版本，可以把它们添加到同一个文件中，除非本书明确指示改变正在使用的函数。

不必总是将一个函数的前期版本删掉，因为下一个版本只是对它做了简单的修改。通过比较新旧两个函数，您有机会看到对该函数做的修改。

只要最新的版本在您加载时处于文件的最底部，这个最新版本将被使用。

当自己写程序时，这是一个有用的练习。没有什么会像乱动正在处理的一段代码，之后不刻如何将它改回以前可以工作的状态那样痛苦。

注意，在下面的代码中，`def`（函数的定义）已经被更改，现在它指定该函数需要两个参数，参数名称在函数名称后的元组中指定。这些参数将进入并且保持在`in_fridge`函数的作用域内，它们分别是`some_fridge`和`desired_item`。
``` python
 def in_fridge(some_fridge,desired_item):
 """This is a function to see if the fridge has a food.
 fridge has to be a dictionary defined outside of the function.
 the food to be searched for is in the string wanted_food"""
     try:
         count = some_fridge[desired_item]
     except KeyError:
         count = 0
     return count
```
当调用一个带参数的函数时，在`in_fridge`函数调用的圆括号中放置指定参数的值或者名称，参数值之间以逗号分隔。前面已经在使用函数`len`时看到了这种做法。

@(试一试)[调用带参数的函数]

再一次，通过运行`python -i ch5.py`或者使用`Run with Interpreter`重新调用一个交互式的Python会话，得到的交互式会话中定义了新的`in_fridge`函数。
``` python
 >>> fridge = {'apples':10, 'oranges':3, 'milk':2}
 >>> wanted_food = "oranges"
 >>> in_fridge(fridge, wanted_food)
 3
```

** 示例说明 **

字典`fridge`和字符串`wanted_food`作为参数传递给新的`in_fridge`函数。当进入该函数的作用域后，`fridge`引用的字典现在被名称`some_fridge`引用。同时，`wanted_food`引用的字符串`oranges`，在一进入`in_fridge`函数作用域后与名称`desired_item`关联。做完该调整后，函数有了正常工作需要的信息。

为了进一步说明工作原理，可以使用没有命名的值，即不通过名称引用的数据：
``` python
 >>> in_fridge({'cookies':10, 'broccoli':3, 'milk':2}, "cookies")
 10
```
这些值被带入`in_fridge`函数的作用域，并根据函数定义赋值给函数中使用的名称。在函数内部将不再有一个对全局作用域名称的引用。

##### 5.2.6 检查参数
打算使用的参数类型可能与函数被调用时提供的类型不同。例如，可能编写了一个函数，期待的参数是一个字典，但偶然传入一个列表，此时函数将一直运行，直到需要访问字典特有的运算。程序因为产生异常而退出。这与其他语言不同，它们尝试确保每个参数的类型是已知的，而且可以检查其正确性。

Python并不检查哪种类型的数据与函数的参数名称关联。大多数情况下，这不是问题，因为在给定数据上的操作都是某个类型的所特定的，如果名称引用的数据类型不正确，程序将不能正常地工作。

例如，如果向`in_fridge`传入数值而不是字典，python在尝试将数值当作字典访问时，将引发一个`except:`捕捉不到的错误。产生的`TypeError`错误表明Python试图操作的类型做不了Python期望它做的事情：
``` python
 >>> in_fridge(4, "cookies")
 Traceback (most recent call last):
   File "<stdin>", line 1, in ?
   File "<stdin>", line 7, in in_fridge
 TypeError: unsubscriptable object
```
这个示例传递给函数一个数值，而函数期待对一个字典进行操作。不论怎样，数值没有将名称作为键查找值的属性。数值没有键，也没有与键对应的值。在任何上下文中，Python中都不能找到`4("cookies")`，因此将引起异常。

Python用词`unsubscriptable`指出它不能像在字典中那样找到与一个键关联的值。下标`(subscripting)`是描述访问列表、元组或者字典中的元素时的术语，因此在其中任意一个上下文中都可能遇到该错误。

不需要明确定义期待的类型，而允许灵活确定希望如何处理类型的行为可给您带来好处。可以编写一个函数，处理任意期望的类型。还可以编写接受多种类型参数的函数，之后再依据传递给函数的类型确定函数应该如何运行。采取哪种方法取决于需要在程序中做什么。

为了确定某些数据的类型，记住可以使用内置函数`type`，第2章对它做了介绍。使用该函数的输出，可以在函数的开头部分验证变量类型。
``` python
 def make_omelet(omelet_type):
     """This will make an omelet. You can either pass in a dictionary
     that contains all of the ingredients for your omelet, or provide
     a string to select a type of omelet this function already knows
     about"""
     if type(omelet_type) == type({}):
         print("omelet_type is a dictionary with ingredients")
         return make_food(omelet_type, "omelet")
     elif type(omelet_type) == type(""):
         omelet_ingredients = get_omelet_ingredients(omelet_type)
         return make_food(omelet_ingredients, omelet_type)
     else:
         print("I don't think I can make this kind of omelet: %s" % omelet_type)
```
`make_olemet`的定义并不能工作，因为它还信赖于其他几个未编写的函数。编程过程中有时会这么做，先创建一些函数的名称，随后再填充它们的内容。在本章后面将看到这些函数，那时上述代码就变得完全可用了。

@(试一试)[使用`type`函数确定更多的类型]

在用`python -i`或者`Run with Interpreter`加载`ch5.py`文件之后，输入如下代码：
``` python
 >>> fridge = {'apple':10, 'oranges':3, 'milk':2}
 >>> type(fridge)
 <class 'dict'>
 >>> type({})
 <class 'dict'>
 >>> type("Omelet")
 <class 'str'>
 >>> type("")
 <class 'str'>
```
** 示例说明 **
要注意的第一件事情是`type`函数返回对象的类。在测试中可以使用这个类的对象，即它可与其他类对象进行比较。注意，Python中，类和类型是同一事物的不同名称，即它们定义了变量和值的数据类型。

@(试一试)[使用字符串比较类型]

在这里还可以使用另外一个特性。前面已经看到，对于`print`函数，Python中的话多对象可以表示成字符串。这是因为，许多对象都有内置的方法，在需要时可将它们转换成字符串。

例如，另外一种编写前面比较的方法如下：
``` python
 >>> fridge = {'apples':10, 'oranges':3, 'milk':2}
 >>> str(type(fridge))
 "<class 'dict'>"
 >>> if str(type(fridge)) == "<class 'dict'>":
 ...     print("They match!")
 ...
 They match!
```

** 示例说明 **

由于事先可以知道一个类型的字符串表示是什么样子，可以将那个字符串与一个通过`str`函数转换成字符串的对象进行比较。

##### 5.2.7 为参数设置默认值
还有一个小窍门可确保函数易于使用。函数的每个参数都要有值。如果没有给所有必需参数赋值，函数将产生一个错误，或者更糟的是，它返回了错误的数据。

为了避免这种情形，Python允许创建带默认值的函数，这些默认值赋给那些在函数调用时没有显式提供的参数。您已经见过这种行为。例如列表的`pop`方法，它既可以被告知处理列表中的一个特定元素，也可以在没有给定任何值的情况下，自动处理最后一个元素。

可以在定义函数时，在参数列表中使用赋值运算符（`=`）指定默认值。例如，如果希望`make_omelet`的变体可以默认地做出一个奶酪煎蛋卷，仅需改变它的定义，其余什么都不用作。

@(试一试)[设置默认参数]

剪切并粘贴整个`make_omelet`函数。之后，在函数的新副本中对它的定义做如下修改，它将默认地做奶酪煎蛋卷：
``` python
 def make_omelet2(omelet_type="cheese"):
```

** 示例说明 **

该定义并不改变函数其余代码的行为。它仅在函数`make_omelet2`被调用、但没有定义`omelet_type`时设置它的值。

仍然可以用一个字典或者一个不同类型的煎蛋卷指定这个参数。然而，如果`make_omelet`用这样的方式定义，可以在不指定何特定煎蛋卷的类型的情况下调用它，该函数将做出一个奶酪煎蛋卷。

对`make_omelet`做相同的操作是将`make_omelet`编写为一个以友好和直观的方式运行的函数的第一步。记住，仍然需要编写其他函数！目标是得到如下的输出：
``` python
 >>> make_omelet()
 Adding 2 of eggs to make a cheese
 Adding 2 of cheddar to make a cheese
 Adding 1 of milk to make a cheese
 Made cheese
 'cheese'
 >>> make_omelet("western")
 Adding 1 of pepper to make a western
 Adding 1 of ham to make a estern
 Adding 1 of onion to make a western
 Adding 2 of eggs to make a western
 Adding 2 of jack_cheese to make a western
 Adding 1 of milk to make a western
 Made western
 'western'
```
如果编写了一个有多个参数的函数，并且希望其中既有必需参数也有可选参数，必须将可选参数放在参数列表的末尾。因为一旦指定某个参数为可选参数，它可能出现也可能不出现。从第一个可选参数起，Python不能保证那些在可选参数右边的参数都出现。换言之，第一个默认参数后面的所有参数都变成可选参数。这是自动发生的，因此要小心使用这个特性。

##### 5.2.8 在函数中调用其他函数
在顶层或者全局作用域声明的函数可以被其他函数以及其他函数包含的函数使用。全局作用域的名称可在任何地方使用，因为最有用的函数需要在其他函数中可用。

为了使用`make_omelet`函数能像之前看到的那样工作，它信赖的其他函数应当可用，以便被`make_omelet`使用。

它的工作方式是：首先，一个函数扮演了一本食谱的角色。它被给予一个指定煎蛋卷类型的字符串，并返回一个包含所有成分及其分量的字典。该函数将被叫做`get_omelet_ingredients`，它需要一个参数，即煎蛋剪子的名称：
``` python
 def get_omelet_ingredients(omelet_name):
 """This contains a dictionary of omelet names that can be produced,
 and their ingredients"""
     # All of our omelets need eggs and milk
     ingredients = {"eggs":2, "milk":1}
     if omelet_name == "cheese":
         ingredients["cheddar"] = 2
     elif omelet_name == "western":
         ingredients["jack_cheese"] = 2
         ingredients["ham"]         = 1
         ingredients["pepper"]      = 1
         ingredients["onion"]       = 1
     elif omelet_name == "greek":
         ingredients["feta_cheese"] = 2
         ingredients["spinach"]     = 2
     else:
         print("That's not on the menu, sorry!")
         return None
     return ingredients
```
做煎蛋卷所需的第二个函数叫做`make_food`，它需要两个参数。第一个参数是包含所需成分的列表，这些成分完全从`get_omelet_ingredients`函数得来。第二个参数是食物的名称，它应当是一种煎蛋卷的类型：
``` python
 def make_food(ingredients_needed, food_name):
     """make_food(ingredients_needed, food_name)
     Takes the ingredients from ingredients_needed and makes food_name"""
     for ingredient in ingredients_needed.keys():
         print("Adding %d of %s to make a %s" %
 (ingredients_needed[ingredient], ingredient, food_name))
     print("Made %s" % food_name)
     return food_name
```
此时，所有部分都已就绪，可以使用`make_omelet`函数。它需要调用函数`get_omelet)ingredients`和`make_food`来完成工作。每个函数都提供了制作一个煎蛋卷的部分过程。`get_omelet_ingredients`函数为特有的煎蛋卷类型提供了详细而精确的说明，而通过`make_food`函数提供的信息，可以知道在将合适数量的一些成分混合之后得到哪些结果（为了演示，这里采用了一种简单的方法）。

@(试一试)[调用已完成的函数]

现在已经有了能使`make_omelet`工作的所有函数，用`python -i`或者`Run with Interpreter`命令调用`ch5.py`文件，之后在Shell中尝试如下代码：
``` python
 >>> omelet_type = make_omelet("cheese")
 Adding 2 of eggs to make a cheese
 Adding 2 of cheddar to make a cheese
 Adding 1 of milk to make a cheese
 Made cheese
 >>> print omelet_type
 cheese
 >>> omelet_type = make_omelet({"eggs":2, "jack_cheese":2, "milk":1, "mushrooms":2})
 omelet_type is a dictionary with ingredients
 Adding 2 of jack_cheese to make a omelet
 Adding 2 of mushrooms to make a omelet
 Adding 2 of eggs to make a omelet
 Adding 1 of milk to make a omelet
 Made omelet
 >>> print omelet_type
 Omelet
```

** 示例说明 **

所有函数已经就绪，可以被逐个调用，所以只需指定希望制作的煎蛋卷的名称，然后就可以使用`make_omelet`了。

##### 5.2.9 函数嵌套函数
在工作中不可能对煎蛋卷制作进行模拟，但对现实世界的情形进行部分模拟是有可能的，本小节将介绍如何改进已有的解决方案。

也许一个特定函数的工作太多，不便在一个地方定义，您希望将它分解成小的不同的片段。为此，可以将函数放在另外的函数内部，并且从那个函数中调用该函数。这样复杂函数变得更有意义。例如，`get_omelet_ingredients`可以完全包含在`make_omelet`函数内部，并且不能用于程序的其余部分。

限制该函数的可见性是有意义的，因为该函数只能用于制作煎蛋卷。如果编写一个程序，其中也包含制作其他食物的指令，煎蛋卷的成分将不能用于制作其他类型的食物，即使像炒蛋或者梳芙厘这样与煎蛋卷类似的食物。每种新食物都需要自己的功能相同的函数。然而，`make_food`函数仍然有意义，可用于任意类型的食物。

在另外一个函数中定义一个函数就像在顶层定义它一样。唯一的不同之处是它与包含它的函数中的其他代码在相同的级别缩进。这种情况下，所有代码看起来很类似：
``` python
 def make_omelet(omelet_type):
     """This will make an omelet. You can either pass in a dictionary
     that contains all of the ingredients for your omelet, or provide
     a string to select a type of omelet this function already knows
     about"""
     def get_omelet_ingredients(omelet_name):
         """ This contains a dictionary of omelet names that can be produced,
 and their ingredients"""
         ingredients = {"eggs":2, "milk":1}
         if omelet_name == "cheese":
             ingredients["cheddar"] = 2
         elif omelet_name == "western":
             ingredients["jack_cheese"] = 2

     ingredients["ham"]      = 1
             ingredients["pepper"]  = 1
             ingredients["onion"]   = 1
         elif omelet_name == "greek":
             ingredients["feta_cheese"] = 2
         else:
             print("That's not on the menu, sorry!")
             return None
         return ingredients
     if type(omelet_type) == type({}):
         print("omelet_type is a dictionary with ingredients")
         return make_food(omelet_type, "omelet")
     elif type(omelet_type) == type(""):
         omelet_ingredients = get_omelet_ingredients(omelet_type)
         return make_food(omelet_ingredients, omelet_type)
     else:
         print("I don't think I can make this kind of omelet: %s" % omelet_type)
```
使用函数之前定义函数非常重要。如果试图在定义一个函数之前就调用它，那么在调用时Python不知道函数的存在，因此不能调用它！当然，这将导致一个错误并引起一个异常。因此，在文件的开始处定义函数，这样一直到最后都可以使用它们。


##### 5.2.10 用自己的词语标记错误
如果需要指出发生了一个特定的错误，那么可能希望使用已经见过的一个错误指出正在调用的函数哪里出错了。

与`try:`和`except:`关键字对应的是`raise ... :`命令。使用`raise ... :`命令的好时机是，在编写了一个接受多个参数的函数，而其中一个参数类型错误时，非常适合使用`raise ... :`命令。

可以检查传递进来的参数，并使用`raise ... :`指出提供了错误类型的参数。当使用`raise ... :`时还提供了一条`except ... :`语句可以捕获并显示的错误信息，即关于该错误的解释。

下面的代码修改了`make_omelet`函数的结尾部分，将一个打印出的错误（适合运行程序的人阅读）替换为一个`raise ... :`语句，这样即可以通过函数处理错误，也可以将该错误打印出来。
``` python
 if type(omelet_type) == type({}):
     print("omelet_type is a dictionary with ingredients")
     return make_food(omelet_type, "omelet")
 elif type(omelet_type) == type(""):
     omelet_ingredients = get_omelet_ingredients(omelet_type)
     return make_food(omelet_ingredients, omelet_type)
 else:
     raise TypeError("No such omelet type: %s" % omelet_type)
```
完成该修改后，`make_omelet`在遇到问题时，可以显示关于该类错误的精确信息，同时仍旧为使用者提供信息。

#### 5.3 函数的层次
现在已经了解了函数是什么以及它们是如何工作的，考虑它们的调用方式以及Python如何记录调用层次非常有用。

当程序调用一个函数时，或者一个函数调用一个函数时，Python在其内部创建了一个叫做栈的列表，有时也叫做调用栈。当调用一个函数时，Python将停止片刻，记住程序调用函数时所处的位置，之后将该信息贮藏到它的内部列表。之后进入函数并且执行它。例如下，如下代码阐明了Python如何记录它是如何进入以及离开函数的：
``` python
 [{'top_level': 'line 1'}, {'make_omelet': 'line 64'}, {'make food': 'line 120'}]
```
在最上层，Python从第一行开始记录。之后，当函数`make_omelet`在第64行被调用时，也对其进行了记录。再后来，`make_food`被`make_omelet`调用。当`make_food`函数结束时，Python确定它在第64行，于是返回到第64行并继续执行。这个示例中的行数是虚构的，但是您可以了解其中的意思。
这个列表叫做栈，形象地表示出了进入函数的方式。可以想象直到退出时，一个函数位于栈顶部，当去掉它时，栈的长度缩减了1。

** 如何解读深层的错误 **

当程序中有一个错误发生时，如果引起一个未捕获的错误，您将看到一个比之前见过的更加复杂的错误。例如，假设传递了一个包含列表而不是一个数值的字典。这将导致一个如下所求的错误：
``` python
 >>> make_omelet({"a":1, "b":2, "j":["c", "d", "e"]})
 omelet_type is a dictionary with ingredients
 Adding 1 of a to make a omelet
 Adding 2 of b to make a omelet
 Traceback (most recent call last):
   File "<stdin>", line 1, in ?
   File "ch5.py", line 96, in make_omelet
     return make_food(omelet_type, "omelet")
   File "ch5.py", line 45, in make_food
     Print("Adding %d of %s to make a %s" % (ingredients_needed[ingredient], ingredient, food_name))
 TypeError: int argument required
```
当从文件进入一个函数后，Python将指出您在栈中的位置（这意味着错误发生时有多少层以及栈中的每层在程序哪一行被调用），因此可以打开有问题的文件来确定发生了什么。

当调用更多的函数或者使用函数调用其他函数，创建了深层的栈（可以将它想象为长一些的列表）时，就获得了使用栈跟踪（这是引发一个错误或者引起一个异常时，Python对输出使用的通用名称）的经验。前面的栈跟踪尝试为3，可以看到在第45行，当调用`make_food`时，参数类型有问题。现在可以回去修复它。

如果认为这个问题会经常发生，可以将`make_food`调用括在一个`try ... :`代码块中，这样`TypeError`错误将不会终止程序。然而，如果能在函数中处理掉这个错误，就更好了。

在使用明显错误的类型或字典成员的情况下，Python将引起一个`TypeError`，我们通常没必要执行额外的操作。然而，希望如何处理特定的情形取决于您。

栈跟踪是栈的可读形式，可以检查它们来确定问题所在。栈跟踪显示了问题发生时的所有情况，只要引发异常，Python就会生成栈跟踪。

#### 5.4 本章小结
本章介绍了函数。函数将Python中的若干语句聚焦在同一个名称下，以在需要的时候调用它。在定义函数时，可以指定该函数带有参数，这样在调用它时，函数就可以对指定的参数值进行操作。

函数的参数名称与该函数一起定义，它们在函数名称后面用括号括起来。不需要参数时，括号仍然出现，只是为空而已。

当函数被调用时，每个函数创建了自己的作用域，在其中可以访问全局范围内的名称，还可以访问函数体内创建和赋值的名称。如果一个全局名称在一个特定函数内被赋值，当用全局名称引用它时，它的值不发生变化，只是在该函数体内发生变化。

如果一个函数 在另外一个函数内定义，它可以访问定义它的函数内的所有名称，还有全局范围的所有名称。记住，这种可见性取决于函数在哪里定义，而不取决于它在哪里被调用。

函数可以在其他函数内被调用。这样可以使用程序易于理解。函数将通用的任务用一个简短的名称表示，减少了重复输入。

定义了参数的函数通过值来调用，提供的每个值都要赋给函数参数列表中的名称。传递给函数的第一个参数赋值给第一个名称，第二个参数赋给第二个名称，依此类推。给函数传递参数时，每一个参数要么是必要的，要么是可选的。定义函数时，可选 参数必须位于必需参数后面，可以赋予它们默认值。

可以使用`raise ... :`特征通知发生了错误，这些错误可以被`except ... :`接收和处理。这就可以从函数提供反馈，它不仅提供错误类型，还提供了对错误进行描述的字符串，从而使该错误可以被处理。

本章还介绍了栈。当`raise ... :`或者程序中的其他错误引发了一个错误条件时，错误的位置不仅通过发生错误的函数名称来描述，还通过涉及到函数名称以及它们的调用位置来描述。如果一个函数足够有用，可在不同的地方使用它，且它只在其中一个地方出问题，可以通过栈跟踪缩小问题源。

** 本章要点 **

* 通过`python -i`（或者`Run with Interpreter`）运行Python程序，可以创建一些较长的程序，而不用直接向Shell中输入代码。
* 通过将代码片段另存为函数，使它们可在当前或者以后的程序中重复使用，可以节省时间。
* 文档字符串以三引号(""")开头，它可以定义函数的用途，为自己和将来的程序员留下注释。
* 可以在函数中用`__doc__`显示文档字符串。
* 通过`dir()`可以看到一个对象的所有属性。
* 可以通过`#`向代码中添加注释。Python忽略同一行中该符号后面的内容。注释允许您留下记录，若干月后需要再次查看代码或其他编程人员需要阅读代码时，可以更快地理解当初编写的代码。
* `type()`函数可以显示一个对象的类型。

#### 5.5 习题
1. 编写一个名为`do_plus`的函数，它接收两个参数，并且用“＋”将它们相加。
2. 增加类型检查，以确认参数的类型要么是整形，要么是字符串。如果参数不正确，招聘一个`TypeError`。
3. 这个题目的工作量较大，请随意将它分为几部分。第4章中，编写一个循环制作煎蛋卷。它做了从检查成分到把它们从冰箱中取出并做成一个煎蛋卷的全部工作。以该循环为原型，更改`make_omelet`函数，编写一个名为`make_omelet_q3`的函数。它应该从下述方面对`make_omelet`进行修改，使得它更加贴切描述一个真实的厨房：
> a. 将冰箱作为第一个参数传递给新的`make_omelet`。应当检查冰箱的类型，确保它是一个字典。
>  b. 增加一个函数检查冰箱，并且将即将用到的成分从冰箱中减去。将这个函数命名为`remove_from_fridge`。该函数首先检查冰箱中是否有足够多的成分制作煎蛋卷，检查完毕后，再将这些成分从冰箱中取出以制作煎蛋卷。用错误类型`LookupError`作为要招聘的错误的类型。
>   c. 将从冰箱中取出的食物放到一个字典中，由函数`remove_from_fridge`函数返回，赋给一个名称，将该名称传递给`make_food`。毕竟，并不希望将不打算使用的食物从冰箱中取出。
>    d. 制作一个不同的默认煎蛋卷，而不是奶酪煎蛋卷。向函数`get_omelet_ingeredients`中添加这个煎蛋卷的成分。
4. 更改`make_omelet`，在订购沙门氏菌煎蛋卷时，使用`get_omelet_ingredients`函数抛出一个`TypeError`错误。尝试订购一个沙门氏菌煎蛋卷，并查看产生的栈跟踪。

### 第6章 类与对象

到目前为止，已经介绍了编程所需的大多数构建模块。您已经使用了数据，使用名称引用数据（程序员通常将这些名称称为变量），还在循环和函数中使用过数据。这三个元素的使用是编写程序以及用计算机解决问题的基础。可以使用名称来存储和引用值，并对它们进行操作。循环可以重复处理列表中的每个元素（或每隔一个元素、两个元素等的元素）。最后，函数可将一组代码整合到一个名称下，这样可在任何需要的时刻和位置调用它。

本章将介绍：
* Python如何将函数和数据整合在一起，并通过一个对象的名称访问它们。
* 如何 和为什么使用类与对象，以及它们如何使编程人员易于在多种情形下编写和使用程序。

#### 6.1 考虑编程

到目前为止，本书已经介绍了Python的基础知识，现在要在Python中创建一个对对象的描述，您已有足够的知识获得两个视图。每一个是数据视图，除了在顶层或者全局作用域的数据外，可以根据需要使用和清除它们。另一个是函数视图，它们没有固有的数据，而只操作提供给它们的数据。

##### 6.1.1 对象的含义

Python中的任何一条数据都是对象。每个对象都由3部分组成：标识、类型和值。对象的标识代表该对象在内存中的存储位置（因此是不可更改的），对象的类型表明它可以拥有的数据和值的类型。在对象中，可变类型的值可以更改，不可变类型的值不能更改。

简单此的解释是参考本书中已经介绍的（或者即将介绍）的对象。例如，整型、字符串、列表等都是对象。可以在程序中很方便地使用这些对象，但是将关系紧密的对象整合在一起岂不更有意义？这也是类的由来。类允许定义一组对象，并将它们封闭到一个方便的空间中。

##### 6.1.2 已经了解的对象

下面即将介绍的方法使您可以考虑包含数据和函数的完整对象。字符串是前面已经接触过的对象。一个字符串不仅包含文本，也有关联的方法，这使得字符串不仅代表文本，还提供了一些功能，例如将整个字符串变成大写或者小写。下面简单回顾已经学到的知识。一个字符串主要的是指输入的文本：
``` python
 >>> omelet_type = "cheese"
```
除了经常处理的数据，即文本“Cheese”，字符串这种对象还拥有方法，方法经常被叫做行为。每一个字符串都有一些方法，如返回小写的字符串的`lower`方法，以及返回一个完全大写的字符串的`upper`方法：
``` python
 >>> omelet_type.lower()
 'cheese'
 >>> omelet_type.upper()
 'CHEESE'
```
其他可用的方法还有内置在元组、列表和字典对象中的方法，例如字典的`keys`方法，在前面已经使用过该方法：
``` python
 >>> fridge = {"cheese":1, "tomato":2, "milk":4}
 >>> for x in fridge.keys():
         print(x)
 ['tomat', 'cheese', 'milk']
```
使用`dir`函数可以列举出一个对象的所有属性和方法：
``` python
 dir(fridge)
['__class__', '__contains__', '__delattr__', '__delitem__', '__doc__',
'__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__',
'__gt__', '__hash__', '__init__', '__iter__', '__le__', '__len__',
'__lt__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__',
'__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__',
'clear', 'copy', 'formkeys', 'get', 'items', 'keys', 'pop', 'popitem',
'setdefault', 'update', 'values']
```
`dir`函数可以显示字符串或者Python中其他任何对象的所有数据方法，简言之，它可以显示这些对象所包含的每个名称。`Dir`函数能够以字母表的顺序列出正在检查的对象中所有可用的名称，它将以下划线开头的名称放在结果的最开始。按照约定，以下划线开头的名称是对象的私有属性，它们是不可见。即，不能直接使用它们，但是Python将决定权留给了开发人员，所以您可以交互地查看这些属性以学习它们：
``` python
 >>> type(omelet_type.__len__)
 <class 'method-wrapper'>
```
这很有趣。可以调用该方法，并观察它输出的结果：
``` python
 >>> omelet_type.__len__()
 6
```
这个方法返回与内置函数`len`一样的结果。当一个函数内置到一个对象中时，它叫做这个对象的“方法”。

实际上，函数`len`就是利用方法`__len__`工作的：函数`len`向这个内置方法询问对象的长度。对象的设计者可定义长度的计算方式，使得对于定义了`__len__`方法的任何对象，内置函数`len`都能够正确运行。

其余的以下划线形状的名称也都具有特殊含义。可以在Python Shell中探究它们。Python Shell通过显示试图调用的对象内的名称，帮助研究一个字符串对象的方法，但它不显示以下划线开头的内部名称。您可以使用`dir`函数实现该功能。

##### 6.1.3 展望：如何使用对象

我们希望能够以自然的方式使用对象。例如，一旦定义了`Omelet`类之后，它便可以产生对象，在查看源代码时，这些对象以自然的方式工作。稍后就会尝试编写实现该操作的代码（下一节中将看到如何操作）：
``` python
 >>> o1 = Omelet()
 >>> o1.show_kind()
 'cheese'
```
我们希望将冰箱当做对象使用，而不仅仅把它看做一个字典。如果使用它就像使用一个真正的冰箱一样，就太合适不过了，我们可以向其中增加食物、从中取出食物、检查食物，以及一次增加或者取出多种食物等。

换言之，创建一个对现实世界的某物进行模拟的对象时，应该使熟悉该现实事物的人们能够比较轻松地认知和理解它们。


#### 6.2 定义类

当思考包含几百行Python代码的小程序如何运行时，经常可以发现程序将数据组织成组的形式——当访问某个数据时，将影响与该数据一起协作的数据。经常会碰到有朴素依赖关系的完整数据列表，如列表1的第一个元素与列表2和列表3中的第一个元素匹配，依此类推。有时，必须通过创造性地将这些列表组合起来才能解决这个问题。Python运用了创建用作占位符的整个类的概念，类起了占位符的作用。当一个类被调用时，它创建了绑定到一个名称的对象。

##### 6.2.1 如何创建对象
将对象绑定到一外名称后，使用该名称可以访问已定义的数据和函数。编写一个类的代码之前，首先要声明该类。通过`class`关键字声明类。

@(试一试)[定义一个类]

定义一个类比较简单，主要是使用关键字`class`，并在后面紧跟一个名称来完成。定义类的方式与定义函数的方式类似，只不过不在类定义之后放置包含项目的元组（在类的定义之后放置包含项目的元组将创建一个要继承的类，第10章将介绍这方面的内容）。
``` python
 class Fridge:
     """This class implements a fridge where ingredients can be
     added and removed individually, or in groups."""
```

** 示例说明 **

从类的定义开始，缩进于其中的所有代码在该类创建的对象中都可用。在第5章介绍函数时已经见过这一点，类似的规则同样适用于类。在类中可以自由选择内置文档字符串，就像在函数中一样。它们的表现方式相同，并且非常有用，提供了了解类信息的简单方法。

如前面的例子所求，应当试着创建`Fridge`类。注意此处使用了大写的“`F`”。类的名称以大写字母开头是Python程序员的惯例。当类的名称有多个单词时，另一种惯例是将这些词连在一起，但是每个词以大写字母开头以方便阅读。例如，模拟一个冰箱和制冷器的类可被命名为`FridgeAndFreezer`。

@(试一试)[由类创建对象]

尝试将`Fridge`类输入到文件`ch6.py`中（或者类似的文件中），之后用`python -i`或者命令`Run with Interpreter`调用该文件，如第5章所示。

通过使用一对圆括号调用`Fridge`类，可以创建一个`Fridge`对象：
``` python
 >>> f = Fridge()
```

** 示例说明 **

此时还没有定义任何复杂的类。`Fridge`类基本是空的，它将作为一个起点。然而，即使它是空的，也应当注意到已经创建了一个可用的空类。它几乎不进行任何操作，但在某些情形下，确实不需要进行任何操作。例如，可以将这个几乎为空的对象当作一个特殊类型的字典处理。可以通过在测试时交互地向类中添加名称来实现该操作。这有助于了解它的工作方式：
``` python
 >>> f.items = {}
 >>> f.items["mystery meat"] = 1
```
除此之外，在第10章将会介绍，异常实际上也是类，有时候只需要一个空类就可以创建一个有效的异常。当有一个简单的、像该类一样未定义的类时，应仅使用这种类型的直接访问。当有一个已做了许多定义的类时，访问该类作用域内的名称会妨碍类的编写方式，因此将引起许多麻烦。

开始编写一个类的最佳方式是首先确定它的功能。此处，基于Python的电冰箱模型`Fridge`是第一个类，它比较基础。考虑这个类时，要专注于需要一个特定的`Fridge`对象完成哪些功能。您希望该对象有足够多的操作可以制造食物，但是不希望担心现实生活中冰箱的一些问题，如温度、冷藏室、除霜、电等，这些具体的问题没有包括在这个简单的示例中，因为它们都是不必要的细节，只会使用目标变得复杂。现在向`Fridge`类中增加文档字符串，定义即将为它创建的各种行为。

首先，您希望`Fridge`类有一个存储食物的方法，并打算用两种方式实现该功能：第一种方式是一次添加一种类型的单个项目，并向类中增加一个完整的字典，这种方式比较易于初始化；第二种方式是模拟冰箱被填充的情形，例如购物归来的时候。

其次，您希望有一个从`Fridge`类取出食物的方法。在取出食物和放入食物时做相同的事情：从冰箱中拿出一个或者许多食物。

还需要向这个对象中写入若干代码，使选择的这个模型成为一个`Fridge:`一个是能确定某种食物是否在`Fridge`中存在的函数，另外一个是检查一个包含食物成分的完整字典的函数。现在可以开始准备烹饪了。

为了建模的目的，在使用`Fridge`存储成分并在希望烹饪时从冰箱中取出它们时，这即是需要的全部方法。换言之，这将作为该特定情形的模型运行，并能够应付每种可能的情况。

对象提供给外界使用的方法叫做它的接口，因为这些方法是对象之外的程序使用该对象的途径。对象通过提供接口变得实用。

接口是使对象可用的任何方法和名称。在Python中，这通常意味着没有以一个或多个下划线形状的方法和名称都是接口；当然，在类的文档字符串中明确指出哪些方法可用，以及如何使用它们，以与那些不希望被调用的函数区别，这是一个很好的习惯。
``` python
 class Fridge:
     """This class implements a fridge where ingredients can be
     added and removed individually, or in groups.
     The fridge will retain a count of every ingredient added or removed,
     and will raise an error if a sufficient quantity of an ingredient
     isn't present.
     Methods:
     has(food_name [, quantity]) - checks if the string food_name is in the
 fridge. Quantity will be set to 1 if you don't specify a number.
     has_various(foods) - checks if enough of every food in the dictionary is in the fridge
     add_one(food_name) - adds a single food_name to the fridge
     add_many(food_dict) - adds a whole dictionary filled with food
     get_one(food_name) - takes out a whole dictionary worth of food.
     get_many(food_dict) - takes out a whole dictionary worth of food.
     get_ingredients(food) - If passed an object that has the __ingredients__
            method, get_many will invoke this to get the list of ingredients.
     """
    def __init__(self, items={}):
           """Optionally pass in an initial dictionary of items"""
           if type(items) != type({}):
               raise TypeError("Fridge requires a dictionary but was given %s" %
   type(items))
           self.items = items
           return
```
花几分钟看上面代码中的`__init__`和`self`部分。这是类的两个非常重要的特征。当Python创建对象时，`__init__`方法传递给对象第一个参数。而`self`实际上是代表该实例本身的变量。

另外，当决定编写一个类时，为希望使用的方法做注释是一个好习惯。实际上，它是考虑类的完整性时，类要完成的功能的概述，这使得在编写程序的同时就可以测试程序（更详细的信息可参考第12章）。

当编写接口方法时，将会注意到，大多数情况下，简单的方法共享许多特征，例如“取出一种”、“取出两种”或者“取出多种”等，但是为了使它们调用起来比较简单，希望保留各种形式。这看起来好像要为其中每个函数重复大量源代码。然而，不用重复输入接口方法的共同部分，可以编写仅由每个方法内部使用的私有方法而节省输入。

这些私有方法可以执行部分或者全部接口方法的共同操作。当私有方法很复杂，或者包含用户在使用方法时不需要了解细节时，需要进行这样的操作。这样可以在类被调用时避免困惑，同时使用它更易于编写。最好的情况下，这是个明显的双赢局面。

在`Fridge`类，以及即将编写的许多类中，通常有一个方法可以操作一组数据，有另外一个方法只处理单个元素。不论何时遇到这种情况，都可以使处理单个项目的方法简单地调用可处理任意多个项目的函数而减少工作量。实际上，有时将该方法当作私有方法，或者不作为接口的一部分很有用。这样不管它是否被使用，它的更改都不会影响类的使用，因为对它所做的修改在对象外不可见，只在内部可见。

对于`Fridge`类，创建带有两个参数的内部方法`__add__multi`可将工作量减到最小，方法的两个参数分别是项的名称和项的数量。该方法可将项添加到每个对象的`items`字典中。

@(试一试)[编写内部方法]

当向本章的文件中添加新方法时，确保这些方法正确地缩进于`Fridge`类下，而不是单独出现在顶层。为了明确说明，在这里给出类的声明：
``` python
 class Fridge:
     # the docstring and intervening portions of the class would be here, and
     # __add_multi should go afterwards.
     def __add_multi(self, food_name, quantity):
           """
         __add_multi(food_name, quantity) - adds more than one of a
         food item. Returns the number of items added

         This should only be used internally, after the type checking has been done
            """
         if (not food_name in self.items):
             self.items[food_name] = 0
         self.items[food_name] = self.items[food_name] + quantity
```

** 示例说明 **
现在已有方法可将任意数量的食物添加到`Fridge`对象中。然而，这是一个内部方法，不能判定当前传入的类型（`food_name`或`quantity`）是否有效。应当用接口函数做这个检测，因为作为一个认真的程序员，总是需要确定给私有方法传递了正确的值。在允许的每个地方做检查是一个好想法，但在当前这个例子中，不打算在此处检查，因为只会以非常简单的方式使用`__add_multi`方法。

现在`Fridge`类已经拥有了很好用的方法`__add_multi`，之后`add_one`和`add_many`方法都可使用它，而不必交类似的函数写两遍。这就减少了工作量。

@(试一试)[编写接口方法]

为了更快捷，现在可以不输入文档字符串。此处的方法使您在遇到问题时，可以更好地理解代码的实际操作。

如前所示，这些方法需要缩进在`Fridge`类的定义中。看上去在每行的初始位置开始的任何代码实际上是前一行的延续，应当输入到同一行上：
``` python
 def add_one(self, food_name):
     """
     add_one(food_name) - adds a single food_name to the fridge
     returns True
     Raises a TypeError if food_name is not a string.
     """
     if type(food_name) != type(""):
         raise TypeError, "add_one requires a string, given a %s" % type(food_name)
     else:
         self.__add_multi(food_name, 1)

     return
 def add_many(self, food_dict):
     """
     add_many(food_dict) - adds a whole dictionary filled with food as keys and  quantities as values.
     returns a dictionary with the removed food.
     raises a TypeError if food_dict is not a dictionary
     returns False if there is not enough food in the fridge.
     """
     if type(food_dict) != type({}):
         raise TypeError("add_many requires a dictionary, got a %s" % food_dict)

     for item in food_dict.keys():
         self.__add_multi(item, food_dict[item])
     return
```

** 示例说明 **

`add_one`和`add_many`的目的类似，并且每个方法都有可以确保它们被正确使用的代码。同时，它们都使用`__add_multi`来完成主要的工作。现在，如果`__add_multi`的工作方式发生改变，开发人员可以节省时间，因为它将自动改变使用它的两个方法的行为方式。

现在已经编写了足够的代码，可将食物放入`Fridge`对象中，但是没有方法可以将放入冰箱的食物拿出来。可以直接访问`object.items`字典，但除了测试的时候，这从不是一个好主意。当然，现在就是测试，为何不这么做呢？
``` python
 >>> f = Fridge({"eggs":6, "milk":4, "cheese":3})
 >>> f.items
 {'cheese':3, 'eggs':6, 'milk':4}
 >>> f.add_one("grape")
 True
 >>> f.items
 {'cheese':3, 'eggs':6, 'grape':1, 'milk':4}
 >>> f.add_many({"mushroom":5, "tomato":3})
 >>> f.items
 {'tomato':3, 'cheese':3, 'grape':1, 'mushroom':5, 'eggs':6, 'milk':4}
 >>>
```
目前为止输入的代码都能正常工作！这是较简单的部分。接下来需要增加可以判断冰箱中是否存在某物的方法。

编写代码证实某物是否在冰箱中存在很重要，因为它可用于取出食物的方法中，如`get_one`、`get_many`和`get_ingredients`，从而使这些方法可以检查冰箱中是否有足够多所需的食物。这正是`has`与`has_various`方法的用途：
``` python
 def has(self, food_name, quantity=1):
     """
     has(food_name, [quantity]) - checks if the string food_name is in the fridge. Quantity defaults to 1
     Returns True if there is enough, False otherwise.
     """

     return self.has_various({food_name:quantity})

 def has_various(self, foods):
     """
     has_various(foods) determines if the dictionary food_name has enough of every element to satisfy a request.
     returns True if there's enough, False if there's not or if an element does not exist.
     """

     tyr:
         for food in foods.keys():
             if self.items[food] < foods[food]:
                 return False
         return True
     except KeyError:
         return False
```
在`has`和`has_various`方法完成后，可在测试中使用`Fridge`对象，当阅读代码时，它总是有意义的。

@(试一试)[使用更多的方法]

现在可以使用`python -i`或者`Run with Interpreter`命令调用`ch6.py`文件，这样可以使用添加到`Fridge`类的任何代码。如果出现错误而不是`>>>`提示符，注意招聘的异常，并试着修复缩进问题、拼写错误或者其他基本的错误。

`Fridge`类可按下述方法使用：

``` python
 >>> f = Fridge({"eggs":6, "milk":4, "cheese":3})
 >>> if f.has("cheese", 2):
 ...     print("It's time to make an omelet!")
 ...
 It's time to make an omelet!
```

** 示例说明 **

现在已经定义了新的方法，`f`对象可以使用它们。当用鸡蛋、牛奶以及奶酪重新创建`f`对象时，就从新的`Fridge`类创建了对象，因此它拥有新添加的可用方法。

最后，我们应当讨论从冰箱中取食物的方法了。与向冰箱中添加食物的方法类似，由一个核心方法完成主要工作，所有接口方法者信赖于这个方法：
``` python
 def __get_multi(self, food_name, quantity):
         """
     _get_multi(food_name, quantity) - removes more than one of a 
     food item. Returns the number of items removed
     returns False if there isn't enough food_name in the fridge.
     This should only be used internally, after the type checking has been
     done
         """
     try:
         if (self.items[food_name] is None):
             return False;

         if (quantity > self.items[food_name]):
             return False;
         self.items[food_name] = self.items[food_name] - quantity
     except KeyError:
         return False
     return quantity
```
当定义了上面的方法后，可以创建`Fridge`类的文档字符串指定的其他方法。其中每个方法都使用了`__get_multi`，因此都可以用最少的额外代码从冰箱中取出食物：
``` python
 def get_one(self, food_name):
     """
     get_one(food_name) - takes out a single food_name from the fridge 
     returns a dictionary with the food: 1 as a result, or False if there 
 want's
     enough in the fridge.
     """
     if type(food_name) != type(""):
        raise TypeError("get_one requires a string, given a %s" % type(food_name))
     else:
         result = self.__get_multi(food_name, 1)
     return result
 def get_many(self, food_dict):
     """
     get_many(food_dict) - takes out a whole dictionary worth of food.
     returns a dictionary with all of the ingredients
     returns False if there are not enough ingredients or if a dictionary
     isn't provided.
     """

     if self.has_various(food_dict):
         foods_removed = {}
         for item in food_dict.keys():
             foods_removed[item] = self.__get_multi(item, food_dict[item])
         return foods_removed

 def get_ingredients(self, food):
     """
     get_ingredients(food) - If passed an object that has the __ingredients__
         method, get_many will invoke this to get the list of ingredients.
     """
     try:
         ingredients = self.get_many(food.__ingredients__())
     except AttributeError:
         return False
     if ingredients != False:
         return ingredients
```
现在已经编写了一个完全可用的冰箱类。记住，可以将这些内容沿不同的方向引申。不只可以使用`Fridge`类制作煎蛋卷，也可以将它用于其他项目，对产品流程进行建模，例如，熟食品店有10个冰箱，每个冰箱中都装着不同的食品。

当有机会为已经编写的类（或者使用过的类）赋予新的用途时，可利用这个机会，在不影响类的已有功能的基础上向类中添加一些功能以支持新的需求。

例如，在需要若干个冰箱的应用程序中也许需要每个`Fridge`类有一些额外的属性，例如名称（像“奶制品冰箱”）、在商店中的位置、最佳温度设置和尺寸等。可以将这些属性添加到类中，并添加读取和设置这些值的方法，同时仍保持它对于本书中的煎蛋卷示例安全可用。接口的好处在此时就体现出来了。只要`Fridge`类中的接口没有改变，或者只要它们的运行方式保持不变，您就可以任何修改。保持接口行为不变的能力叫做类的稳定性。

##### 6.2.2 对象和它们的作用域
如在第5章所见，函数为它们使用的名称创建了自己的空间，也就是作用域。当函数被调用时，声明了名称并赋值之后，只要函数还在使用，任何对名称做出的修改会持续下去。然而，在函数结束运行，并再次被调用时，之前调用过程中所做的工作都丢失了，该函数必须重新开始执行。

对象中的值可被存储，并在对象内关联到`self`（这晨的`self`是指对象本身的名称，它与对象外指向对象的名称，例如`f`是一样的）。只要对象被一个仍在使用的名称引用，它包含的所有值也可用。如果一个对象在函数中被创建，并且没有被该函数返回，即该对象没有被一个具有更长生命周期的名称引用，那么与函数中的其他数据一样，它只在调用它的函数中可用。

如果多个对象先后被创建，它们就可被一起使用。例如，现已经在程序中实现了一个能够工作的`Fridge`的所有特性，还需要`Omelet`对象与其一起协作。

@(试一试)[创建另外一个类]

我们已经创建了一个类`fridge`。用同样的形式，可以创建一个可用的`Omelet`类：
``` python
 class Omelet:
     """This class creates an omelet object. An omelet can be in one of
     two states: ingredients, or cooked.
     An omelet object has the following interfaces:
     get_kind() - returns a string with the type of omelet
     set_kind(kind) - sets the omelet to be the type named
     set_new_kind(kind, ingredients) - lets you create an omelet
     mix() - gets called after all the ingredients are gathered from the fridge
     cook() - cooks the omelet
     """
     def __init__(self, kind="cheese"):
         """ __init__(self, kind="cheese")
         This initializes the Omelet class to default to a cheese omelet.
         Other methods
         """
         self.set_kind(kind)
         return
```

** 示例说明 **

现在有一个类，它的目的很明确。在第5章的函数中，已经见过大多数这样的行为，但是现在有了一个结构，可以在其中整合所有这些行为。

`Omelet`类有接口方法，使得它可与`Fridge`对象协作，并且与第5章一样，它仍具备创建定制的煎蛋卷的能力。

下面所有代码都必须在`Omelet`类定义下缩进一个级别：
``` python
 def __ingredients__(self):
         """Internal method to be called on by a fridge or other objects
     that need to cat on ingredients.
         """
     return self.needed_ingredients

 def get_kind(self):
     return self.kind

 def set_kind(self, kind):
     possible_ingredients = self.__known_kinds(kind)
     if possible_ingredients == False:
         return False
     else:
         self.kind = kind
         self.needed_ingredients = possible_ingredients

 def set_new_kind(self, name, ingredients):
     self.kind = name
     self.needed_ingredients = ingredients
     return

 def __know_kinds(self, kind):
     if kind == "cheese":
         return {"eggs":2, "milk":1, "cheese":1}
     elif kind == "mushroom":
         return {"eggs":2, "milk":1, "cheese":1, "mushroom":2}
     elif kind == "onion":
         return {"eggs":2, "milk":1, "cheese":1, "onion":1}
     else:
         return False

 def get_ingredients(self, fridge):
     self.from_fridge = fridge.get_ingredients(self)

 def mix(self):
     for ingredient in self.from_fridge.keys():
         print("Mixing %d %s for the %s omelet" %
 self.from_fridge[ingredient], ingredient, self.kind))
     self.mixed = True

 def make(self):
     if self.mixed == True:
         print("Cooking the %s omelet!" % self.kind)
         self.cooked = True
```
现在有一个`Omelet`类可以创建`Omelet`对象。`Omelet`类与第4章和第5章中制作煎蛋卷的过程有相同的特性，但更简单易用，因为所有我都整合在了一起，并且`Omelet`的外在表现集中到几个简单的接口。

现在有两个类，在用`python -i`或者`Run with Interpreter`命令加载它们后，可以制作一个煎蛋卷：
``` python
 >>> o = Omelet("cheese")
 >>> f = Fridge({"cheese":5, "milk":4, "eggs":12})
 >>> o.get_ingredients(f)
 >>> o.mix()
 Mixing 1 cheese for the cheese omelet
 Mixing 2 eggs for the cheese omelet
 Mixing 1 milk for the cheese omelet
 >>> o.make()
 Cooking the cheese omelet!
```
这并不比在第5章中制作一个煎蛋卷更难或者更简单。然而，当同时要处理多件事情时，使用对象的好处变得很明显。例如，需要同时制作多个煎蛋卷：
``` python
 >>> f = Fridge({"cheese":5, "milk":4, "eggs":12, "mushroom":6, "onion":6})
 >>> o = Omelet("cheese")
 >>> m = Omelet("mushroom")
 >>> c = Omelet("onion")
 >>> o.get_ingredients(f)
 >>> o.mix()
 Mixing 1 cheese for the cheese omelet
 Mixing 2 eggs for the cheese omelet
 Mixing 1 milk for the cheese omelet
 >>> m.get_ingredients(f)
 >>> m.mix()
 Mixing 1 cheese for the mushroom omelet
 Mixing 2 eggs for the mushroom omelet
 Mixing 1 milk for the mushroom omelet
 Mixing 2 mushroom for the mushroom omelet
 >>> c.get_ingredients(f)
 >>> c.mix()
 Mixing 1 cheese for the onion omelet
 Mixing 2 eggs for the onion omelet
 Mixing 1 milk for the onion omelet
 Mixing 1 onion for the onion omelet
 >>> o.make()
 Cooking the cheese omelet!
 >>> m.make()
 Cooking the mushroom omelet!
 >>> c.make()
 Cooking the onion omelet!
```
花几分钟时间将上面的代码与第5章中功能相同的函数进行比较，您将意识到为什么要用这种方式编写程序，以及这样的编程方式（叫做面向对象编程）为什么会用于编制大型系统。

只要冰箱里有需要的材料，制作不同类型的煎蛋卷变得异常容易：仅需调用该类创建一个新对象，之后调用每个`Omelet`对象的3个方法。当然，可以将这三个方法减少为一个。

#### 6.3 本意小结

本章介绍了Python中的类和对象，这是面向对象编程的基本概念。

在类中使用的函数叫做方法，每个类都有一个特殊的名称`self`，当`self`被调用时，它包含对象中所有的数据和方法。

使用类的名称并在后面跟着圆括号“()”来创建该类的对象。此时可以给定初始化参数，当然不论是否提供参数，新创建的对象都将调用方法`__init__`。与普通的函数一样，类中的方法（包括`__init__`）可以接收参数，包括可选的和默认的参数。

创建一个类的过程包括决定创建哪些方法，以完成期望的功能。类中的方法通常可分为两类：一类是公共接口，应当在对象外部调用，另一类是私有方法，应当只能被对象内部的其他方法调用。接口应当尽量不变，而内部的私有方法可以改变，而不影响类的使用方式。当使用其他人编写的类时，记住这一点尤其重要。Python认为在对象作用域内，以两个下划线形状的任何名称都是私有属性，因此您也应当遵守这个约定。其他名称一般被认为是公共的。

** 本章要点： **

* 为了详细说明类的使用方法，应当为这个类创建文档字符串，即在类定义后的第一行输入一个字符串。文档字符串最好能够提供期望被使用的方法的名称和用途。在文档字符串中包含对整个类的解释也不是一个坏主意。
* 类中定义的所有名称（数据和方法）在每个创建的对象中都不同。当一个对象调用某个方法时，该方法改变那个对象中的数据，而同一类型的其他对象则不受影响。Python中内置的字符串对象就是一个示例，它们包含特殊的方法，可以帮助完成普通的文本处理任务。
* 为了使对象易用，通常提供行为类似的多个接口。为了节省工作，这些接口可以找到调用内部方法的一些方式，而内部方法比它们更复杂，接收更多的参数。这有两个好处。第一，调用这些方法的代码更易读，程序员不必记住参数的名称，因为方法的名称本身就提供了程序员所需的信息。第二，只改变内部方法就可以改变所有相关接口的行为。这在修复问题时尤其有用，因为一个修复就可改正所有接口的工作方法。另外，为其他方法提供这种支持的方法本身也可以是公共接口。像这样一个特别有用的方法应当是私有的还是公共的并没有严格的规则，这完全由开发人员决定。
* 编写对象的一个目的是尽量少编写重复代码，而是提供尽量多的特性。创建使用对象的类可以节省大量输入，因为它们通常比数据和函数分开更易于操作，原因在于同一个类中的方法总是可以确定它们使用的其他方法和数据是存在的。可以写一组相互依赖的类，对相互协作的事物建模。第7章将介绍如何组织这些相互依赖和合作的类。
* 本章最后介绍了Python的代码编辑器Shell，它可以帮助研究对象，只要输入一个句点，它将显示该对象所有接口的名称。这比输入`dir`得到相同信息更简单，因为代码编辑器能够以便捷和易于使用的方式显示信息。

#### 6.4 习题

下面每个习题都是建立在前面习题的基础之上。
1. 向`Omelet`类的`mix`方法中加入一个可以关闭创建消息的选项，方法是添加一个默认为`True`的参数，表示应当打印“mixing...”消息。
2. 在`Omelet`类中创建一个方法`quick_cook`，该方法使用习题1中新的`mix`方法，它接受3个参数：煎蛋卷的类型、需要的数量，以及它们来自于哪个`Fridge`。`quick_cook`应当实现需要的功能，而不只是3个方法调用，但是它应当使用已有的方法完成这些功能，包括已修改的`mix`方法，它关掉了`mix`的消息。
3. 试着为`Omelet`类中所有没有文档字符串的方法创建一个文档字符串。确保在每个文档字符串中包含方法的名称，方法需要的参数，方法的功能，成功时返回的值，以及当发生错误时返回的结果（或者抛出什么样的异常）。
4. 创建一个`Omelet`对象，查看已创建的文档字符串。
5. 创建可以被`Omelet`类调用的`Recipe`类，它可以得到食物成分。`Recipe`类应当拥有`Omelet`类包括的煎蛋卷成分列表，还可以包含其他任何喜欢的食物。`Recipe`类应当有获得食谱的方法`get(recipe_name)`，以及添加食谱并对它命名的方法`create(recipe_name, ingredients)，其中`ingredients`是一个字典，与`Fridge`类和`Omelet`类中用到的字典格式相同。
6. 更改`Omelet`类中的`__init__`方法，它可以接受`Recipe`类作为输入。为此，可执行如下操作：
> a. 创建一个名称self.recipe，这是每个`Omelet`对象都有的名称。
> b. `Omelet`类的内部方法`__known_kinds`存储处方。更改`__known_kinds`，在期望的煎蛋卷类中调用`self.recipe.get()`来使用食谱。
> c. 更改`set_new_kind`方法，将新的食谱添加`self.recipe`中，之后调用`set_kind`，将当前煎蛋卷的类型设置为刚添加到食谱中的类型。
> d. 修改`__known_kinds`，使用`recipe`的`get`方法找出煎蛋卷的成分。
7. 尝试使用所有的新类和新方法，判断您是否已经理解了它们。

### 第7章 组织程序
第6章中，您开始利用Python的特性创建不同的类，这些类可以创建完全自包含对象。创建的类和对象是一些工具，用于将数据和函数集中到自包含的空间，这样可将它们一个大实体的一部分。

到目前为止，都是在一个文件中定义类，而且并没有以通常的方式运行程序。相反，它们被交互式地调用，因此可以像从加外的程序中调用一样使用类。然而，如果希望用学到的知识使用编写的类，则需要使定义这些类的文件成为程序。这意味着使所有的类放在文件的开始，而将重要的做决策的代码放在文件尾部。通常需要花费大量时间在文件的尾部寻找希望找到的代码。

还有一点需要注意。类非常有用，但并不是所有的问题都要通过创建类来解决。有时，定义类是大材小用，有时则只需要函数，而并不需要像对象中的数据和方法那样拥有较长的生存期。

Python提供了一些强大的我使其更有用，其中之一就是允许创建模块，这些模块为函数和数据创建了一个已命名的作用域，但是比类和对象简单。模块是个工具，它将程序划分为不同的命名片段，而不性命用类来实现这一点。实际上，可在模块中定义类。

作为扩展，可以将这些模块划分到不同的文件中，Python将这个特性叫做包。包将程序分散到几个文件中，甚至分散到不同的目录中，以对它们进行组织。

到目前为止，本书只介绍了Python语言的内部知识，即Python的工作原理。尽管Python只有一小部分核心特性，但它非常灵活，可在各种模块中扩展。可以使用一个叫做`os`的模块扩展Python，使其能够利用操作系统的特性。Python也具备网络特性，这是通过既能提供低级的网络协议（例如套接字），也能提供高级的网络协议（例如`http`和`ft`等）的模块实现的。Python有许多自带模块。由于模块易于编写，所以有各式各样的由第三方提供的模块，其中既有免费的也有商业性的。

本章将介绍：
* 如何编写自己使用或者共享的简单模块。
* Python中捆绑的模块。
* 导入模块的概念。
* 如何在包中包含独立于全局作用域的有效的函数和名称。
* 如何利用作用域测试包。

#### 7.1 模块

模块包含与一个公共主题相关的一组函数、方法或者数据。这样的主题可能是网络组件（见第16章），执行更加复杂的处理字符串和文本的操作（见第12章），处理图形用户界面（见第13章），以及其他服务。

在学习了如何使用一门语言编程之后，您将发现经常需要使用一些组件，这些组件最开始时并没有被捆绑到语言中。Python也不例外。Python是一个小巧简单的语言，没有提供许多特性。然而，因为它的简单性，可以把它作为一个平台，用一些任何人可用的函数和对象对它进行扩展。

##### 7.1.1 导入可用模块

为了使用模块，需要完成以下两个操作。首先要在操作系统上安装该模块。希望完成的大多数基本操作，例如读写文件等（第8章将介绍更多这方面的内容），以及其他一些重要的基础性操作（这些操作在不同的平台上是不同的），都可以通过内置于Python的模块完成——即它们是免费的，并且在语言中通用。

开始使用模块的最简单的方式是用`import`关键字导入它：
``` python
 import sys
```
这条语句将导入名称为`sys`的模块，它包含了Python提供的主要与各个系统有关的服务。这意味着它与系统的工作方式有关，例如如何安装一个特定版本的Python，或者如何从命令行调用程序。

为了查看模块，您将正在处理的文件编写为可以独立运行的程序。为此，创建文件`ch7.py`，并输入如下代码：
``` python
 #!/usr/bin/env python3.1
 # Chapter 7 module demonstration
 import sys
```
第一行用于在Linux和其他Unix系统中使用Python（或者是在基于UNIX的系统 中使用Python，例如Cygwin）。在系统中还有其他Python解释器时，可以用上述方式运行Python 3.1。在Windows和Macintosh系统中，文件的扩展名应该提供操作系统用来加载Python解释器所需的信息，可能是Python、Python 3.1或者安装到系统上时使用的其他名称（尽管需要一些配置）。

##### 7.1.2 通过已有模块创建新模块

为了创建模块，首先要为该模块选择一个名称，并在编辑器中打开以该名称命名的文件，文件的扩展名是`.py`。例如，为了创建`Foods`模块，仅需创建`Foods.py`文件。创建后，可以通过使用“`Foods`”名称导入创建的模块，而不用在模块名称尾部添加`.py`。此时，就已经成功导入了一个简单的模块！

@(试一试)[创建模块]

将第6章的所有源代码复制到文件`Foods.py`中。复制完成后，打开Python Shell，导入`Foods`模块：
``` python
 >>> import Foods
 >>> dir(Foods)
 ['Fridge', 'Omelet', 'Recipe', '__builtins__', '__doc__', '__file__', '__name__']
```

** 示例说明 **

现成已经访问了`Fridge`类、`Omelet`类，还有前面习题中的`Recipe`类。得到文件就是一个模块，其中包含这些类，使得它们可以一起工作。不过现在需要通过名称`Foods.Fridge｀、`Foods.Omelet`和`Foods.Recipe`访问这些模块，虽然有了一些新规则，它们仍旧完全可用。

这是您第一次直接运行本书中的示例！Python维护了一个默认的目录列表，它在列表中的目录下寻找要加载的模块。这个列表包括了若干目录，它们的确切位置取决于安装Python解释器的方式。如果尝试导入`Foods`模块，但Python Shell却从一个未存放`Foods.py`文件的目录启动，就将得到一个错误（但是可以通过转换到正确的目录解决该问题）。

Python自动搜寻的路径或者目录列表存储于`sys`模块的`path`变量中。为了访问该名称，要先导入`sys`模块。导入`sys`模块后，`sys.path`才可以使用：
``` python
 >>> import sys
 >>> print(sys.path)
 'C:/python31/Chapter 6', 'C:\\Python30\\Lib\\idlelib',
 'C:\\Windows\\system32\\python31.zip', 'C:\\Python31\\DLLs',
 'C:\\Python31\\lib', 'C:\\Python31\\lib\\plat-win',
 'C:\\Python31', 'C:\\Python31\\lib\\site-packages']
```
`sys.path`是一个普通的列表，如果希望添加出现在`sys.path`之外的搜索目录，可以用普通方法更改系统路径——要么用`append`方法增加一个目录，要么用`extend`方法增加任意数量的目录。

导入`Foods`模块后，在输入一个名称时，它将弹出该模块作用域内所有名称的列表，代码编辑器的这种特性可以通过交互的方式提供帮助。每当输入一个句点时，如果输入的名称与一些名称关联，代码编辑器允许从该名称提供的接口做出选择。这有助于研究刚才创建的模块，但是大型复杂模块中将更有用！

现在可以运行前面章节中的示例了，但是现在需要通过`Foods`模块访问类。例如，需要调用`Foods.Fridge`，而不是`Fridge`。如果希望单独访问`Fridge`，您很快就将看到如何完成该操作。

@(试一试)[研究新模块]

Python Shell中的代码编辑器提供的特性可以在开发人员输入代码的过程中与其交互。您也许已经注意到，输入一个类或者一个模块的名称后，在名称后输入一个句点，Shell将显示一个菜单，它包含模块或对象作用域中的名称。图7-1显示了这个特性，您也可以执行相同的操作。
!(图7-1)[]
** 示例说明 **
在Shell中输入代码的同时，它将对输入的内容求值。当输入了特定字符时，Python将对其执行操作。例如，无论输入哪各类型的引号，字符串都会改变颜色，还有就是在Python中关键字的颜色也不同。无论何时向Python Shell中输入一个句后，它知道开发人员希望看到某个模块或者对象的内部，因此，它在后台查询该对象并显示结果。

##### 7.1.3 从命令行开始使用模块

到日前为止，您已经开始使用`import`，并在它后面跟着一个模块名称。当使用这种方式导入模块时，它包含的所有名称都被放到了该模块命名的作用域中，也就是说，作用域的名称就是`import`语句中使用的名称。

例如，在`sys`中，通过在`sys`后加上一个句点和内部名称，可以引用该模块内所有可用的内容，例如`sys.path`或者`sys.copyright`，如字面意思所求，`sys.copyright`指出了Python的版权。知道了模块的组织方式，就可以交互地使用代码编辑器Python Shell，或者像第6章那样使用`dir`函数，研究`sys`模块（`dir`甚至比代码编码器Shell的帮助对话框中显示的有效信息更多，它可以显示私有名称，这些私有名称不是模块接口。在类和对象中看到的概念依然适用于模块）。也可以研究模块以及模块中的函数和类中的文档字符串。

在UNIX和类UNIX环境中，要求用户提供命令行参数是很正常的，这是参数决定了整个程序的运行方式。从概念上讲，这与在Python中函数参数的使用方式类似。这些命令行参数在Python程序中显示为`sys`模块中的一个特殊名称。这个名称是`argv`。它初看起来不是非常有意义，但需要重点了解它，因为各个平台和语言都使用它。

`argv`是`argument vector`的缩写。在程序语言lingo中，`argument`是`parameter`的另外一个名称。当在命令行中运行事参数的程序时，`argument`指命令行下函数的参数（命令行中参数的另外一个名称是`flags`）。`vector`是选项列表的别称。在某些语言中，它有一个特定的与众不同的含义，但Python不区分它们，所以不必担心。

根据这些定义理解`argv`，可看出它的意思就是像列表那样访问的命令行参数。将argv`转换成英语（或者任何其他非程序语言）中简短易理解的有意义的词非常困难，因此词`argv`被一直保留下来。

为了从命令行中输出参数，只需像使用其他列表那样使用`sys.argv`:
``` python
 >>> import sys
 >>> print("This was given the command line parameters: %s" % sys.argv)
```
为了在其他平台上执行相同的过程，需要从代码编辑器中启动。选择`File|Run Options`，并在`Other argv`域中输入希望的参数。前面从第5章开始也用过这个功能，但是使用`Run Options`对话框设置启动程序时的命令行，这很新奇。

为了测试不断变化、并且不以交互式方式使用的程序，一般来说最好使用`python -i`或者`Run with Interpreter`，这样就可以尝试从头开始重复运行程序。图7-2显示了一个列出了可选命令行选项的弹出窗口。
!(图7-2)[]

@(试一试）[打印`sys.argv`]

任何时刻使用`File`菜单的`Run with Interpreter`选项运行程序，都可得到以列表形式输出的`sys.argv`。例如，如果在`Other argv`中提供的命令行参数是“test 123 test”，程序将打印如下信息（这是Windows系统上的运行结果，UNIX Shell下的`sys.path`看起来完全不同）：
``` python
 This was given the command line parameters: ['D:\\Documents\\Chapter7.py', 'test', '123', 'test']

** 示例说明 **

`sys.argv`列表的第一个元素永远都是程序的名称，其他元素都是`sys.argv`列表的元素，从位置`1`开始。

模块中的类的访问方式与其他任何名称的访问方式相同。对于提供了类的模块，其调用与预期一样，即在拼写出的完整路径后加上圆括号，例如调用`Foods.Recipe()`。

##### 7.1.4 改变导入方式

`Import`可以单独使用，此时它会创建一个命名的作用域，模块中的所有内容都可以从该作用域引用。有时，将模块的特定部分引入到程序顶层的全局作用域很有用。这样，在访问函数或者类之前将不必输入模块名称，从而可以减少输入量并使用代码变得直接易读。利用于面的代码和`Foods`模块可创建一个洋葱煎蛋卷对象：
``` pyhton
 import Foods
 r = Foods.Recipe()
 onion_ingredients = Foods.Omelet(r, "onion")
```
该示例表明，希望调用或者访问模块中的某方法时，要拼写出完整的路径。您很快就会感到厌烦。然而，将`from`修饰符用于`import`命令，可以使用名称与代码更接近：
``` python
 from Foods import Omelet
 from Foods import Recipe
 r = Recipe()
 onion_ingredients = Omelet(r, "onion")
```
如果必须深入多个级别，例如（制成的食物）`Foods.Recipes.Breads.Muffins.Bran`，并且要在当前作用域直接使用`Bran`中的名称，需要写类似的代码，如下所示：
``` python
 from Foods.Recipes.Breads.Muffins import Bran
```

#### 7.2 包

在单独的文件中创建一个模块后，该单独的文件经常会陷入组织问题。主要问题是，单独的类在单独使用时更有用，它比模块中其余的类有更多代码。这也是将它移动单独的文件中的好理由，但这会毁坏使用该模块的代码！然而，有一个解决办法。

为了解决上述问题，Python提供了包。包使用与操作系统中类似的目录（也叫做文件夹）结构，使用得同一目录下的文件在一起使用时就像单独的模块。

可以从简单地创建目录开始。将`Foods`模块分解。首先，需要使用一个新名称，因为`Foods.py`已经存在，如果继续使用“Foods”会引起困惑。因此，首先创建一个新包`Kitchen`（这个名称足够通用，为日后使用留下了足够的空间）。

创建`Kitchen`目录，并在其中创建`__init__.py`文件（这个名称必须与类中该方法的名称相同，并且名称前后各有两个下划线）。该文件提示Python这是个包目录，而不仅是包含Python文件的普通目录。这很重要，因为它确保开发人员知道要维护目录和控制它的行为。`__init__`文件包含了控制包的用法的代码，因为与模块不同，当导入包时，目录中的每个文件并没有立即导入。相反，`__init__.py`文件首先被计算，它指定了要使用的文件以及使用它们的方式。

@(试一试)[在`kitchen`包中创建文件]

为了将已经编写的3个类作为`Kitchen`包的一部分，在`Kitchen`目录下创建4个文件，将相应的类放到每个文件中，并以类的名称命名文件。记住，在`Windows`所有版本下，应当将看到的斜杠（`/`）替换为一个反斜杠（`\`），因为`Windows`用它分隔目录。换言之，在`Kitchen`目录中创建文件`Kitchen/Fridge.py`，并仅将`Fridge`类放到该文件中。

为每个类创建一个文件，并创建`__init__.py`文件：

* `Kitchen/Fridge.py`：该文件包含`ch6.py`中从`Fridge`类的声明处开始的，`Fridge`类的所有代码和注释。
* `Kitchen/Omelet.py`：该文件包含`Omelet`类的所有代码和注释。使用在第6章的习题中修改后的`Omelet`类。
* `Kitchen/Recipe.py`：该文件包含`Recipe`类的所有代码和注释。
* `Kitchen/__init__.py`（记住在文件名前后各有两个下划线）：本文件是空的。

** 示例说明 **

现在，除了为每个类创建了文件，还创建了一个`__init__.py`文件，可以导入`Kitchen`包了。然而，导入`Kitchen`后，Python只计算`__init__.py`。这是个非常重要的细节，因为如果没有在`__init__.py`中放置代码，就将永远看不到代码。目前，没有导入任何东西，您默认地导入了`Kitchen`。

导入`Kitchen`后，为了使所有类可用，需要将显式的`import`语句放入`__init__.py`文件：
``` python
 from Fridge import Fridge
 from Recipe import Recipe
 from Omelet import Omelet
```
向`__init__.py`加入这些行后，导入`Kitchen`包后这些类都变得可用：
``` python
 >>> import Kitchen
 >>> r = Kitchen.Recipe()
 >>> r.recipes
 {'cheese':{'cheese':1, 'eggs':2, 'milk':1}, 'onion':
 {'cheese':1, 'eggs':2, 'milk':1, 'onion':1}, 'mushroom':
 {'cheese':1, 'eggs':2, 'milk':1, 'mushroom':2}}
```
此外，它还没有带来很多好处，因为这只是一个非常小的项目，但是对于逐渐增长的项目，这个工具非常重要，它使得多个开发人员共同进行开发变得容易，通过将函数和类自然地分配到多个文件中，每个程序员可以在自己那组文件上工作。

#### 7.3 模块和包

现在已经定义了模块和包，接下来将介绍如何使用它们。模块和包一般可以交换使用，对于两者在行为上存在区别的地方，后面的内容会选择另指出。因为模块被命名为`Foods`，包被命名为`Kitchen`，所以在处理的是包的代码还是模块折代码方面您不会感到困惑。记住：`Kitchen`是包，`Foods`是模块。

##### 7.3.1 将所有内容引入当前作用域

注意模块的一个特性：有时需要不用显式地指定模块中每个可用的名称而使用模块的所有内容。为此，Python提供了一个特殊字符`*`，它用于`from ... import ...`语句。记住，在导入到全局作用域时，只能使用`*`进行导入，理解这一点很重要：
``` python
 From Foods import *
```
这将`Omelet`类以及`recipe`模块顶层的所有类都引入到当前作用域中，现在不必再输入`Foods.Omelet()`，仅需输入`Omelet()`，并且仅需输入一次，而不是每次在需要将某个名称变为局部名称时都要输入。

包与模块的工作方式类似，但它们内部的工作方式不同。对于包，当使用`from ... import *`时，需要显式指定希望得到的名称。在`__init__.py`文件中使用`__all__`列表可使`Kitchen`包中的3个模块变得可用。出现在`__all__`列表中的所有名称也仅有这些名称可通过`*`导出。

`__all__`列表中出现的元素可以是函数、类的名称或数据，它们都可以通过`import *`被自动导入到程序的全局作用域。

模块和类的使用者在程序中会自动使用`from ... import *`语法。为了能够处理包，必须指定一个要导出的名称列表。然而，如果模块较大，也可以在模块文件的顶部创建`__all__`列表，它将像在包中那样把名称限制在模块中。

@(试一试)[从包中导出模块]

由于`from ... import *`的经常使用，`__all__`列表才得以存在。您半首先使用、然后再编写包含很多层、函数、数据名称以及单独模块的包，用户看不见这些内容，因为它们不是公共接口的一部分。需要非常小心，避免给用户提供许多他们不需要的内容，`__all__`列表会强迫您确定接口的内容。
``` python
 __all__ = ['Fridge', 'Recipe', 'Omelet']
```

** 示例说明 **

使用语句`from Kitchen import *`后，这些名称将进入程序的全局作用域。了解这点非常重要。如果`__init__.py`文件如下所示：
``` python
 from Fridge import Fridge
 from Omelet import Omelet
 __all__ = ['Omelet', 'Recipe', 'Fridge']
```
如果删除`from Recipe import Recipe`语句，那么调用`from Ketchen import *`之后，需要调用`Recipe.Recipe()`创建一个新的食谱类。

##### 7.3.2 重新导入模块和包

编程是一个试验并改正错误的过程。在交互式的Shell中，您经常意识到已经在模块中犯了一个错误。因为在加载问题模块前，为了正确地设置Shell，您也许输入了大量的代码，所以您希望能够修复问题模块并让Python重新加载它，这样可以不用再次设置会话。目前还没介绍这种方法，但是可以实现这个操作。

第一件需要了解的事情是，多个模块共享一个公共模块，并且多次在同一个程序中调用它是很正常的现象。在这种情况中，为了不必每次花额外的时间重新加载、重新计算、重新编译该模块（见“编译和`.pyc`文件”部分），Python将模块的名称以及模块的来源都隐藏在一个特殊的`sys.modules`下，该`sys.modules`包含了目前已经导入的全部模块。实际上，从代码编辑器中使用Python Shell时，它已经加载了`sys`以及其他许多模块，因此，每次调用Python Shell时，这些模块已经被加载！

** 编译和.pyc文件`

看看已经处理过的`ch5.py`文件、`ch6.py`文件或者其他的Python文件，可以注意到在运行它们之后，会出现一个名称几乎一样的新文件，唯一不同之处是这个新文件的名称以`.pyc`为后缀。这是Python输出的一个特殊文件，它包含了某种形式的代码，这些代码比纯文本源代码更易于快速地加载和运行。如果对`.py`文件做了修改，下次调用它时（通过双击它，或者运行`python -i`，或者在代码编辑器使用`Run`或`Run with Interpreter`菜单选项），Python将根据更新过的源代码重新创建`.pyc`文件。

@(试一试)[检查`sys.modules`]

查看`sys.modules.keys`返回的列表，可以看到已加载过的每个模块的名称。即使在代码编辑器以外启动了一个Python Shell，在导入`sys`后，通过查看`sys.modules`，可以发现系统在您不知情的情况下已经加载了许多模块。每个操作系统和不同Python版本的`sys.moudles`字典的确切内容稍有不同，但它通常与下面的内容类似：

``` python
 >>> list(sys.modules.keys())
 ['builtins', 'sys', '_frozen_importlib', '_imp', '_warnings', '_thread', '_weakref', '_frozen_importlib_external', '_io', 'marshal', 'posix', 'zipimport', 'encodings', 'codecs', '_codecs', 'encodings.aliases', 'encodings.utf_8', '_signal', '__main__', 'encodings.latin_1', 'io', 'abc', '_weakrefset', 'site', 'os', 'errno', 'stat', '_stat', 'posixpath', 'genericpath', 'os.path', '_collections_abc', '_sitebuiltins', 'sysconfig', '_sysconfigdata_m_darwin_darwin', '_osx_support', 're', 'enum', 'types', 'functools', '_functools', 'collections', 'operator', '_operator', 'keyword', 'heapq', '_heapq', 'itertools', 'reprlib', '_collections', 'weakref', 'collections.abc', 'sre_compile', '_sre', 'sre_parse', 'sre_constants', '_locale', 'copyreg', '_bootlocale', 'importlib', 'importlib._bootstrap', 'importlib._bootstrap_external', 'warnings', 'importlib.util', 'importlib.abc', 'importlib.machinery', 'contextlib', 'mpl_toolkits', 'readline', 'atexit', 'rlcompleter']
```
** 示例说明 **
依赖于具体的操作系统，当调用`sys.modules`字典时，它将显示已调用过的所有模块。对于显示结果中没有显式地导入的模块，可以认为Python自动调用了它们，用来处理操作系统或者Python不要求您直接处理的任务。前面的示例来自于Mac OS X系统，许多具体的操作显然与操作系统相关（例如`posix`和`posixpath`，如果您用过UNIX就会了解），而其他模块则不然。

可以利用这个机会查看与感兴趣的任何键所关联的值。可以看到一些模块被列作内置模块，一些被列作来自于文件，对于后者，模块文件的完整路径都列在了模块提供的信息中。不必担心Python Shell中显示的模块列表与前面的示例显示的模块列表不同。在加载了`Foods`模块后，它将出现在`sys.moudles`字典中，此后，即使改变了`Foods.py`，Python也不再重新计算它。为了在交互式会话中修复这个问题，可以简单地将`Foods`模块从`sys.modules`字典中移除，然后再次导入它。由于Python在`sys.modules`中不再有该记录，它会按照您要求的方式工作，而不是采用像删除它的引用之前那样的方式工作：
``` python
 >>> import Kitchen
 >>> 'kitchen' in sys.modules
 True
 >>> sys.moudles['Kitchen']
 <module 'Kitchen' from 'Kitchen\__init__.py'>
 >>> sys.modules.pop('Kitchen')
 <module 'Kitchen' from 'Kitchen\__init__.py'>
 >>> sys.modules['Kitchen']
 Trackback (most recent call last):
   File "<input>", line 1, in ?
 KeyError: 'Kitchen'
```
现在知道了`sys.modules`的底层工作方式，还需要知道有一个简单的方法可以完成相同的功能。Python提供了一个内置函数`reload`，它重新加载指定的模块，效果与刚才手动重新加载它一样：
``` python
 import Kitchen
 reload(Kitchen)
 <moudle 'Kitchen' from 'Kitchen\__init__.pyc'>
```
注意，这不会影响已经存在的对象。即使您已经在刚才加载的模块里做了修改，它们仍旧有可能关联到旧的定义。如果更改了`Recipe`和`Omelet`类，需要重新调用这两个类，并重新创建它们的对象，对象的初始化如下所示：
``` python
 >>> r = Omelet.Recipe()
 >>> o = Omelet.Omelet(r, 'onion')
```
#### 7.4 测试模块和包的基础知识

为模块创建的作用域有一个有趣的用法。程序中有一个特殊名称`__name__`，可以告诉您正在运行的作用域的名称。例如，如果在`Foods`模块中检查`__name__`值，它返回字符串“Foods”。

`__name__`是一个特殊的保留字，它是顶层全局作用域的名称。如果有一个从来不被直接使用的模块，可以在其尾部粘贴一些代码，这些代码只有一个用途，即验证该模块可否正常工作。这使得对它的测试变得简单。

经常可以看到模块的尾部有如下代码：

``` python
 if __name__ == '__name__'
```
可以在自己的模块的尾部使用这个语句；从此刻起，可以测试类是否已经创建，函数是否返回了期望的值，或者执行其他任何您可以想到的测试。在程序中，之前能够正常工作的代码突然崩溃是很常见的。在包中测试是否出现这种情况是个好主意，这样将不再忘记会发生这种情况，从而掌握主动权。第12章中将介绍更多有关测试的知识。

#### 7.5 本章小结

前面的章节介绍了如何在交互的Python Shell中编写代码，以及将代码放到可以运行的单个文件中。本章介绍了如何将程序组织成模块和包。

Python利用模块为局部名称保留一个作用域。模块内部的名称可被直接使用。然而，要在一个特定模块的外部（例如，名称实际上是`__main__`的全局作用域中）访问模块内的名称，首先需要指定模块名称，之后跟着一个句点，再后面是希望访问的名称。例如`sys.path`。通过使用这种方式，可以在不同模块中将相同的名称用于不同的目的，而不会引起混乱。

为了使用一个模块，必须用`import`语句将它导入到程序中。`import`将找到具体有指定名称的模块文件，其扩展名为`.py`，并使它可用。Python检查`sys.path`列表中的每个目录，直到找到该文件为止。

通常希望在不必输入完整路径的情况下，使用某个模块的特定部分。完整的路径以模块名称开始，后面跟着任何中间模块的名称（用句点分隔），最后是实际需要的名称。此处，可以用`from ... import ...`导入频繁使用的名称。导入一个模块后，模块中不在任何函数或者类中出现的代码将被求值。

当要编写的代码量较大时，可以用包将代码组织起来，操作系统的文件系统提供了该功能。包结构以目录开始，将包导入程序后，该目录的名称就是包的名称。`__init__.py`文件将普通的目录变为包。需要读`__init__.py`文件并对它解析，该文件包含对整个包有用的代码，例如包的所有部分共享的数据、版本信息和重要文件的存储位置等，文件中还包含必要的`import`语句，这些语句使包的其他部分能够正常工作。

当程序员用语句`from ... import *`请求一个包时，包中的文件不会被自动导出，即使这些文件已经在`__init__.py`中被导入。应该在列表`__all__`中指定包中需要默认导出的名称。

** 本章要点： **

* 使用`import`关键字导入模块。
* `argv`是`argument vector`的缩写，它代表命令行参数。这些参数可以当作一个列表通过`sys.argv`访问。
* 每个操作系统都使用目录结构，包也使用目录结构，同一目录下的所有文件一起使用时，就像一个单独的模块。
* 使用语句`from modulename import *`，其中`modulename`是模块的名称，可以导入一个模块的全部内容。

#### 7.6 习题

可心将代码直接移到模块和包中，而不必做出修改，这是Python比较好用之处。
本章的习题重点在于测试模块，因为测试实际上就是为自动化任务编写小程序。
1. 为`Foods.Recipe`模块写测试，创建包含一组食物的`recipe`对象，并且验证提供给它的键与值都存在并且匹配。直接调用`Recipe.py`时运行该测试，而不是在导入它时运行测试。
2. 测试`Foods.Fridge`模块，向`Fridge`类添加食物，因为`get_ingredients`需要一个`Omelet`对象，练习使用除了`get_ingredients`之外的所有接口。
3. 对这些测试进行试验。从命令行直接运行它们。如果正确输入了测试代码，不应当出现错误。试着引入错误，以查看在测试中得到的错误消息。

### 第8章 文件和目录

本章将介绍Python中用来读写文件以及访问目录内容的函数和类型。这些函数很重要，因为几乎所有比较大的程序都用文件来读取输入或存储输出。

Python提供了丰富的输入/输出函数，本章将介绍其中使用广泛的那些函数。首先介绍文件对象，它是Python中实现输入输出的基本方法。之后将介绍用于操作路径、获取文件信息和访问目录内容的函数。

** 本章将介绍 **

* Python中用于读写文件以及访问目录内容的类型和函数。这些函数很重要，因为几乎所有比较大的程序都用文件来读取输入或存储输出。
* Python丰富的输入/输出函数，本章将介绍其中使用最广泛的那些函数。
* Python中实现最基本的输入/输出的文件对象。
* 操作路径、获取文件信息和访问目录内容的函数。

#### 8.1 文件对象

本章中的大部分示例使用Windows路径名称。如果您在其他平台上工作，用您的系统中的路径替换示例中的路径。

如果恰好使用Windows，要记住反斜杠在Python字符串中是一个特殊字符，因此必须在路径中对反斜杠转义（即每次用两个反斜杠）。例如，路径`C:\Windows\Temp`用Python字符串`"C:\\Windows\\Temp"`代替。还可以通过在开头的引号前放置字母`r`，取消字符串中对反斜杠的特殊处理，因此同样的路径可以写作`r"C:\Windows\Temp"`。

我们将使用字符串对象来存储创建和访问的示例文件的路径。如果使用`Windows`，输入如下代码（可以选择希望使用的任意路径）：
``` python
 >>> path = "C:\\sample.txt"
```
如果使用Linux，请输入下面的代码（或者自己选择一个路径）：
``` python
 >>> path = "/tmp/sample.txt"
```

##### 8.1.1 编写文本文件

下面从创建简单的文本文件开始介绍。要在系统上创建一个新文件，创建一个`file`对象，告诉Python希望向文件中写数据。`file`对象代表对一个文件的连接，而不是文件本身，但是如果试图打开或者向一个不存在的文件写数据，Python将自动创建该文件。输入如下代码：
``` python
 >>> def make_text_file():
     a = open('test.txt', "w")
     a.write("This is how you create a new text file")
     a.close()
```
可以从创建一个新的`make_text_file()`函数开始。告诉Python打开一个名为`test.txt`的文件。由于Python找不到该文件，就会创建该文件（注意，如果该文件存在，Python会删除它并创建一个新文件，因此要小心使用这项技术！后面将学习如何在创建一个文件之前检查它是否已经存在）。“`W`”参数告诉Python打算向文件中写数据，如果没有指定该参数，Python认为您打算从文件中读数据，若文件不存在，它将抛出异常。接下来，向文件中添加一行文件：“This is how you create a new text file”。

花点时间浏览Python安装目录，它应该类似于“`C://Python31`”。可以注意到一个新的`test.txt`的文件已经被创建。如果双击它，可以看到文件中已存在上面的示例中向其添加的文本。恭喜，您已经创建了第一个文件！

现在已经使用上面的技术创建了一个文件，接下来创建一个程序，首先检查某个文件是否已经存在。如果存在，将返回一个错误消息；如果不存在，程序将创建文件。输入下面的代码：
``` python
 >>> import os
 >>> def make_another_file():
         if os.path.isfile('test.txt'):
             print("You are trying to create a file that already exists!")
         else:
             f = open('test.txt', "w")
             f.write("This is how you create a new text file")
         ...
 >>> make_another_file()
 "You are trying to create a file that already exists!"
```
打开一个文件时，利用本章讨论的其他文件处理函数，可以指定一个相对路径（相对于当前目录的路径，当前目录是指程序或者Python正在运行的地方）或者一个绝对路径（以磁盘或者文件系统的根目录开始的路径）。例如，`/tmp/sample.txt`是一个绝对路径，而`sample.txt`由于没有指定上层目录，是相对路径。

##### 8.1.2 向文件中追加文本

向文件中追加文本很容易实现。追加文本不是用参数（“`w`”）实现的，而是用追加参数（“`a`”）。这样可以保证文件中已有的数据不被重写，而是将新文本追加到文件末尾。尝试下面的代码：

@(试一试)[向文件中追加文件]

``` python
 >>> def add_some_text():
     a = open('test.txt', "a")
     a.write("Here is some additional text!")
 ...
 >>> add_some_text()
```

** 示例说明 **
该示例创建了一个叫做`add_some_text()`的函数。之后使用`open()`方法打开文件`test.txt`，告诉Python希望向文件中追加文件（使用参数“`a`”）。接下来，向文件中写入新文本。稍后调用该函数时，它增加一行文本“Here is some additional text!”

可以到Python的安装目录打开`test.txt`文件查看结果。应当会看到新的文本被添加到了文件的末尾。

注意，`write`函数不会自动写换行符，任何时候想向文件中增加换行符时，必须使用转义序列`\n`。空格也一样。如果不自己添加空格、制表符或换行符，下一次向文件中添加的文本会紧跟在已有文本之后。

如果再次使用`write`，新的文本又被追加到之前写的文本之后。如果传递的字符串超过一行，将有多行文本被添加到文件中：
``` python
 >>> def even_more_text():
 a = open('test.txt', "a")
 a.write("""
 here is
 more
 text""")
 ...
 >>> even_more_text()
```
此处使用了一个多行的、三引号的字符串。直到使用结束三引号，Python会一直用“...”提示继续输入当前字符串。Python在行之间加入了换行符。再次打开`test.txt`文件，看看有什么变化。

##### 8.1.3 读文本文件

读文件是类似的。首先，通过创建一个`file`对象打开文件。这一次，使用“`r`”告诉Python打算读文件。“`r`”是默认参数，可以省略。
``` python
 a = open("test.txt", "r")
```
确保使用了前面创建的路径，或者使用希望读的某个文件的路径。如果文件不存在，Python将招聘一个异常。

可以使用`readline`方法从文件中读出一行文件。当在一个文件对象上第一次调用该方法时，它将返回该文件的第一行文本：
``` python
 >>> a.readline()
 'This is how you create a new text file\n'
```
注意，`readline`返回的字符串末尾是换行符。若要逐行读取文件内容，可重复调用`readline`方法。

还可以使用`read`方法一次性地读取文件中的剩余内容。该方法返回文件中未读取的所有内容（如果在一条形文件时就调用`read`，它将该文件的完整内容作为一个长字符串返回）。
``` python
 >>> f = open("test.txt", "r")
 >>> text = a.read()
 >>> print(text)
 This is how you create a new text file
 Here is some additinal text
 here is
 more
 text
```
因为使用了`print`打印文本，Python将换行符看做真正的换行符，而不是`\n`。
当完成操作时，删除文件对象并关闭文件。
``` python
 >>> del a
 >>> a.close()
```
让Python将一个文本文件分解为多行是很方便的，但是如果一次可以得到所有的行会更好，例如，这样就可以将其用在一个循环中。`readline`方法可以实现这个目的：它将文件的剩余内容作为一个字符串列表返回。如果希望打印文件中每一行的长度，可以使用下面的代码：
``` python
 def print_line_lengths():
     a = open("test.txt", "r")
     text = a.readlines()
     for line in text:
         print(len(line))
```

@(试一试)[打印示例文件中行的长度]

使用函数`print_line_lengths`，可以检查刚才创建的文件，并显示每一行的长度：
``` python
 >>> print_line_lengths()
 38
 28
 7
 4
 4
```

** 示例说明 **

每一行作为一个字符串读入。在读入一行时，将读入的字符串作为`len`函数的参数可以显示该行的长度。记住，每一行都包含换行符，因此看起来为空的行的长度为1。

##### 8.1.4 文件异常

因为Python程序对计算机的文件系统没有独占控制，在访问文件时它必须能够处理预料之外的错误。当Python在执行文件操作并遇到问题时，它将招聘一个`IOError`异常（异常在第4章中介绍）。该异常的字符串表示将描述遇到问题。

有许多情况都会引起`IOError`错误，包括：

+ 试图打开并读取一个不存在的文件。
+ 试图在一个不存在的目录中创建文件。
+ 试图打开一个没有读访问权限的文件。
+ 试图在一个没有写访问权限的目录下创建文件。
+ 计算机遇到磁盘错误（或者网络错误，如果在访问一个网络磁盘上的文件）。

如果希望在错误发生时程序能够优雅地做出反应，必须能够处理这些异常。在接收到一个异常时采取什么操作取决于程序的行为。某些情形下，在打印了一个警告消息之后，也许希望尝试另一个文件。在另外的情形下，也许必须询问用户接下来想做什么，或者如果错误不能恢复，就直接退出程序。

#### 8.2 路径和目录

Windows、Linux、UNIX和Mac OS/X上的文件系统有许多共同点，但是它们的某些规则、约定和功能略有不同。例如，Windows使用反斜杠将一个路径中的目录名称分隔开，而Linux和UNIX（Mac OS/X是UNIX的一种）使用正斜杠。除此之外，Windows使用驱动器名称，而其他系统则不用。这些不同之处是编写跨平台程序的障碍。Python将路径和目录操作的繁琐细节隐藏在`os`模块中，以方便程序员使用。然而，使用`os`并不能解决所有移植问题，`os`模块中的一些函数并不是在所有平台上都可用。本小节仅描述在所有平台上都可用的函数。

即使打算仅在一个平台上使用程序，并且预计能够避免大多数这样的问题，但如果程序很有用，很可能某一天有人会在其他平台上尝试运行该程序。因此最好使用`os`模块，它提供了许多有用的服务。不要忘记首先要导入`os`，然后再使用它。

#### 8.3 OS中的异常

`os`模块中的函数在失败时会抛出`OSError`异常。如果希望程序在出错时行为友好，那么必须处理这个异常。与`IOError`一样，异常字符串表示描述了遇到的问题。

##### 8.3.1 路径

模块`os`包含另外一个模块`os.path`，它提供了操作路径的函数。由于路径也是字符串，因此可以使用普通的字符串操作方法组合和分解文件路径。但是如果这样，代码可能不易移值，也不能处理`os.path`知道的一些特殊情形。使用`os.path`操作路径，可使程序易于移植，且可以处理一些特殊情形。

使用`os.path.join`可将目录名称组合成路径。Python使用适合操作系统的路径分隔符。在使用之前不要忘记导入`os.path`模块。例如，在Windows系统上，输入如下代码：
``` python
 >>> import os.path
 >>> os.path.join("sankes", "Python")
 'sankes\\Python'
```
在Linux系统上，在`os.path.join`中使用相同的参数会得到如下不同的结果：
``` python
 >>> import os.path
 >>> os.path.join("snakes", "Python")
 'sankes/Python'
```
函数`os.path.split`具有相反的功能，它将路径的最后一个组件提取出来。该函数返回包含两个项的元组：父目录的路径以及最后一个路径组件。这里有一个示例：
``` python
 >>> os.path.split("C:\\Program Files\\Python30\\Lib")
 ('C:\\Program Files\\Python30', 'Lib')
```
在UNIX或者Liunx系统上的结果如下：
``` python
 >>> os.path.split("/usr/bin/python")
 ('/usr/bin', 'python')
```
自动分解序列在这里派上了用场。`os.path.split`返回一个元组，该元组可分成几个部分，分别赋予等号左边的组件：
``` python
 >>> parent_path, name = os.path.split("C:\\Program Files\\Python30\\Lib")
 >>> print(parent_path)
 C:\Program Files\Python30
 >>> print(name)
 Lib
```
尽管`os.path.split`仅将路径的最后部分分离开，但是有时候也许希望将一个路径完全分解为若干目录的名称。写一个这样的函数并不困难，只需对该路径调用`os.path.split`，之后在父目录的路径上再次调用`os.path.split`，依此类推，直到得到根目录。实现该功能的一种得体的方式是使用递归函数，即自己调用自己的函数。它的形式如下：
``` python
 def split_fully(path):
     parent_path, name = os.path.split(path)
     if name == "":
         return (parent_path, )
     else:
         return split_fully(parent_path) + (name, )
```
最关键的一行是最后一行，此处函数调用自己将父目录分解成各个组件。路径的最后一个组件`name`被添加到完全分解的父路径后面。`split_fully`中间的行阻止函数无限将地调用自己。当`os.path.split`不能继续分解一个路径时，它返回的第二个组件为空，`split_fully`注意到这一点并只返回父路径，而不再调用自身。

函数可以安全地调用自身，因为Python记录了函数每一个运行实例的参数和局部变量，即使运行实例是从另一个运行实例中调用的。 在这种情形下，当`split_fully`调用自身时，即使内部（第二个）实例给`name`赋予了一个不同的值，外部（第一个）实例也不会丢失`name`的值，因为每个函数运行实例都有自己的变量`name`的副本。当内部实例返回后，外部实例继续使用它在进行递归调用时拥有的该变量的值。

编写递归函数时，要确保它不会无限次地调用自身。无限次调用自身是很糟糕的，因为它永远都不会返回结果（实际上，这种情形下，Python会用守记录所有调用的空间，并抛出异常）。函数`split_fully`不会无限次调用自身，因为最终的`path`会足够短，并且`name`会变成一个空字符串，此时该函数不会再调用自身，而是直接返回。

该函数中有两处使用单个元素的元组，注意必须在圆括号中包含一个逗号，没有逗号，Python会将圆括号解释为普通的分组圆括号，就像在在数学表达式中那样：`(name,)`是一个包含单个元素的元组，但`(name)`与`name`完全相同。

这里有一个可以运行的函数：
``` python
 >>> split_fully("C:\\Program Files\\Python31\\Lib")
 ('C:\\', 'Program Files', 'Python31', 'Lib')
```
当有一个文件名称时，可以用`os.path.splitext`分解出它的扩展名：
``` python
 >>> os.path.splitext("image.jpg")
 ('image', '.jpg')
```
对`splitext`的调用返回一个包含两个元素的元组，因此可以用上面的方式提取出扩展名：
``` python
 >>> parts = os.path.splitext("image.jpg")
 >>> extension = parts[1]
```
实际上，并不需要变量`parts`。可以从`splitext`的返回值直接提取出第二个组件`extension`：
``` python
 >>> extension = os.path.splitext("image.jpg")[1]
```

`os.path.normpath`也能派上用场，它可以规范化或“清理”路径：
``` python
 >>> print(os.path.normpath(r"C:\\Program Files\Perl\..\Python30"))
 C:\Program Files\Python30
```
注意如何通过备份目录组件去掉“`..`”，以及如何修复双分隔符。函数`os.path.abspath`与`os.path.normpath`类似，它将一个相对路径（相对于当前目录的路径）转变为一个绝对路径（从驱动器或者文件系统的根目录开始）：
``` python
 >>> print(os.path.abspath("other_stuff"))
 C:\Program Files\Path30\other_stuff
```
输出取决于调用`abspath`时的当前路径。您也许已经注意到，即使在Python目录下没有叫做`other_stuff`的文件或者目录存在，这个函数仍然可以正常工作。`os.path`下面的所有路径操作函数都不检查正在操作的路径是否真正存在。

可以使用`os.path.exists`判断某个路径是否实际存在。它仅简单地返回`True`或者`False`：
``` python
 >>> os.path.exists("C:\\Windows")
 True
 >>> os.path.exists("C:\\Windows\\reptiles")
 False
```
当然，如果使用的不是Windows，或者Windows安装在另外一个目录（例如`C:\WinNT`）中，这两个调用者会返回`False`！


##### 8.3.2 目录内容

现在知道如何构造任意路径并且将它们分开。但是如何才能找出硬盘上实际存在哪些内容呢？`os.listdir`模块会返回一个目录下所有名称条目，包括文件和子目录等内容。

@(试一试)[获取目录的内容]

下面的代码将得到一个目录下的条目列表。在Windows系统下，可以列出Python安装目录下的内容：
``` python
 >>> os.listdir("C:\\Python31")
 ['Chapter 5', 'chapter 6', chapter 7', 'DLLs', 'Doc', 'ham', 'include', 'Lib', 'libs', 'LICENSE.txt', 'maybe', 'NEWS.txt', 'python.exe', 'pythonw.exe', 'README.txt', 'tcl', 'Test', 'Test.py', 'test.txt', 'test2.txt', 'test6.txt', 'tester.py', 'test.txt', 'Tools', 'w9xpopen.exe']
```
注意您的结果有可能不同，因为显示的结果取决于目录下的文件。

如果您使用其他的操作系统，或者在另外目录下安装Python，请将示例中的路径替换为其他路径。使用“`.`”可以列出当前目录。当然，如果列出一个不同的目录，将会得到一个不同的名称列表。

无论哪种情况，都应该注意一些重要的事情。首先，返回的结果是目录条目的名称，，而不是完整路径。如果需要某个条目的完整路径，必须使用`os.path.join`构造它。其次，结果中既有文件名称也有目录名称，从`os.listdir`的结果中无法区分两者。最后，注意结果中不包含“`.`”和“`..`”，这两个代表当前目录和其父目录的特殊目录名称。

编写一个函数，列出某个目录中的内容，但是需要打印出完整路径，而不是仅打印文件和子目录的名称，并且要求每行打印一个条目：
``` python
 def print_dir(dir_path):
     for name in os.listdir(dir_path):
         print(os.path.join(dir_path,name))
```
该函数在`os.listdir`返回的列表上循环，并且对每个条目调用`os.path.join`，在打印之前构造完整路径。尝试下面的代码：
``` python
 >>> print_dir("C:\\Python30")
 C:\Python31\DLLs
 C:\Python31\Doc
 C:\Python31\ham
 C:\Python31\include
 C:\Python31\Lib
 C:\Python31\libs
 C:\Python31\LICENSE.txt...
```
以上代码并不能保证`os.listdir`返回的条目列表以某种特定的方式排序，也就是说顺序是任意的。可能希望条目以某种特定顺序排序，以满足应用需求。由于它是字符串列表，因此可以使用`sorted`函数将它排序。

默认情况下，得到的结果按字母表排序，并区分大小写：
``` python
 >>> sorted(os.listdir("C:\\Python31"))
 ['DLLs', 'Doc', 'LICENSE.txt', 'Lib', "NEWS.txt', 'README.txt', 'Removepywin322.exe', 'Scripts', 'Tools', 'include', 'libs', py.ioc', 'pyc.ico', 'pyhton.exe', 'pythonw.exe', 'pywin32-wininst.log', 'tcl', 'w9xpopen.exe']
```
@(试一试)[列出桌面或者主目录的内容]

使用`print_dir_by_ext`列出桌面或者主目录的内容。Windows的桌面是一个文件夹，它的典型路径是`C:\\Documents and Settings\\username\\Desktop`，其中`username`是账户名称。在GUN/Linux或者UNIX上，主目录的典型路径是`/home/username`。这是您期望的输出吗？

##### 8.3.3 获取文件信息

可以很容易地判断出一个路径是指向一个文件还是指向一个目录。如果是指向文件，`os.path.isfile`将返回`True`；如果是指向目录，`os.path,isdir`将返回`True`。如果路径不存在，这两个函数都返回`False`：
``` python
 >>> os.path.isfile("C:\\Windows")
 False
 >>> os.path.isdir("C:\\Windows")
 True
```
** 其他类型的目录条目 **
在某些平台下，一个目录也许包含许多其他类型的条目，例如符号链接、套接字还有设备等。这些类型的条目的具体含义取决于特定的平台，相关内容比较复杂，这里不进行讨论。然而，`os`模块为检查这些条目提供了支持，请查阅模块的文档了解与您的平台有关的细节。

** 递归目录列表 **
可以将`os.path.isdir`和`os.listdir`结合起来实现一些有用的操作：例如，递归地处理子目录。可以列出一个目录的内容，它的子目录，子目录的子目录，依此类推。对于这个目的，编写一个递归函数很有用。当函数找到一个子目录时，它调用自身，列出该子目录的内容：
``` python
 def print_tree(dir_path):
     for name in os.listdir(dir_path):
         full_path = os.path.join(dir_path, name)
         print(full_get)
         if os.path.isdir(full_path):
             print_tree(full_path)
```
注意上央的函数与之前编写的`print_dir`函数很类似。然而，这个函数为每个条目构造了完整路径`full_path`，因为这既符合打印的需求，也考虑到子目录的需求。最后两行代码检查它是否是子目录，如果是，该函数在继续运行之前通过调用自己列出子目录的内容。如果试用该函数，确保没有对一个非常大的目录树调用该函数，否则，不得不等待它打印出树中每一个子目录和文件的完整路径。

模块`os.path`中的其他函数提供了关于文件的信息。例如，`os.path.getsize`在不必打开和扫描某个文件的情况下以字节为单位返回该文件的大小。使用`os.path.getmtime`可以得到文件上次被修改的时间。返回的值是1970年起到文件上次被修改的时间之间的秒数，而这不是用户喜欢的日期的格式。必须调用另外一个函数`time.ctime`，将该结果转换为易于理解的形式（不要忘了首先要导入`time`模块）。这里有一个示例输出了Python安装目录上次被修改的时间，这可能是在计算机上安装Python的日期和时间：
``` python
 >>> import time
 >>> mod_time = os.path.getmtime("C:\\Python30")
 >>> print(time.ctime(mod_time))
 Thu Mar 15 01:36:26 2009
```
现在知道了如何修改`print_dir`来打印目录的内容，包括每个文件的大小和修改时间。为了简单，下面的版本只打印条目名称，而不打印它们的完整路径：
``` python
 def print_dir_info(dir_path):
     for name in os.listdir(dir_path):
         full_path = os.path.join(dir_path, name)
         file_size = os.path.getsize(full_path)
         mod_time = time.ctime(os.path.getmtime(full_path))
         print("%-32s:%8d bytes, modified %s" % (name, file_size, mode_time))
```
最后一条语句使用了第1章和第2章中介绍的Python内置的字符串格式化方法，以产生整洁的对齐的输出。如果希望输出其他文件信息，请浏览`os.path`模块的文档，学习如何获取这些信息。

##### 8.3.4 重命名、移动、复制和删除文件

模块`shutil`中包含了操作文件的函数。可以使用函数`shutil.move`重命名一个文件：
``` python
 >>> import shutil
 >>> shutil.move("server.log", "server.log.backup")
```
或者，可以使用它将一个文件移动到另外一个目录下：
``` python
 >>> shutil.move("old mail.txt", "C:\\data\\archive\\")
```
您也许已经注意到，`os`也包含一个可以重命名和移动文件的函数`os.rename`。一般应当使用`shutil.move`，因为使用`os.rename`可能并不能指定一个目录名称作为目标，而且在某些系统上，`os.rename`不能将一个文件移动到另外一个磁盘或者文件系统中。

`shutil`模块还提供了`copy`函数，它将一个文件复制为具有一个新名称的文件，或者复制到一个新目录下。可以简单地使用如下代码：
``` python
 >>> os.remove("junk.dat")
```
如果您是一位老派的UNIX黑客（或者希望自己冒充成一个黑客），可能更喜欢`os.unlink`，它能完成相同的操作。

** 文件权限 **

文件权限在不同的平台上的工作方式是不同的，解释它们超出了本书的讨论范围。然而，如果需要改变一个文件或者目录的权限，可以使用`os.chmod`函数。它与UNIX或者Linux的系统调用`chmod`的工作方式相同。参考`os`模块的文档了解其细节。

##### 8.3.5 示例：轮换文件
在这个示例中，将处理一个更困难的实际的文件管理任务。假设需要保留一个文件的多个老版本。例如，系统管理员要保留老版本的系统日志文件。通常，文件的老版本的名称有一个数字后缀，例如`web.log.1`、`web.log.2`等，其中较大的数字代表较老的版本。为了给文件的新版本预留空间，这些老版本被轮换：目前的版本`web.log`变成了`web.log.1`，而`web.log.1`则变成了`web.log.2`，依此类推。

手动实现该功能非常乏味，但是Python却可以很快地实现。有几个棘手的问题需要考虑。首先，文件当前版本与老版本的命名方式不同：老版本有一个数字后缀，而当前版本没有。解决这个问题的一个方法是将当前版本的命名方式不同：老版本有一个数字后缀，而当前版本没有。解决穿上问题的一个方法是将当前版本作为版本`0`。函数`make_version_path`为当前版本和老版本构造了正确的路径。

另外一个不易注意的地方是必须确保首先要重命名老版本。例如，如果在重命名`web.log.2`之前将`web.log.1`重命名为`web.log.2`，后者将被重写，它之前的内容就会丢失，这并不是你所希望的。递归函数将再次伸出援手。该函数可以调用它自身，在重写下一个老版本的的日志文件之前轮换它：
``` python
 import os
 import shutil

 def make_version_path(path, version):
     if version == 0:
         # No suffix for version 0, the current version.
         return
     else:
         # Append a suffix to indicate the older version.
         return path + "." + str(version)

 def rotate(path, version=0):
     # Construct the name of the version we're rotating.
     old_path = make_version_path(path, version)
     if not os.path.exists(old_path):
         # It doesn't exist, so complain.
         raise IOError("'%s' doesn't exist" % path)
     # Construct the new version name for this file.
     new_path = name_version_path(path, version + 1)
     # Is there already a version with this name?
     if os.path.exists(new_path):
         # Yes. Rotate it out of the way first!
         rotate(path, version + 1)
     # Now we can rename the version safely.
     shutil.move(old_path, new_path)
```
花几分钟时间研究一下上面的代码和注释。`rotate`函数使用了递归函数通过的技术：第二个参数用于处理递归的情形，在这个示例中，即文件的版本号被轮换。该参数的默认值为`0`，它表示文件的当前版本。当调用该函数时（与函数调用自己的情况不同），不需要指定该参数的值。例如，可以直接调用`rotate("web.log")`。

该函数检查正在被轮换的文件是否确实存在，如果该文件不存在，则引发异常。假设希望轮换一个不确定是否存在的系统日志文件。解决该问题的一种可能方法是在该日志文件不存在时，创建一个空的日志文件。回忆一下，当以写方式打开一个并不存在的文件时，Python会自动创建它。如果没有向新文件中输入内容，它将为空。下面是一个轮换可能存在的日志文件函数，如果不存在，首先要创建日志文件。它使用之前编写的`rotate`函数。

「LatestType Page-146」
##### 8.3.6 创建和删除目录

##### 8.3.7 通配

#### 8.4 本意小结

#### 8.5 习题


### 第9章 Python语言的其他特性

#### 9.1 lambda和filter：简单匿名

#### 9.2 Map：短路循环

#### 9.3 在列表中做出决策——列表解析

#### 9.4 为循环生成迭代器

#### 9.5 使用字典的特殊字符串替换

#### 9.6 重要模块

##### 9.6.1 getopt——从命令行中得到选项

##### 9.6.2 使用一个以上的进程

##### 9.6.3 线程——在相同的进程中完成多个工作

#### 9.7 本意小结

#### 9.8 习题


### 第10章 创建模块

#### 10.1 研究模块

##### 10.1.1 导入模块

##### 10.1.2 查找模块

##### 10.1.3 理解模块

#### 10.2 创建模块和包

#### 10.3 使用类

##### 10.3.1 定义面向对象编程

##### 10.3.2 创建类

##### 10.3.3 扩展已有的类

#### 10.4 完成模块

##### 10.4.1 定义模块特定的错误

##### 10.4.2 选择导出哪些内容

##### 10.4.3 为模块建立文档

##### 10.4.4 测试模块

##### 10.4.5 将模块作为程序运行

#### 10.5 创建一个完整的模块

#### 10.6 安装模块

#### 10.7 本意小结

#### 10.8 习题


### 第11章 文本处理

#### 11.1 文本处理的用途

##### 11.1.1 搜索文件

##### 11.1.2 日志剪辑

##### 11.1.3 邮件筛选

#### 11.2 使用OS模块导航文件系统

#### 11.3 使用正则表达式和re模块

#### 11.4 本意小结

#### 11.5 习题

## 第III部分 开始使用Python

### 第12章 测试

#### 12.1 断言

#### 12.2 测试用例和测试套件

#### 12.3 测试装置

#### 12.4 用极限编程整合

##### 12.4.1 用Python实现搜索实用程序

##### 12.4.2 一个更加强大的Python搜索

#### 12.5 软件生命周期中的正规测试

#### 本意小结

### 第13章 使用Python编写GUI

#### 13.1 Python的GUI编程工具箱

#### 13.2 Tkinter简介

#### 13.3 用Tkinter创建GUI小组件

##### 13.3.1 改变小组件的尺寸

##### 13.3.2 配置小组件选项

##### 13.3.3 使用小组件

##### 13.3.4 创建布局

##### 13.3.5 填充顺序

##### 13.3.6 控制小组件的外观

##### 13.3.7 单选按钮和复选框

##### 13.3.8 对话框

##### 13.3.9 其他小组件类型

#### 13.4 本意小结

#### 13.5 习题

### 第14章 访问数据库

#### 14.1 使用dbm持久字典

##### 14.1.1 选择dbm模块

##### 14.1.2 创建持久字典

##### 14.1.3 访问持久字典

##### 14.1.4 dbm与关系数据库的适用场合

#### 14.2 使用关系数据库

##### 14.2.1 编写SQL语句

##### 14.2.2 定义表

##### 14.2.3 建立数据库

#### 14.3 使用Python的数据库API

##### 14.3.1 下载各个模块

##### 14.3.2 创建连接

##### 14.3.3 使用游标

##### 14.3.4 使用事务并提交结果

##### 14.3.5 检查模块的功能和元数据

##### 14.3.6 处理错误

#### 14.4 本意小结

#### 14.5 习题

### 第15章 使用Python处理XML

#### 15.1 XML的含义

##### 15.1.1 层次标记语言

##### 15.1.2 一组标准

#### 15.2 模式/DTD

##### 15.2.1 文档模型的用途

##### 15.2.2 是否需要文档模型

#### 15.3 文档类型定义

##### 15.3.1 DTD示例

##### 15.3.2 DTD不完全是XML

##### 15.3.3 DTD的局限性

#### 15.4 模式

##### 15.4.1 示例模式

##### 15.4.2 模式是纯粹的XML

##### 15.4.3 模式具有层次

##### 15.4.4 模式的其他优点

#### 15.5 XPath

#### 15.6 HTML是XML的子集

##### 15.6.1 HTML DTD

##### 15.6.2 HTML Parser

#### 15.7 Pathon中可用的XML库

#### 15.8 SAX的含义

##### 15.8.1 基于流

##### 15.8.2 事件驱动

##### 15.8.3 DOM的含义

##### 15.8.4 内存中访问

#### 15.9 使用SAX或者DOM的理由

##### 15.9.1 能力权衡

##### 15.9.2 内存考虑

##### 15.9.3 速度考虑

#### 15.10 Python中可用的SAX和DOM解析器

##### 15.10.1 xml.SAX

##### 15.10.2 xml.dom.minidom

#### 15.11 XSLT简介

##### 15.11.1 XSLT是XML

##### 15.11.2 转换和格式语言

##### 15.11.3 函数式、模板驱动

#### 15.12 lxml简介

#### 15.13 元素类

#### 15.14 使用lxml解析

#### 15.15 本章小结

#### 15.16 习题

### 第16章 网络编程

#### 16.1 理解协议

##### 16.1.1 比较协议和程序语言

##### 16.1.2 Internet协议栈

##### 16.1.3 Internet协议简介

#### 16.2 发送电子邮件

##### 16.2.1 E-mail文件格式

##### 16.2.2 MIME消息

##### 16.2.3 使用SMTP和发送邮件

#### 16.3 检索Internet邮件

##### 16.3.1 使用mailbox解析本地邮筒

##### 16.3.2 使用poplib从POP3服务器获取邮件

##### 16.3.3 使用imaplib从IMAP服务器获取邮件

##### 16.3.4 安全的POP3和IMAP

##### 16.3.5 Webmail应用程序不是E-mail应用程序

#### 16.4 套接字编程

##### 16.4.1 套接字简介

##### 16.4.2 绑定到外部主机名

##### 16.4.3 镜像服务器

##### 16.4.4 镜像客户端

##### 16.4.5 套接字服务器

##### 16.4.6 多线程服务器

##### 16.4.7 Python聊天服务器

##### 16.4.8 设计Python聊天服务器

##### 16.4.9 Python聊天服务器协议

##### 16.4.10 Python聊天客户端

##### 16.4.11 基于select的单线程多任务

#### 16.5 其他主题

##### 16.5.1 协议设计的多种考虑

##### 16.5.2 对等架构

#### 16.6 本意小结

#### 16.7 习题

### 第17章 用C扩展编程

#### 17.1 扩展模块概述

#### 17.2 构建并安装扩展模块

#### 17.3 从Python向C传递参数

#### 17.4 从C向Python返回值

#### 17.5 LAME项目

#### 17.6 LAME扩展模块

#### 17.7 在C代码中使用Python对象

#### 17.8 本意小结

#### 17.9 习题


### 第18章 数值编程

#### 18.1 Python语言中的数值

##### 18.1.1 整数

##### 18.1.2 长整数

##### 18.1.3 浮点数

##### 18.1.4 格式化数值

##### 18.1.5 作为数值的字符

#### 18.2 数学

##### 18.2.1 算术运算

##### 18.2.2 内置数学函数

#### 18.3 复数

#### 18.4 数组

#### 18.5 本意小结

#### 18.6 习题


### 第19章 Diango简介

#### 19.1 框架的定义以及使用框架的理由

#### 19.2 Web框架的其他功能

#### 19.3 Django发展史

#### 19.4 理解Django的架构

##### 19.4.1 项目初始设置

##### 19.4.2 创建视图

#### 19.5 使用模板

#### 19.6 使用模板和视图

##### 19.6.1 模型

##### 19.6.2 创建模型的第一步——配置数据库设置

#### 19.7 创建模型：创建一个应用程序

#### 19.8 本意小结

#### 19.9 习题


### 第20章 Web应用程序与Web服务

#### 20.1 REST：Web架构

##### 20.1.1 REST的特性

##### 20.1.2 Register操作

#### 20.2 HTTP：REST的实际应用

##### 20.2.1 可见的Web服务器

##### 20.2.2 HTTP请求

##### 20.2.3 HTTP响应

#### 20.3 CGI：将脚本变为Web应用程序

##### 20.3.1 Web服务器与CGI脚本的协议

##### 20.3.2 CGI的特殊环境变量

##### 20.3.3 通过HTML表单接收用户输入

#### 20.4 HTML表单的有限词汇

#### 20.5 访问表单值的安全性

#### 20.6 构建wiki

##### 20.6.1 Bitty Wiki核心库

##### 20.6.2 Bitty Wiki的Web接口

#### 20.7 Web服务

#### 20.8 REST Web服务

##### 20.8.1 REST快速入门：在Amazon.com上寻找廉价商品

##### 20.8.2 WishListBargainFinder简介

##### 20.8.3 向Bitty Wiki提供REST API

##### 20.8.4 使用REST Web服务实现搜索和替换功能

#### 20.9 XML-RPC

##### 20.9.1 XML-RPC请求

##### 20.9.2 XML-RPC中的数据表示

##### 20.9.3 XML-RPC响应

##### 20.9.4 错误处理机制

##### 20.9.5 通过XML-RPC展示Bitty Wiki API

##### 20.9.6 基于XML-RPC Web服务的wiki搜索和替换

#### 20.10 SOAP

##### 20.10.1 SOAP快速入门

##### 20.10.2 SOAP请求

##### 20.10.3 SOAP响应

##### 20.10.4 错误处理机制

##### 20.10.5 展示一个Bitty Wiki的SOAP接口

##### 20.10.6 基于SOAP Web服务的wiki搜索和替换

#### 20.11 为Web服务API创建文档

##### 20.11.1 人类可读的API文档

##### 20.11.2 XML-RPC自省API

##### 20.11.3 WSDL

#### 20.12 选择Web服务标准

#### 20.13 Web服务礼仪

##### 20.13.1 Web服务的使用者礼仪

##### 20.13.2 Web服务的创建者礼仪

##### 20.13.3 将Web应用程序作为Web服务使用

#### 20.14 本章小结

#### 20.15 习题


### 第21章 集成Java与Python

#### 21.1 在Java应用程序中编写脚本

#### 21.2 比较各种Python实现

#### 21.3 安装Jython

#### 21.4 运行Jython

##### 21.4.1 交互地运行Jython

##### 21.4.2 运行Jython脚本

##### 21.4.3 控制Jython脚本

##### 21.4.4 创建可执行命令

#### 21.5 独立运行Jython

#### 21.6 打包基于Jython的应用程序

#### 21.7 集成Java和Jython

##### 21.7.1 在Jython中使用Java类

##### 21.7.2 从Jython访问数据库

##### 21.7.3 通过Jython编写Java EE servlet

##### 21.7.4 选择Jython解释器

#### 21.8 使用Jython进行测试

#### 21.9 嵌入Jython解释器

#### 21.10 处理C-Python和Jython之间的差异

#### 21.11 本章小结

#### 21.12 习题


## 第IV部分 附 录

### 附录A 习题答案

### 附录B 在线资源

### 附录C Python 3.1的新特性

### 附录D 术语表


















全文第【86】页


上传图片的免费实用图床网站：
[https://sm.ms](https://sm.ms/)

在Markdown中引用图片的方式的文章：
https://www.jianshu.com/p/c7618a53454f
