# Python编程入门经典

![python log](https://i.loli.net/2019/04/25/5cc162f5430fa.jpg)

## 作者简介
James Payne居住在佛罗里达州马盖特市，他是Developer Shed公司的主编，从7岁起就开始写作和编程。James精通多门语言，已经撰写了400余篇文章，囊括了几乎每一种主流编程语言。James的工作是使用Python为金融业开发专有软件，在业余时间 他喜欢涉猎Django方向的知识。

## 致谢
我感谢在Developer Shed的同事：Jack和Jay Kin持续的敌意使我备受鼓舞；Charles Fagundes使我成为一名编辑，而不仅仅是一个作者；Keith Lee为我提供了编写代码的支持；特别要感谢Jenny Ruggieri，他使我得到了这份工作，所以有了这本书的面世。最后，还要感谢所有为这本书的前期版本付出艰辛劳动的人们，他们的工作是本书的基础。还要感谢编辑Carol Long、Jenny Watson、Ed Connor以及Chris McAvoy，他们帮助我在最终期限前完成本书。

我还想感谢Guido Van Rossum，没有他，也就没有Python语言可写。

## 前言
欢迎使用Python 3.1！
我使用Python已有10年左右，每一个新版本都使我越来越喜欢这门语言。版本3.1也不例外。如果您是Python的初学者，不必担心，我会一路引领着您。相反，如果您是一名希望尝试新版本的Python老手，可以不必在已掌握的知识上浪费时间，而是直接学习所需要的知识，因为本书的结构十分清晰。

之所以写这本书，是因为我热爱Python。我非常 喜爱它！我想和您一起分享我对Python的热爱。您可能也会像我一样越来越喜爱它。

### 本书读者对象
如果您具备计算机知识，并且想学习一门有趣的程序语言来更好地控制计算机，那么本书适合您。

如果您是系统管理员，希望学习一门优秀的语言来更好地管理和配置系统和网络，那么本书适合您。

如果您已经了解Python，但是想知道版本3.1中有哪些很酷的新功能，那么本书适合您。

总之，本书适合于所有热衷于使用功能最丰富且十分易用的最新版本Python 3.1进行编程的诸。

### 本书主要内容
本书主要介绍Python 3.1。Python 3.1发布于2009年，是Python程序语言的最新主版本。由于Python是一门跨平台的语言。本书中的内容和示例适用于任何平台（除非特别指出的例外情况）。在可能独立于平台的情况下，本书中的示例都尽量设计成跨平台的。

此外，由于Python 3.1相对较新，并非所有支持库都被更新到可以在Python 3.x下工作。在这种情形下，如果某些理论需要详细解释，本书将使用Python 2.6代替Python 3.1。

### 本书结构
就像所有入门书籍一样，本书首先对语言进行了介绍。从这里开始，会接触到语言的核心，进而接触到更加高级的专门主题。本书分为如下4个部分。

#### 第I部分——初步了解Python
如标题所示，第I部分让您初步了解Python。

##### 编程基础和字符串
本章首先介绍Python，探讨Python是什么，为什么它如此有用和强大。另外，还探讨Python的开发历史和最新的版本，后者正是本书的讨论重点。您会了解到Python所涉及的范围，以及Python可能参与的应用开发领域。最后，您将开始操作自己的第一种数据类型：字符串。

##### 数值与运算符
本章会介绍数值和运算符的基本知识。您将会学习不同类型的数值，如何执行简单的和复杂的公式，以及如何使用各种运算符。还将学到运算符的优先级以及数值的格式化。

##### 变量
编程语言最终帮助程序员管理不同类型的信息，换言之，就是管理数据。理解数据类型并且知道Python如何表示它们对于Python编程非常必要。本章将帮助您理解在Python中表示不同数据类型的最佳方式。

#### 第II部分——Python语言和标准库
当然，使用一门语言最需要的是了解语言本身，熟悉它的语法和模块。本部分首先介绍数据类型和变量，并逐步介绍其他概念，直到获得开发功能完善的Python程序所需的全部知识。

注意，应该按顺序阅读本部分的章节，因为每一章都建立在前一章的基础之上。

##### 做出决策
最终，程序将需要在某个位置做出决策：是选择这条路径，还是选择另一条路径？如果选择那条路径，将会发生什么？在本章中将学到如何比较数据，例如判断某个值是否比另一个值大，并且将学习如何利用循环来完成重复性的任务。

##### 函数
本章将介绍函数编程，这将帮助您扩展Python知识。函数允许使用者利用强大的概念，例如参数传递和代码重用。本章将介绍如何利用函数使编写的代码更加高效和灵活。

##### 类和对象
本章将介绍对象的概念。您将学习如何定义类和如何在类中创建对象和编写方法，还将学到有关对象作用域的知识。

##### 组织程序
当程序变大时，需要把它们分成单独的几部分。本章将讨论Python模块，并探索包的概念。包并不复杂，它仅是若干模块的集合。

##### 文件和目录
日常编程中一个重要的部分是学习如何处理文件和目录。文章着重介绍通常如何创建、修改和处理文件。另外，还将介绍如何从文件中获得数据，以及如何与各种各样的目录交互。

##### Python语言的其他特性
本章将介绍Python语言提供的其他特征，包括如何使用列表做出决策，如何使用字典进行字符串替换，以及一些有特色的模块。

##### 创建模块
通过允许重用代码片段，模块能够帮助节省时间。它能减少发生错误的机率，因为当前用到的模块可能之前已经被测试和使用过很多次。本章将介绍如何创建自己的模块，以及如何导入并处理已存在的模块，这些已经存在的模块使得Python在应用中功能非常强大。

##### 文本处理
在编程过程中，可以利用文本做很多事情，而且本质上，文本是与用户进行有效沟通的关键。毕竟，如果没有文本，就只能使用图片了。本章将介绍如何用多种方法处理文本，包括利用正则表达式、搜索文件以及搜索特定类型的文件等。

#### 第III部分——开始使用Python
现在您已经知道了Python是什么，以及如何利用这门语言进行工作，接下来应该做什么呢？本部分探究了您会遇到或者想了解的许多编程主题。可以顺序阅读本部分的各章，也可以按其他任意顺序阅读。因为它们是彼此独立的。

##### 测试
在把程序交付给用户之前，对程序进行测试，这是保证它能正常工作的唯一途径。本章不仅会介绍正确测试程序的一些基本概念，还会介绍一些可用的测试工具和测试框架。

##### 使用Python编写GUI
目前为止，本书中的程序都是通过命令行方式工作。本章将介绍GUI编程的概念。您将使用Tkinter创建几个GUI程序，Tkiner是Python程序员最常用的GUI工具包。

##### 访问数据库
数据库存储了程序可以使用的各种信息。它也可以作为存储信息的地方，以便日后可以从中检索出特定任务所需要数据。本章将介绍各种类型的数据库以及如何利用它们进行工作。

##### 使用Python处理XML
XML是处理Internet数据的强大工具。本章将介绍XML的基础知识，包括模式与DTD之间的区别、基本的语法、如何创建和验证XML以及一些高级的主题（例如使用lxml）。

##### 网络编程
Internet已经潜移默化地进入了我们的日常生活，并逐渐变成必需品，而不是一种特权。本章将介绍如何使用程序发送E-mail，以及如何允许用户通过Web进行交流。

##### 用C扩展编程
本章深入介绍如何使用C语言编程，包括如何利用C的框架和模块，C的基础知识，以及如何从Python向C传递参数，并在之后将值返回给Python。

##### 数据编程
本书的开始部分简单介绍了数值，现在是进一步钻研的时候了。本章将深入介绍整形、浮点型、复数和数组的全部知识，以及如何使用内置的数学函数和模块。

##### Django简介
Django是用Python编写的Web应用程序框架，它利用了模型－视图－控制器模式。Django最初被用来管理新闻Web站点，但由于简单易用而变得流行起来，它使得程序员可以用简单的方式创建复杂的Web站点，包括以数据库为中心的Web站点。本章将介绍Django的基础知识。

##### Web应用程序和Web服务
本章将介绍Web应用程序和Web服务的基础知识，例如REST架构，以及如何处理HTTP请求和响应。

##### 集成Java与Python
本章将介绍Java的基础知识，这样可以在研究如何结合Python和Java之前，打好坚实的基础。还将介绍各种帮助在Python中使用Java的模块，以及如何创建简单但有效的应用程序。

#### 第IV部分：附录
本书结尾的附录可以进一步扩展您对Python的了解，激发您对Python的学习兴趣。
* 习题答案
* 在线资源
* Python 3.1的新特性
* 术语表

### 使用本书的条件
使用本书的有一些条件。在此给出下面列出的推荐，因为Python本身可在多种不同的平台上运行。然而，本书的前几章假定您可以使用GUI，例如在Windows、Mac OS X、UNIX和Linux上的X Window等系统上可用的GUI。自然地，一些章节（例如介绍GUI的那一章）也需要GUI，而如果有网络连接，涉及网络的那些章节会更有意义。

下面是建议的最低配置需求：
* 一台PC机，运行Linux、BSD UNIX或Windows系统，频率在500MHz以上；或者运行Mac OS X版本10.2或更新版本的G3或更新的Macintosh。
* 至少256M内存。
* 所用平台具有图形用户界面。
* 对所用计算机有必要的权限，以安装必要的软件。
* 可以访问TCP/IP网络，例如Internet或者校园网。
* 可以通过Internet下载所需软件。

### 源代码
在阅读本书提供的代码时既可以亲自输入所有代码，也可以使用随书提供的代码文件。本书所有代码均可以从[http://www.wrox.com](http://www.wrox.com)（或[http://www.tupwk.com.cn/downpage](http://www.tupwk.com.cn/downpage)）网站下载。进入该网站后，请根据本书的书名查找本书（读者既可以使用搜索框进行查找，也可以使用书名列表进行查找），然后单击本书详细内容页面上提供的Download Code链接，就可以下载本书提供的所有代码。

**注意：**
由于许多书籍名称与本书类似，因此也可以通过ISBN进行查找，本书英文版的ISBN为：978-0--470-41463-7。
下载代码后，可以利用一种压缩工具解压代码。此外，还可以通过访问网站[http://www.wrox.com/dynamic/books/download.aspx](http://www.wrox.com/dynamic/books/download.aspx)中提供的Wrox代码下载页面来获取本书提供的代码，也可以下载Wrox出版的其他书籍提供的代码。

### 勘误表
为了避免本书文字和代码中存在的错误，我们已经竭尽全力。然而，就如世界上不存在完美无缺的事物，本书仍然可能存在错误。如果您在我们编写的书籍中发现了诸如拼写错误或代码缺陷等问题，请告诉我们，我们对些表示感谢。利用勘误表反馈错误信息，可以为其他读者节省大量时间，同时，我们也能够受益于您的帮助，编写出质量更高的专业著作。

如果需要参考本书的勘误表，请在网站[http://www.wrox.com](http://www.wrox.com)中用搜索框或书名列表查找本书书名。然后，在本书的详细内容页面上，单击Book Errata链接。在随后显示的页面中，可以看到与本书相关的所有勘误信息，这些信息是由读者提交、并由Wrox的编辑们加上的。通过访问[www.wrox.com/misc-pages/booklist.shtml](www.wrox.com/misc-pages/booklist.shtml)，还可以看到Wrox出版的所有书籍的勘误表。

如果没有在Book Errata页面上找到自己发现的错误，那么请转到页面[www.wrox.com/contact/techsupport.shtml](www.wrox.com/contact/techsupport.shtml)，针对您所发现的每一项错误填写表格，并将表格发给我们，我们将对表格内容进行认真审查，如果确实是我们书中的错误，那么我们将在该书的Book Errata页面上标明该错误信息，并在该书的后续版本中改正相关错误。

### 关于p2p.wrox.com
如果您希望能够与作者进行讨论，或希望能够参与读者的共同讨论，那么请加入[p2p.wrox.com](p2p.wrox.com)的论坛。这个论坛是一个基于Web的系统，您可以在论坛发表与Wrox出版的书籍有关的技术信息，并与其他读者和技术用户进行讨论。论坛提供了订阅功能，可以将与您所选主题相关的新帖子定期发送到您的电子邮箱。Wrox的作者、编辑、业界专家以及其他读者都会参与论坛中的讨论。

您可以在[http://p2p.wrox.com](http://p2p.wrox.com)参与多个论坛的讨论，这些论坛不仅能够帮助您列好地理解本书，还有助于您更好地开发应用程序。如果希望加入论坛，请按照以下步骤执行：
> (1)进入[http://p2p.wrox.com](http://p2p.wrox.com)页面，单击Register链接。
> (2)阅读使用条款，然后单击Agree。
> (3)填写必要的信息（以及想要提供的可选信息），然后单击Submit。
> (4)随后会收到一封电子邮件，邮件中说明了如何验证账号并完成整个加入过程。

**注意：**
`要阅读论坛信息，无须加入P2P。但是如果需要发表主题或发表回复，那么必须加入论坛。`

成功加入论坛后，就可以发表新主题了。此外，还可以回复其他主题。您在任何时间都可以阅读论坛信息。如果需要论坛将新的信息发送到自己的电子邮箱，那么可以单击论坛列表中论坛名称旁的Subscribe to this Forum图标完成该功能设置。

如果需要获得更多与Wrox P2P相关的信息，请阅读P2P FAQs，这样可以获得大量与P2P和Wrox出版的书籍相关的具体信息。阅读FAQs时，请单击P2P页面上的FAQs链接。

## 第I部分——初步了解Python

### 第1章 编程基础和字符串
本章简单地介绍Python编程实践。Python是一门丰富的语言，包含许多特性，因而学好基础知识是深入学习Python的前提条件。第1章～第3章通过易于理解的段落和简单的示例介绍了常见的编程思想。

对Python感兴趣的有经验的编程人员可以略读本章，并留意其中的示例，直到每3章为止，都可以借助于已有的对其他语言的知识阅读这些章节。

本章将介绍：
* 编程的一些指导原则。
* 关于初步接触程序语言Python的一些说明。
本章末的练习提供了对初步学到的基础知识进行实践的机会。

#### 1.1 编程与使用计算机的区别
编程时第一件需要了解的事情就是控制计算机。有时，计算机并没有按照人们的意愿工作，当它第一次没能如您所愿后，在第二次、第三次仍然会做与第一次相同的事情，直到对它进行修改。

个人计算机发发展已背离了可靠性原则，并朝不可信的软件套软件的方向发展。这就导致人们认为计算机就您一头具有恶意且任性的野兽，当试图让它完成某些事的时候，它会不断地增加人们的额外的工作量并折磨着使用者。然而，学过编程之后，就会知道如何应对这种情况，也许还会发现自己比所有软件的某些编写者还要聪明。

使用Python这种解释型的语言编程，意味着并不需要了解太多的计算机内部细节，如硬件、内存或者长长的0/1串。这时编程就与平常阅读和写作一样，只不过是用一种不同的简单的语言来书写。Python是一门语言，就像所讲的英语或其他语言一样，它对讲同种语言的人而言是有意义的。学习程序语言比学习人类语言甚至更简单，因为化并不是用于讨论、争论、打电话、表演、拍电影以及任何形式的日常交流活动。它们用来制订规则，并确保规则被执行。计算机已被塑造成异常灵活的工具，被广泛地用于人们日常生活中的各种商业活动和任务，但它们依旧是由可理解、可控制的基本部件组成的。

##### 1.1.1 编程的一致性
尽管计算机已消然地囊括了各式各样的设计理念，并日趋复杂。但其基本原理仍然相对简单。定义计算机如何工作的内部机制从上世纪50年代晶体管被第一次用于计算机起，就没有发生过太大的变化。

在那个时代，这种简单的核心意味着计算机可以而且应该具有高度一致性。对于程序员而言，这意味着，在任何时候让计算机跳高（比喻，并非真能跳高），就必须告诉它要跳多高，落在哪里，这样它才能完成跳跃动作，并且在指定的时间内，它将会一次次地重复相同的动作。如果没有改动程序，程序就不应随意地停止或改变工作方式。

##### 1.1.2 程序的可控性
编制一台计算机与编制一个计划是截然不同的。现实生活中，当要求他人做事时，有时候不得不做一番斗争以确保他们按照自己的意愿行事。例如，假如您计划了一个30个的聚会，并指定其中的两个人负责带土豆和蘸酱，但他们却带了饮料，这就失去了控制。

计算机则不存在这种问题，它会严格按照指示工作。如您所料，这意味着必须注意一些细节，以确保计算机确实做了要求它做的事。

Python语言的一个目标就是实现模块化编程，这就使得可以通过每一个子项目作为一个部件，并通过确保部件以易于理解的方式运行来实现更大的项目。这也是面向对象编程的主要目标。这种编程模式的主要原理是通过编制可靠的部件，使这些部件组装之后依然可以运行，且易于理解和使用。这就给予了程序员对程序每一部分运行方式的控制力，使得当要解决的问题发生变化时，知道如何扩展已有的程序。

##### 1.1.3 程序要应对变化
程序运行于计算机之上，并用于解决现实问题。现实世界中，计划和环境总是频繁地改变。这些不断变迁的环境使程序员很难有机会编写出技巧性、实用性和灵活性均趋于完美的程序。通常，只能达到其中的两个目标。这些不得不应对的变化应当都会程序员如何 更加小心地编写程序。如果足够小心，就可以编写出这样的程序，当用户的要求超出它的能力范围，它可以很友好地退出，并且通知它的使用者自己已终止工作。最好可以编出能够指出失败位置并解释失败原因的程序。Python提供了许多有用的特征，使得程序员可以描述出导致程序无法正常工作的原因。

##### 1.1.4 小结
综上所述，这些初步的规则意味着您即将被引进编程的大门，在一个自己控制的环境里，告诉计算机要做的工作。还会意识到，意外时有发生，但这些错误是可以通过某些机制加以控制的，这些机制可以让您知道如何对导致错误的条件进行处理，包括如何让程序从问题中恢复并继续运行。

#### 1.2 准备工作
在开始用Python编程之前，首先要下载并安装Python 3.1访问[www.python.org/download](www.python.org/download)并选择Python的最新版本。这会进入一个说明页面，告诉如何下载最适合本地计算机的Python版本。例如，如果正在运行Windows操作系统，该页面可能会建议下载Windows X86 MSI Installer(3.0)。

程序是以源代码的形式编写的。源代码中包含了使用程序语言编写的指令，当计算机读到源代码并对其进行处理时，程序里的指令将会变成计算机执行的操作。

就像作家和编辑有编写杂志、书籍以及在线出版物的专用工具一样，程序员也需要专门的工具。作为Python的初学者，最合适的编程工具莫过于Python IDLE图形用户界面了。

下载结束后，双击以运行程序。最好接受Python的所有默认提示。这个过程大概需要几分钟，具体时间取决于所使用的系统。

安装完毕之后，也许想测试Python是否被正确地安装。单击Windows的Start菜单，找到All programs，会看到Python 3.0的图标已经出现在菜单中，选择IDLE（Python GUI），等待程序加载。

一旦IDLE启动，输入“Test, test, testing”，并按下回车键。如果Python运行正常，它会返回
```
 'Test, test, testing'
```
这些字母都是蓝色的，并且带单引号（稍后将解释原因）。恭喜，您已成功安装了Python，并且正式步入了成为编程大师的征途。

##### 1.2.1 在非Windows系统上安装Python 3.1
如果使用Mac并运行Mac OS X操作系统，很幸运，它已经预装了Python。不过，它安装的可能不是最新版本的Python。为了安全性以及兼容性的目的，建议访问[www.python.org/download/mac](www.python.org/download/mac)，检查所用的Mac OS X版本是否适合正在安装的Python版本。

装有Linux系统的计算机可能已经安装好Python，但同样可能不是最新版本。这里仍然建议去Python的官方Web站点找到最新版本（当然，要适合所用的系统）。Web站点[www.python.org/download](www.python.org/download)上介绍了如何下载适合您的计算机的Python版本。

##### 1.2.2 使用Python Shell
在开始编写程序之前，需要学习如何使用Python Shell试验程序。现在，可以认为Python Shell是一种查看运行中的Python代码的方式。通过Shell可以进入Python的一个运行实例中，并可以向其中填写代码；同时，Python会执行要求它做的任何工作，并会显示它是如何对程序的环境做出响应的。由于程序通常是在一定的上下文环境——由程序员根据自己的需求量身打造——中运行，使用Shell的好处是它可以让程序员在自己创建的上下文环境中进行实验。

成功安装Python 3.1后，可以开始使用Shell的基本功能做一些实验。例如，可以输入：
``` python
 >>> "Hello World. You will never see this."
```
注意刚才输入Shell的语句实际上什么都不做，Python的环境也没有任何变化。Python会判断输入的语句让它做什么。在本例中，仅需要Python读取所输入的文本。

尽管从技术上说Python没有对输入的文本执行任何操作，但它会给出某种指示，表明自己已读过输入的语句。Python通过显示输入的文本（字符串）表明它已经读过了。字符串是Python的一种数据类型，在Python中，每种数据类型都有不同的显示方式。在逐步深入地阅读本书的过程中，读者会看到Python是如何显示每种不同的数据类型的。

#### 1.3 开始使用Python——字符串
此时，您可以自由使用Shell的基本功能进行实验。输入一些文本，并用引号括住它们。初学者可以输入如下语句：
``` python
>>> "This text really won't do anything"
"This text really won't do anything"
```
您应该立刻注意到，当输入一个引号（"）时，Python Shell改变了之后输入的所有字符的颜色，走到输入第二个引号以结束当前输入的语句。当然，前面的解释是成立的。它什么都不做：它 会改变Python的环境，正在运行的Python实例仅判断输入的语句是否让Python做一些事情。本例中，仅仅让它读入所写的文本，但这些并不会改变环境。

然而，可以看到Python表示它看到了输入。它以字符串的形式显示了输入，即用引号把输入的文本括起来。当学习了其他数据类型后，会发现Python显示不同数据类型的方式是不同的。

##### 1.3.1 字符串概述
字符串是Python语言的一种数据类型。顾名思义，数据类型是指某种特定类型的数据所适合的类别。输入到计算机中的数据会被划分为某种数据类型，不管它们是数值还是字母。定义数据类型使得计算机可以断定如何处理输入的数据。例如，如果想让程序在屏幕上显示数学公式 1+1 ，必须告诉它输入的是文本。否则，程序会将输入解释为数学公式，并进行相应的计算。

在后续的章节中，读者将会了解到越来越多的不同的数据类型，并理解定义数据类型的重要性。目前，知道字符串是由任意字符构成的数据类型即可，一个字符呆能是一个字母、数值、符号或标点符号。因此，下面所列都是字符串的示例。
``` python
 "Hello, how are you?"
 "1+1"
 "I ate 4 bananas"
 "!@#$%^&*()"
```

##### 1.3.2 为什么需要引号
当向Python输入一个字符串时，首先要输入一个引号。至于应该使用单引号（'）、双引号（"）还是三个引号（'''），要取决于想完成的目标。大多数情况下会使用单引号，因为它最容易输入（不需要按下Shift键）。然而，请记住，单引号和双引号以及三层引号是等价的。

尝试输入一些字符串。每当输入一个语句后，按下回车键让Python计算输入的语句。

@(<Inbox>)[用不同的引号输入字符串, 用加号串联字符串, 更多字符串格式, 对不同的数值使用type, 创建虚数, 在字符串中包含不同的数字, 在字符串中将%符号转义, 基本算术, 使用取余运算, 打印结果, %f格式说明符, 使用数学运算, 使用数字格式, 出错, 将数字格式化为八进制和十六进制, 给名称赋值, 创建和使用元组, 通过一个元组访问另外一个元组, 查看列表中的元素, 创建字典]

输入如下字符串，记住引号的类型（单引号或双引号）和行的末端（到达行的末端时使用回车键）：
``` python
 >>> "This is a string using a double quote"
 'This is a string using a double quote'
 >>> 'This is a string with a single quote'
 'This is a string with a single quote'
 >>> """This string has three quotes
 look at what it can do !"""
 'This string has three quotes\nlook at what it can do!'
 >>>
```
在上面的示例中，尽管每个句子看起来都不一样，但计算机用同样的方式解释它们：作为字符串。下面将介绍使用3种不同引号的真正目的。

##### 1.3.3 为什么有3种类型的引号
有3种类型的引号的原因很简单。假定就像刚才所做的那样，要在句子中用一个缩写。如果向Shell中输入语句“I can't believe it's not butter.”，不会有什么问题，但是当实际上程序用到刚才输入的 字符串时，就会得到出错的消息。为了解释这种现象，下一节将介绍`print()`函数。

##### 1.3.4 使用print()函数
Python（以及其他程序语言）中的函数是开发人员用来节省时间以及使程序更有效率的工具。他们将可以重复使用的代码存储在函数中，然后在需要的时候调用这些函数，而不是一遍遍地编写相同的代码。目前不要太担心函数，在后面会对它们进行更详细的介绍。

`print()`函数用来在屏幕上打印文本。在Python Shell中尝试如下的示例：
``` python
 >>> print("Hello World!")
```
按下回车键后，可得到如下输出：
``` python
 Hello World!
```
 这里有几个地方需要注意。首先，当进入`print()`函数时，会弹出如图1-1所示的窗口，显示函数中各种可用的选项。其次，后续行中的文本再次显示为蓝色，但这次，文本周围并无引号。这是因为与之前的示例有所不同，这一次Python实际上对数据做了一些操作。
 ![图1-1](https://i.loli.net/2019/04/25/5cc1669f34d24.png)
 图 1-1

 恭喜，您已经编写了自己的第一个程序。

##### 1.3.5 理解不同的引号
 现在知道了如何使用`print()`函数，可以练习使用本章前面提到的各种不同类型的引号了。尝试之前的示例：
``` python
 >>> print('This is a string using a single quote!')
 This is a string using a single quote!
 >>> print("This is a string using a double quote!")
 This is a string using a double quote!
 >>> print("""This string has three quotes!
 Look at what it can do!""")
 This string has three quotes
 Look at what it can do!
```
可以看到，在示例所示的这些情况中单引号（'）和双引号（"）是可以互换的。然而，若想使用缩写，例如don't，或者想引用某人的言论，观察会发生什么：
``` python
 >>> print("I said, "Dont't do it")
```
当按下回车键执行该函数时，会得到错误消息：`SyntaxError: invalid syntax(<pyshell#10>, line 1)`。您也许会感到奇怪，单引号和双引号不是可以互换吗？大部分情况下是这样的。然而，将它们混合在一起时，经常会出现语法错误，表示错误地输入了代码，并且Python不会知道您的意图何在。

实际上，Python看到输入的第一个双引号后，把它解释为字符串的开头。当它在单词`Don't`之前碰到双引号时，会将该引号看做字符串结束符。因而，后面的字母对Python是没有意义的，因为它们不是当前字符串的一部分。直到遇到字母t之前的那个单引号时，字符串才重新开始。

有一个简单的解决办法，叫做转义。再试一下前面的代码，在字符串中加入一个转义字符：
``` python
 >>> print("I said, \"Dont't do it")
 I said, "Don't do it
```
这一次，代码可以工作了。当Python见到反斜杠（\），也就是转义字符时，知道应当把双引号看做一个字符，而不是某种数据类型的指示符。但是，也许您已经注意到了，这行代码还存在最后一个问题。看到输出结果最后丢失了一个双引号吗？为了使用Python将语句末尾的双引号打印出来，只需要再增加一个转义字符以及一个双引号即可，如下所示：
``` python
 >>> print("I said, \"Dont't do it\"")
 I said, "Don't do it"
```
最后，花点时间讨论一下三引号。之前简单介绍过它的用法。从该示例可看出，利用三引号可以输入多行文本，在输入结束三引号之前这些文本不会被处理。这种技术在不想将大量数据打印到一行以及想在代码中换行时非常有用。接下来的示例使用这种方法写了一首诗：
``` python
 >>> print("""Roses are red
 Violets are blue
 I just printed multiple lines
 And you did too!""")
 Roses are red
 Violets are blue
 I just printed multiple lines
 And you did too!
```
还可以利用换行（\）转义字符在多行中打印文本，换行符是最常用到的转义字符。这里对其做一简单介绍，在后续章节中会深入地讨论它。尝试如下代码：
``` python
 >>> print("Roses are red \n Violets are blue \n
 I just printed multiple
 lines \n And you did too!")
 Roses are red
 Violets are blue
 I just printed multiple lines
 And you did too!
```
可以看到，结果是一样的。采用哪种方法取决于自己，但是换行符可能更有效率并且更易于理解。

#### 1.4 串联两个字符串
每个程序员都会遇到要把两个或多个字符串连接在一起的情况，这叫做串联（concatenation）。例如，假设有一个包含了雇员的名和姓的数据库。某些时候可能希望半这些名字作为完整的记录打印，而不是将名和姓分开。Python中，每个这样的项都会被看做一个单独的字符串，如下所示：
``` python
 >>> "John"
 'John'
 >>> "Everyman"
 'Everyman'
```

@(**试一试**)[用加号串联字符串]

有许多将不同的字符串串联起来的方法。第一种是数学方法：
``` python
 >>> "John" + "Everyman"
 'JohnEveryman'
```
也可以不用+号，而采用下面这种方法：
``` python
 >>> "John" "Everyman"
 'JohnEveryman'
```
从这些示例可以看出，字符串被串联起来了；然而，Python逐字读这个语句，因而两个字符串之间没有空格（请记住：Python现在将它们看做一个字符串，而不是两个！）。如何处理这种情况？有两种解决方法。第一种是在第一个字符串后加入一个空格，如下所示：
``` python
 >>> "John " "Everyman"
 John Everyman
```
然而，并不推荐使用这种方法，因为将来需要阅读这段代码时，很难确定是否存在John的后面加了空格。另外一种方法是简单地使用一个分隔符，例如：
``` python
 >>> "John" + " " + "Everyman"
 'John Everyman'
```
使用这种方法而不是简单地输入一个空格的其他原因与数据库存储有关，第14章中将讨论这方面的内容。请注意，可以使用任意的分隔符，例如：
``` python
 >>> "John" + "." + "Everyman"
 'John.Everyman'
```
##### 用print函数连接字符串
默认情况下，当要在一句话中打印多个字符串时，print()函数会非常周全地插入空格。这里没有必要使用空格分隔符。相反，只需要用逗号将不同的字符串隔开即可。
``` python
 >>> print("John", "Everyman")
 John.Everyman
```

#### 1.5 用不同的方法串联字符串
另外一种指定字符串的方法是使用格式说明符。它通过插入一个特定的字符序列工作，这个字符序列被Python解释为占位符，并将由程序员提供的值 替换。初看起来，这种方法很复杂，不是非常有用，但格式说明符可以控制要显示的信息的格式，还可以提供许多有用的技巧。

@(**试一试**)[用加号串联字符串]

在最简单的情形下，可以对朋友John Q.做同样的事情：

##### 示例说明
%s是针对字符串的格式说明符。在本书对数据类型进行不断讨论的过程中，还会遇到更多的格式说明符，它们分别对应于特定的数据类型。在字符串中，每个格式说明符都担当相应类型的占位符。字符串外面的%符号表明它后面的所有值会被插入到字符串中相应的格式说明符处。

注意圆括号，它告诉字符串后面的序列包含用于填充格式说明符的值。

一种简单的理解方式是%s是一个存储器，存放着圆括号中的值。如果想处理更多的值，只需加入另外一个格式说明符即可，例如：
``` python
 >>> "John %s%s" %("Every", "Man")
 John Everyman
```
这些序列是Python编程的一部分，同样地，在本书的后续章节中会对其做更详细的介绍。目前，只需知道字符串中的每一个格式说明符在提供给它的序列中都必须有一个元素与之对应即可。序列中的每一项都是用逗号分隔开的字符串。

如果是向其中存放数据，为什么要把它们叫做格式说明符呢？原因是它们有多种功能，作为存储器只是其功能之一。下面的示例不仅说明了如何向格式说明符中存放数据，还说明了如何用它指定要显示的数据格式。

@(**试一试**)[更多字符串格式]

这个示例告诉格式说明符处理多个字符。尝试如下代码，并观察结果：
``` python
 >>> "%s %s %10s" % ("John", "Every", "Man")
 'John Every           Man'
 >>> "%-5s %s %10s" % ("John", "Every", "Man")
 John     Every          Man
```
##### 示例说明
在第一行代码中，单词Man出现时，离前面的单词很远，这是因为在最后一个格式说明符中添加了10，表示一个长度为10的字符串。如果字符串没有10个字符（它仅包含3个字符，即M-a-n），它就会在前一个单词与Man中间加入7个空格。

在输入的第二行代码中单词Every被空格隔开的方式与其他单词不同。原因与第一行代码相同，只不过这次空格是在左边，而不是右边。将负号放在格式说明符的右边，这个格式会出现在单词的右边。如果使用了一个非负的数值，它出现在左边。

#### 1.6 本章小结
本章学习了如何安装Python，以及如何使用Python GUI(IDLE)，这个GUI是用Python编写的程序，专门用于编辑Python程序。除了编辑文件，这个Shell还允许用Python的简单编程语句进行实验。

本章通过使用Shell介绍了有关字符串处理的基本知识，包括字符串串联，如何使用格式说明符对字符串进行格式化，甚至如何在同样的%s格式说明符中存储字符串。另外，还学习了如何使用多种类型引号，包括单引号、双引号和三引号，并且了解了\n换行转义字符的含义。

最后，学习了第一个函数print()，并且编写了自己的第一个程序Hello World，初学编程时第一个编写Hello World程序在程序员中间是一个历史悠久的传统，这与演奏吉他首先要学习“Smoke on the Water”一样——它们都是必学的第一课。

##### 本章要点：
* 编程的一致性。所有程序都是为了特定的用途而创建的，程序的使用者不仅希望程序能够实现预定的用途，而且希望程序每次的工作方式都相同。如果用户单击一个按钮，有一个打印对话框弹出，那么这个按钮应当总以相同的方式工作。
* 编程的可控性。程序员控制着自己的应用程序可以执行以及不可以执行的操作。即使程序的某些方面对于普通的观察者而言是随机的，但实际上它们也是由程序员创建的参数控制的。
* 程序要应对变化。通过不断的测试，可以确保程序对用户做出适当的响应，即使用户让程序做一些其能力范围之外的事情。
* 字符串是一种数据类型，简单讲，是一类数据。这些字符串允许以多种方式与用户进行交互，例如，向窗口打印文本，接受用户输入的文本等等。一个字符串可由任意的字母、数值或者特殊字符组成。

#### 1.7 习题
1. 在Python Shell中，输入字符串：“Rock a by baby, `\n\ton the top, \t\when the windblows\n\t\t\t the cradle will drop”`。可以使用不同数目的\n和\t转义序列进行实验，看看它们的数目对屏幕上的显示有什么影响。甚至可以尝试把它们放在不同的位置。可能的输出是什么？

2. 在Python Shell中，使用与练习1中相同的字符串，但是这一次使用print()函数显示该字符串。再一次尝试不同数目的\n和\t转义序列。结果会有什么不同？

### 第2章 数值与运算符
人们天生使用数值。婴儿从开始爬行到最终站起来都使用数值估计距离。随着时间 的推移，人们扩大了数值的使用范围，开始更加有意识地使用数值，例如购买饮料或制定每月的预算。不论是一岁还是九十岁，都对数值有一定程序的了解。实际上，数值是一个如此熟悉的概念，以至于很难注意到在不同的上下文中有多种使用数值的方式。

本章介绍数值以及Python处理数值的一些方法，包括基本算术以及针对不同类型数值的特殊的字符串格式说明符。

本章将介绍：
* Python使用的各种基本数值类型。
* 使用数值的方法。
* 如何显示以及混合各种类型的数值。

#### 2.1 不同类型的数值
如果使用过电子制表软件，会注意到制表软件并不把数值看做单纯的数值，而是看做不同类型的数值。电子制表软件根据不同的单元格格式，用不同的方法显示数值。例如，当处理美元数据时，电子制表软件将1美元显示为1.00。然而，如果想知道自己的车行驶的英里数，很可能以十分之一英里为单位记载，例如10.2英里。当说出想为一个新房子付多少钱时，很可能想到最接近的千位数。在数值的大端，电表账单以千瓦时为单位记录了读表数，千瓦时是指每小时1000瓦。

这对Python意味着，当想使用数值时，有时需要意识到并不是所有的数值都是相关联的（就像本章中讲到的虚数一样），并且有时必须谨慎地决定使用什么样的数值以及要用这些数值做什么。然而，一般情况下，有两种使用数值的方式：第一种是告诉Python重复一个特定的动作，第二种是用数值代表现实世界中的事物（即在程序中尝试对现实世界中的事物建模）。在Python中进行计数时，很少需要将数值看做简单数值之外的其他事物。然而，当尝试解决现实世界中的问题，例如涉及货币、科学、汽车、电等的问题，会发现自己更加清楚如何使用数值。

##### Python中的数值
Python提供了三种类型的可用数值：整型、浮点型和虚数。

在之前的版本中，Python用不同的方法处理大数。介于`-2 147 483 648`和`+2 147 483 647`之间的数被认为是整型。更大的数被提升为长整型。现在这两种类型已经合并，所以整型用于表示整数，无论这个整数是正数还是负数。

要确定数值的分类，可以使用Python中内置的一个特殊函数type。当使用type时，Python会告诉正在使用数据的类型。下面用几个示例进行说明。

@(**试一试**)[对不同的数值使用type]

在Python Shell中可以输入不同数值，type将指出Python如何看待这些数值：
``` python
 >>> type(1)
 <class 'int'>
 >>> type(2000)
 <class 'int'>
 >>> type(999999999999)
 <class 'int'>
 >>> type(1.0)
 <class 'float'>
```
##### 示例说明

尽管日常生活中，`1.0`与`1`相同，但Python自动将`1.0`看做一个浮点数；没有`.0`，数值`1`被当作整数`1`来处理（在小学学到的整数），这是另一种数值类型。

本质上，浮点数与整数的特殊区别在于浮点数有小数部分。像1.01、2.34、0.02324这样的数，以及其他包含小数部分的任意数值都被当作浮点数（虚数例外，它们有单独的规则）。这种数值类型可以用来处理货币或者具有可分性质的事物，例如汽油或者一对袜子（经常发现只剩下一只袜子，是不是这样？）。

##### 棘手的数值
工程领域、金融领域以及其他领域的专家需要处理非常大以及非常小的数（小到有一堆小数位），他们需要比内置类型（例如浮点型）更高的精度和一致性。如果要在编程中探索这些学科，应该使用可用的模块，第7章将介绍模块，它们用来处理与感兴趣的领域有关的问题。至少，在需要使用高精度浮点数时，有必要研究如何使用为处理这些数值编写的模块，这些模块的使用方法不同于默认行为。

Python提供的最后一种数值类型是面向工程师和数学家的。它就是虚数，在学校中应该学习过这种数。虚数定义为`-1`的平方根。尽管叫做虚数，它在对现实工程情形进行建模以及其他领域（例如物理和纯数学领域）都有许多实际的应用。虚数被内置到Python中，因此可以被经常使用计算机解决问题的用户方便地使用。如果您恰巧是这类用户，就会高兴地发现自己并不孤单，Python可以帮助您完成自己的目标。

@(**试一试**)[创建虚数]

除了不能与浮点数混合之外，虚数与浮点数很相似。虚数尾部有一个字母`j`：
``` python
 >>> 12j
 12j
```
##### 示例说明
当在数值之后使用字母j，并且数值和字母不是这字符串（即不在引号中）时，Python知道要将输入的数值看做虚数。出现在字符串以外的字母都必须有特殊含义，例如，这个修饰符指定了数值的类型，或者是一个已命名变量（见第3章），或者是另外一个特殊名称。否则，一个字母单独出现会导致出错！

可以将虚数与非虚数结合起来，创建一个复数：
``` python
 >>> 12j + 1
 (1+12j)
 >>> 12j + 1.01
 (1.01+12j)
 >>> type (12j + 1)
 <class 'complex'>
```
可以看到，当试图混合虚数以及其他数值时，它们没有相加（相减、相乘或相除），而是以创建复数的方式保持独立。复数有实部和虚部，但是如何使用它们超出了本章的讨论范围，如果需要使用它们，可以在学习第6章以后探索复数模块（再一次出现这个词！）。模块的名称是cmath，代表complex math。复数将在第19章做进一步讨论。

#### 2.2 程序文件
现在，您应该可以比较熟悉地使用Python Shell，并在其中编写不同代码。前面用它实现示例，但现在将以一种不同的方式使用它。不同于简单地输入那些在GUI关闭之后会消失的单行代码，现在将创建和保存实际的文件，这些文件可以被再次打开和使用。

本章后续部分鼓励使用Python Shell和记事本创建自己的文件。

@(**试一试**)[创建虚数]

向记事本中输入下面的文本：
``` python
 print("This is a basic string")
 print("We learned to join two strings using " + "the plus operation")
```
现在已经向编辑器中添加了代码，尝试保存它。选择File菜单的Save As命令（如图 2-1 所示。）

![图2-1](https://i.loli.net/2019/04/25/5cc1670bb0496.png)

图 2-1

此时将出现一个弹出菜单，提示输入文件名和文件的存储目录。Python文件使用`.py`扩展名，因此要始终确保将`.py`加到文件名之后，否则记事本会将文件保存为其默认类型`.txt`。将这个文件命名为`Test.py`。接下来，定位到Python的安装目录。通常，安装路径以`C:/Python31/`开头。单击`Save`按钮，就把文件保存到了指定位置。

** 提示 **
在选择文件名并保存文件之后，可以重新打开它。要运行`Test.py`，在Python Shell中选择`File | Open`，选定要运行的文件（此处是`Test.py`）。Python编辑器将打开。单击`Run`，选择`Run Module`（见图 2-2），然后满怀期待地关注自己的第一个运行的程序。

![图2-2](https://i.loli.net/2019/04/25/5cc169019a79d.png)

图 2-2

要注意一些情况。首先，初次打开`Test.py`文件时，Python使用不同的颜色突出显示代码。这使得函数和数据类型（以及其他许多与编程有关的方面）更易于辨认。例如，`print()`函数的颜色是紫色的，而包含值的字符串是绿色的。

运行这个模块时，不再看到代码，而是看到它的结果在屏幕上以蓝色文本写出：
``` python
 This is a basic string
 We learned to join two strings using the plus operator
```
用不同的字符串再多做几次这样的操作，把它们保存在不同的文件中。每个会话现在都是可用的，之后可以引用它们。

##### 2.2.1 使用不同的类型
除了基本的整形外，其他数值类型也可能增长到具有过多的数位，从而变得难以阅读和理解。所以，经常看到这些数值在生成之后，以类似于科学计数法的格式出现。Python也允许以这种格式输入数值，所以这是一条双向路。使用非常大的整型数和浮点型数有许多障碍。这个主题涉及很多细节，并且不是学习Python必须理解的。如果想对一般意义上的浮点数有更多了解，并且了解它们对计算机而言意味着什么，[http://docs.sun.com/source/806-3568/ncg_goldberg.html](http://docs.sun.com/source/806-3568/ncg_goldberg.html)是一篇非常优秀的参考文化，尽管其中的解释只对了解计算机和数值的人有意义。然而，不要因此就不去阅读，它也许是您将来某个时刻想了解的知识。

最常用的是整型和浮点型。从某些地方（例如日期、时间或者某人的年龄信息等）得到数值的情况很常见。当以数值的形式得到数据后，还需要显示数据。

通常的方法是将数值放到字符串中。可以使用第1章中用到的格式说明符方法。直觉上，可能认为应当能够使用`+`将数值包含到一个字符串中，但实际上这是不行不通的，因为它们是不同的类型，而`+`运算符只能用于同类型数据：例如，两个字符串，两个数值，或者两个其他对象和类型等。有一个例外是浮点数和整型数可以相加。除此以外，应当认为不同类型的数据是不能用`+`运算符结合起来的。

您可能会感到奇怪，为什么字符串的格式说明符中可以有数值，但是`+`却不可以。原因是`+`运算符依赖于要相加的实际项中包含的信息。在Python中使用的任何东西都可以看做具有属性的对象，并且所有的属性结合在一起定义了这个对象。每个对象最重要的属性是它的类型，现在对于类型，最重要的是理解，一些自然而然可以理解的操作（例如`+`操作）只能用于两个可兼容类型的对象。大部分情形下，除了数值以外，应该把可兼容类型看做同一类型。

** 提示 **

如果确实想对数值和字符串执行`+`操作（这经常是自己可以决定的风格问题），可以使用一个内置函数`str`，该函数在可行的情况下把数值转换为字符串。这样就可以完成将字符串和数值相加，从而形成一个单独的字符串这样的操作。可以对大多数对象使用`str`函数，因为大多数对象都有一个作为字符串显示的方法。然而，为了保持一致，现在仍然使用字符串格式说明符。

@(**试一试**)[在字符串中包含不同的数字]

在第1章中使用格式说明符将两个字符串连接在一起时，用到了格式说明符`%s`，它的含义是“一个字符串”。由于数值和字符串有不同的类型，必须使用不同的说明符将数值包含到字符串中：
``` python
 >>> "Including an integer works with %%d like this: %d" % 10
 'Including an integer works with %d like this: 10'
 >>> "An integer converted to a float with %%f: %f" % 5
 'An integer converted to a float with %f: %f: 5.000000'
 >>> "A normal float with %%f: %f" % 1.2345
 'A normal float with %f: 1.234500'
 >>> "A really large number with %%E: %E" % 6.789E10
 'A really large number with %E: 6.789000E+10'
 >>> "Controlling the number of decimal places shown: %.02f" % 25.101010101
 'Controlling the number of decimal places shown: 25.10'
```
如果不知道在哪里使用格式说明符，注意最后一个示例看起来与打印货币数值的方法很相似，实际上，任何处理元和分的程序都至少要有这种处理数值和字符串的能力。

** 示例说明 **

任何时候，当为字符串提供格式说明符时，可能会有一些选项可以用来控制该说明符如何显示与它相关联的值。在第1章中已经看到与`%s`相关的选项，该选项可以控制显示的字符数。数值说明符也是一种 约定，指出特定类型的数值应该如何显示。当使用任意数值格式说明符时，这些约定控制着显示的结果。

@(**试一试**)[在字符串中将%符号转义]

之前已经给出了另外一个小窍门。如果想在程序中打印字符串`%d`，可以在Python字符串中连续使用两个`%`符号。这仅当在同一字符串中还有其他Python可以替换的有效格式说明符时才是需要的。
``` python
 >>> print("The %% behaves differently when combined with other letters, like this: %%d %%s %%f %d" % 10)
 The % behaves differently when combined with other letters, like this: %d %s %f 10
```

** 示例说明 **

注意，Python注意字母的组合，它将在一个字符串中既有格式说明符又有双百分号时正确地工作。

##### 2.2.2 基本算术
在程序中使用数值进行基本算术运算的情况是很常见的。加法、减法、除法和乘法都是内置的。加法和减法通过`+`和`-`号执行。

@(**试一试**)[基本算术]

在Python Shell提示中可以输入基本的算术表达式，将它当作一个计算器来使用。像计算器一样，Python接受一组操作，当按下`Enter`键后，它将计算输入的表达式，并给出结果：
``` python
 >>> 5 + 300
 305
 >>> 399 + 3020 + 1 + 3456
 6876
 >>> 300 - 59994 + 20
 -59674
 >>> 4023 - 22.46
 4000.54
```

** 示例说明 **
简单的算术运算起来和预期的一样。除了`+`和`-`，乘法通过`*`执行，除法通过`/`执行。由于浮点数整数的区别，乘法和除法在Python中并没有想象的那么直截了当。

在Python早先的版本中，当数值变大时，将从整型被提升为长整型。然而，Python 3.1中合并了这两种类型，所以不再需要做这样的提升。观察下面的数值以及当这些数值达到一定大小时Python是如何提升它们的：
``` python
>>> 2000403030 * 392381727
784921594607432810
>>> 2000403030 * 3923817273929
7849215963933911604870
>>> 2e304 * 3923817273929
inf
>>> 2e34 * 3923817273929
7.8476345478579995e+46
```
注意，尽管Python可以处理非常大的数，但是一些操作的结果仍会超过Python的容纳能力。Python在遇到无法处理的大数时将返回inf，这是infinity（无穷大）的缩定。

在Python 3.1之前，除法更值得注意。在没有帮助的情况下，Python不能够通过除法将一种数转化为另一种数。只有当至少有一个操作数是浮点数（数后有一个小数点）时才显示浮点型结果。如果两个普通的整型或者长整型数（无论是其中的哪种情况，都缺少小数部分，包括`.0`）相除，余数将被舍弃。这个问题已经被解决了，目前的Python将显示小数，除非告诉它不要这样做。观察如下输出：
``` python
 >>> 44 /11
 4.0
 >>> 5.0 / 2.5
 2.0
 >>>324/101
 3.2079207929792981
 >>> 324.5/102.9
 3.1535471331389697
```
可以看到，如果将一个整数与另外一个整数相除，将显示一个浮点数，即使在没有余数的情况下也是如此。同样地，一个整数除以一个浮点数将返回一个浮点数。然而要注意，即使整型被显示为浮点型，如前面示例中的`4.0`和`2.0`，但实际上它仍旧是整型。不过，`324/101`的结果被转换成一个浮点数。

@(**试一试**)[使用取余运算]

Python还有一个基本运算应当注意：取余运算。Python一个新增的功能是允许查看一则除法的完整结果（如前面的公式`324/101`中所示）。以前，如果想知道余数，必须要用取余运算符，因为Python只显示结果的整数部分。对于`324/101`，Python将显示3。不过在某些情况下，仍然仅需要除法结果的余数部分。为了确定这部分结果，必须要用取余运算符，符号是`%`。不必困惑，`%`只有在用于数值的时候才代表取余数。当使用字符串时，它仍然表示格式说明符的含义。同样的操作在不同的上下文中有不同的含义，这叫做重载，是一种非常有用的功能，但是当某些操作通过设计而具有不同行为时请不要惊讶。
``` python
 >>> 5 / 3
 1.666666666666667
 >>> 5 % 3
 2
```

** 示例说明 **

上面的代码表示`5`除以`3`得`1.666666666666667`，而在第二个示例中，当`5`除`3`时余数为`2`。取余运算符一个非常有用的任务是确定某个数是否可以被另外一个数整除，例如，决定序列中的某些项是否可以均匀地填充到另外一个序列中（第3章会介绍更多关于序列的知识）。这里有一些示例可以尝试：
``` python
 >>> 123 % 44
 35
 >>> 334 % 13
 9
 >>> 625 % 4
 0
```

##### 2.2.3 一些惊喜
当处理普通的浮点值时要小心，例如钱数。Python中的一些地方很令人迷惑。例如，当以看似直接的数学方式操作某些数时，得到的结果后面将有一些多余的值，如下所示：
``` python
 >>> 4023 - 22.4
 4000.599999999999
```
尾部的9会令人烦恼，但它们仅仅反映了Python的高精度。然而，当打印或者执行数学运算时，这个我实际上将得到精确的结果。

@(**试一试**)[打印结果]

尝试实际打印出结果，将上面具有不同寻常结果的数学公式的结果显示给用户，例如，在某个程序内部就可能采取这种做法：

``` python
 >>> print("%f" % (4023 -22.4))
 4000.600000
```

** 示例说明 **
前面介绍浮点数除法时提到，在Python 3.0中会输出整个公式。在计算公式`5/3`时，会得到`1.666666666667`。但是也许并不想向用户显示这么长的一串数值。可以用`%f`格式𧪈符将答案截短。

@(**试一试**)[%f格式说明符]

尝试下面的代码，观察Python处理浮点运算的不同方法，以及如何利用格式化方法操作结果：
``` python
 >>> print("%f" % (5/3))
 1.666667
 >>> print("%.2f" % (5/3))
 1.67
 >>> print("%f" % (415 * 20.2))
 8383.000000
 >>> print("%0.f" % (415 * 20.2))
 8383
```
浮点数非常容易让人糊涂。对浮点数的完整讨论超出了本书的范围，但是如果熟悉计算机和数值并且想更多地了解浮点数，可以阅读[http://docs.sun.com/source/806-3568/ncg_glodberg.html](http://docs.sun.com/source/806-3568/ncg_glodberg.html)上的论文。论文里的解释应该可以帮助完善这里的讨论。

#### 2.3 使用数值
如前面的示例所示，可以利用诸如格式说明符的方法将数值包含到字符串中，并用`print()`函数显示出来。重要的一点是必须确定如何显示这些数值，以便它们可以表示想让它们表示的含义，这要取决于对应用程序的了解程度。

##### 2.3.1 求值顺序
进行数学运算时，可能会看到`4*3+1/4-12`这样的表达式。面临的一个问题是确定如何求这种表达式的值，以及自己求值的方法是否与Python的求值方法相同。最安全的做法总是把数学表达式用括号括起来，这就是使得先求哪些数学运算的值变得清楚。

Python以如下方式对这些基本的数学运行求值：先计算乘法和除法，后计算加法和减法，但即使这样也有令人困惑的时候。

@(**试一试**)[使用数学运算]

当考虑一组数学运算时，将它们写下来（或者用键盘输入）看起来最直接，然而以后查看这些运算时容易感到迷惑。尝试如下示例，设想它们没有括号：
``` python
 >>> (24 * 8)
 192
 >>> (24 * (8 + 3))
 264
 >>> (24 * (8 + 3 + 7.0))
 432.0
 >>> (24 * (8 + 3 + 7.0 + 9))
 648.0
 >>> (24 * (8 + 3 + 7.0 + 9))/19
 34.10526305789474
 >>> (24 * (8 + 3 + 7 + 9)) / 19
 34.10526315789474
 >>> (24 * (8 + 3 + 7 + 9))%19
 2
```
在示例中要注意，使用浮点数时，整个公式会改为使用浮点数，而去掉所有浮点数会导致Python将所有数都看做整型，除非结果是浮点型的。

** 示例说明 **

上面的示例以类似于正常求值顺序的方式组合在一起，但是使用圆括号可以肯定哪组代数运算将首先被求值。最里面的运算最先被求值，最外面的运算最后被求值。在一结圆括号内，以正常顺序求值。

##### 2.3.2 数值格式
当准备在字符串中包含数值时，有很大的灵活性。下面的“试一试”部分给出了一些示例。

为了显示钱数，使用格式说明符将小数点后的位数限制为两位。

@(**试一试**)[使用数字格式]

例如，尝试下面的示例。这里把一个数值作为钱数打印：
``` python
 >>> print("$%.02f" % 30.0)
 $30.00
```
也可以用类似的格式表示小于1美分的值，例如当列出单独销售的小件商品时。如果要打印的数值多于即将打印的位数，看看Python将怎么做：
``` python
 >>> print("$%.03f" % 30.00123)
 $30.001
 >>> print("$.03f" % 30.00163)
 $30.002
 >>> print("%.03f" % 30.1777)
 30.178
 >>> print("%.03f" % 30.1113)
 30.111
```

** 示例说明 **
正如所见，如果指定的格式比要求Python显示的精度更高，Python不会截断当前的数。它将适当地进行数学上的四舍五入操作。

##### 2.3.3 可能会发生的错误
输入这些示例时，可能会犯错。显然，输入一个不同的数时，Python帮不了任何忙，得到的结果肯定会与本书不同。然而，对于作为格式说明符输入的字母对Python没有意义的情况，或者在提供给一个字符串格式说明符的序列中没有足够多的数值时，Python会试图给出尽可能多的信息，指出发生了什么问题，开发人员可以根据这些信息修复错误。

@(**试一试**)[出错]

为了理解错误发生后，接下来会发生什么，这里给出一些可以尝试的示例。从第4章开始将介绍它们完整的含义，但此时应当知道：
``` python
 >>> print("%.03f" % (30.1113, 12))
 Trackback (most recent call last):
   File"<input>", line 1, in ?
 TypeError: not all arguments converted during string formatting
```

** 示例说明 **

在上述代码中，序列中的元素（总共两个）多于字符串中的格式说明符（仅一个），因此Python给出一条帮助消息。这个错误将导致正在运行的程序停止运行，因此这通常是一个出错条件，或者称为异常。这里，词`arguments`指的是格式说明符，但通常用来代表使某个对象工作所需要的参数。当调用需要指定若干值的函数时，每个期望的值就叫做一个参数。

这是程序员认为理所当然的事；这种专门的技术语言可能不会立刻显得有意义，但是熟悉它之后就会感觉正确了。尽管为了减少困惑，在本书的前10章中，将把`arguments`当作参数，因为没有人会有争议，它们仅仅是用于设置在特定时刻要用到的条件。编程时，`arguments`和`parameters`是可以互换的。

下面列出了另外一个可能发生的错误：
``` python
 >>> print("%.03f, %f %d" % (30.1113, 12))
 Trackback (most recent call last):
   File"<input>", line 1, in ?
 TypeError: not enough arguments for format string
```
现在知道了Python中argument所代表的含义，错误消息的含义就是很显明了。代码中使用了一个格式说明符，但在伴随的序列中并没有一个值可以与之匹配，因此，没有足够多的参数。

如果尝试将字符串和数值相加，也将会出错：
``` python
 >>> "This is a string" + 4
 Trackback (most recent call last):
   File"<pyshell#13>", line 1, in <module>
 TypeError: Can't convert 'int' object to str implicitly
```
错误消息不难理解，因为前面已经介绍了执行这种操作的条件。不过下面给出了清晰的表述：Python清楚地告诉您哪些事它被告知去做但却做不了，因此需要自己解决问题（提示：可以使用str函数）。
```python
 >>> "This is a string""" + str(4)
 'This is a string4'
```

##### 2.3.4 几个不寻常的例子

Python还为数值提供了另外一个值得了解的特性，以便在遇到时可以理解它。通常我们使用十进制，即基数为10的计数系统。它包含0～9共10个数字。大于9的数字由0～9的各种组合表示。然而，计算机通常用八进制（octal)以及十六进制（hexadecimal）表示它们实际处理的二进制数。这些系统给程序员提供了一种了解数据字节的简单方法，数据经常由一到两个8位组成。

另外，不管是八进制还是十六进制都不能显示负数。用这种方法描述的数值叫做无符号数，与有符号数对应。`+`号和`-`是不同的。通常地，数值被认为是正数，但如果一个数是有符号的，它也可以是负数。如果一个数值是无符号的，它一定是正数。如果要求以无符号格式字符串显示负数，将得到预想不到的结果。

@(**试一试**)[将数字格式化为八进制和十六进制]

```Python
 >>> print('Octal uses the letter "o" lowercase. %d %o' % (10, 10))
 Octal uses the letter "o" lowercase. 10 12
```
将数值10提供给字符串时，第二个数却打印为12，看起来这像是个错误。然而八进制仅仅有8个数值（0～7），因此`0～10`用八进制表示依次是`0、1、2、3、4、5、6、7、10、11、12`。
```Python
 >>> print('Hex uses the letter "x" or "X". %d %x %X' % (10, 10, 10))
 Hex uses the letter "x" or "X". 10 a A
```
还有另外一个地方需要解释。十六进制使用`0～15`的数字，但是因为`9`这之后就没有数字了，所以十六进制用了字母`a～f`。如果使用格式说明符`%x`，这些字母是小写的；如果使用`%X`，它们则是大写的。因此，十进制的`0～19`用十六进制表示为：`0、1、2、3、4、5、6、7、8、9、a、b、c、d、e、f、10、11、12、13`。

#### 2.4 本章小结
本章介绍了Python中的数值，但是没有涵盖数值的所有方面。我们看到并使用了3种 Python内置的数字：整型数、浮点型数以及虚数。本章还介绍了如何用字符串格式说明符在字符串中包含数值，并且使用不同风格格式化了这些数值。

要重点记住，数值的格式（数值在字符串中的显示方式）并不会改变其值。即使打印成整型，浮点数仍然是浮点数，反之亦然。

本章执行了主要的内置的数学运算：加、减、乘、除以及取余。还介绍了如果整型和浮点型混合，结果为浮点型，如果两个整型数相除，可能也将适当地返回一个浮点型数。如果将整型或者浮点型数与虚数结合起来做数学运算，结果将是一个复数，复数分别有实部和虚部。本章还示范了`type`函数，该函数可以确定数值的类型。

最后，人们通常使用十进制数，而Python很容易将数值转换为八进制或者十六进制。

** 本章要点： **
* Python中有3种数值类型。它们分别是：整型数，即整数（正数和负数）；浮点型数，即带小数值的数；虚数，即`-1`的平方根，经常用于工程和物理计算。
* 当用于字符串时，`+`操作符可以将两个或多个字符串串联。例如，语句`print("Hello," + "how are you?")`的结果是一句话：“Hello, how are?”。
* 可以使用`str`函数将数值转换为字符串。
* 将两个整形数相除有时可能得到一个浮点型数（例如，3/2）。用一个浮点数除一个整型数，总会得到一个浮点数。
* 取余运算符（`%`）用来返回一则除法中的余数。例如，`5%2`将返回`1`.
* 计算中使用括号可以帮助确保以正确的顺序求值。

#### 2.5 习题
在记事本中完成前3个习题，并将结果保存于文件`ch2_exercises.py`中。在Python中，可以打开文件，选择Run Moudle运行它们。
1. 在Python Shell中，将`5`和`10`相乘。并尝试其他数值。
2. 打印数字6~14的八进制形式。
3. 打印数字9~19的十六进制形式。
4. 尝试从Python解释器中引出其他错误，例如故意将`print`拼错为`pinrt`。注意，在Python Shell的文件上工作时，它以不同方式显示`print`和`pinrt`。

### 第3章 变量
在前两章中，您学习了Python如何 看待字符串、整型、浮点型和虚数，以及如何创建和显示它们。本章将给出更多的示例，说明这些数据类型的用法。

本章将介绍：
* 使用名称存储已经了解的以及即将介绍的类型。
* 如何处理还未学习的不同类型的对象，如变量以及不同的新类型，学习本章后您将更加熟悉列表、无组和字典。
* 引用的概念及示例。
* 学习本章的重点是，应当新手输入示例代码并且更改它们，观察会发生什么。

#### 3.1 引用数据——使用数据的名称
在程序中总是地写字符串和数值是非常困难的，因为这迫使程序员记住所有的字符和数值等。计算机的内存使得它可以比人记住更多的细节，利用计算机的这种能力是编程中一个很大的部分。然而，为了更灵活简单地使用数据，可以给数据命名，之后可以用名称引用这些数据。

@(**试一试**)[给名称赋值]

这些名称一般叫做变量，表明它们引用的数据可以变化，而名称保持不变。您会看到变量也叫做名称（name），这是Python的叫法。
``` python
 >>> first_string = "This is a string"
 >>> second_string = "This is another string"
 >>> first_number = 4
 >>> second_number = 5
 >>> print("The first variables are %s, %s, %d, %d" % (first_string, second_string, first_number, second_number))
 The first variables are This is a string, This is another string, 4, 5
```

** 示例说明 **

可以用等号（=）将一个值（字符串或整型数）与名称关联。所用的名称并不与所指的数据直接相关（如果将一个数据命名为“number”，并不意味着它实际保存了一个数值。）
``` python
 >>> first_string = 245
 >>> second_number = "This isn't a number"
 >>> print(first_string)
 245
 >>> print(second_number)
 "This isn't a number"
```
注意，仅希望将一个变量的值打印出来时并不需要使用引号。如果在`print()`函数中将一个变量用引号括起来，函数会打印出这个变量的名称，而不是它的内容，这是因为程序把它看做一个字符串而不是一个变量。命名数据的好处是可以赋予它一个有着某种含义的名称。给数据起一个有意义的名称非常有必要，它可以说明数据所包含的内容，或者数据在程序中的使用方式 。如果打算清点家里所有的灯泡，您也许希望有一段程序包含壁橱中的灯泡数量，另外还有一段程序包含正在使用的灯泡的数量：
``` python
 >>> lightbulbs_in_closet = 10
 >>> lightbulbs_in_lamps = 12
```
使用灯泡时，把它们从壁橱中移到灯中，还可以给今年已经扔掉的灯泡数起一个名称，这样在年终，就会知道买了多少灯泡，瑞在有多少，以及使用过多少；当想知道还有多少灯泡时，只需要引用`lightbulbs_in_closet`或者`lightbulbs_in_lamps`即可。

当名称与其存储的值相关联时，就创建了一个非正式的索引，这样就可以查询并且记住信息存储的位置，从而便于在程序中使用它们。

##### 3.1.1 使用名称修改数据
如果数据是一个数值或者是一个字符串，可以通过已经知道的一些可用的操作修改它们。

@(**试一试**)[给名称赋值]

我们学过的关于数值和字符串的所有操作都可用于变量名，这样可以像处理它们所引用的数值那样处理它们：
``` python
 >>> proverb = "A penny saved"
 >>> proverb = proverb + " is a penny earned"
 >>> print(proverb)
 A penny saved is a penny earned
 >>> pennies_saved = 0
 >>> pennies_saved = pennies_saved + 1
 >>> print(pennies_saved)
 1
 print(pennies_saved + 1)
 2
```
** 示例说明 **
无论何时，在等号的右端使用已命名的值时，即使同样的名称出现在等号的左端，Python仍将这些名称看做它们所引用的值。当Python遇到这样的情况时，它首先对右边的名称求值并计算结果，然后将结果赋给左边的名称。这样，名称同时出现在等号两端时就不再引起混乱，Python会执行正确的操作。

##### 3.1.2 复制数据
给数据起的名称仅仅是个名称，是表示要访问的数据的一种方法。这意味着可以用多个名称引用同一个数据：
``` python
 >>> pennies_saved=1
 >>> pennies_earned = pennies_saved
 >>> print(pennies_earned)
 1
```
当再次使用`=`号时，就给名称赋予了一个已创建的新值，而另一个名称仍然指向原来的值。
``` python
 >>> pennies_saved = pennies_saved + 1
 >>> print(pennies_saved)
 2
 >>> print(pennies_earned)
 1
```

##### 3.1.3 禁用的名称以及一些规则
Python把一些名称作为特殊的内置词，它保留这些词用于特殊用途以防止出现多义性。下面列出了Python的保留词，不可以将它们用作数据的名称：
``` python
 and, as, assert, break, class, continue, def, del, elif, else,
 except, exec, False, finally, for, from, global, if, import, in,
 is, lambda, not, None, or, pass, print, raise, return, try, True,
 while, with, yield
```
另外，数据的名称不能以数值或者多数非字母的字符开头（例如逗号、加减号和斜杠等），但下划线例外。下划线是合法的，甚至在某些情形下有特殊含义（特别是用于类和模块时，详见第6章以及后续章节）。

在本章后面的讨论中将会看到许多这样特殊的保留字。在使用Python完成各式各样的任务时，它们非常重要。

#### 3.2 使用更多的内置类型
除了字符串和数值之外，Python还提供了另外4种重要的基本类型：无组、列表、集合和字典。这4种类型有许多共同点，因为它们都允许在一个名称下面组织多条数据。因为具有这种组织性，每个类型都允许在它们中查找元素。这些组织在一起的数据通过圆括号`()`、方括号`[]`和花括号`{}`表示。
> 在写程序或者读别人的程序时，如果看到一组元素，注意所使用的括号的类型是很重要的。`{}`、`[]`和`()`的区别非常重要。

##### 3.2.1 元组——不可更改的数据序列
在第1章和第2章中为字符串中的多个格式说明符赋值时，看到了元组（tuple）的应用。元组是值的序列，其中每个值都可以被单独访问，元组是Python的基本类型。在创建时就可以识别出元组，因为它们被圆括号包围：
``` python
 >>> print("A %s %s %s %s" % ("string", "filled", "by a", "tuple"))
 A string filled by a tuple
```

@(**试一试**)[创建和使用元组]

元组包含对数据的引用，例如对字符串和数值的引用。然而，虽然它们引用数据，但是仍然可以像其他类型的数据一样为它们命名：
``` python
 >>> filler = ("string", "filled", "by a", "tuple")
 >>> print("A %s %s %s %s" % ("string", "filled", "by a", "tuple"))
 A string filled by a tuple
```
注意，可以通过在`print()`函数中简单地调用元组，打印出其中的数据。尝试如下代码并观察结果：
``` python
 >>> filler = ("string", "filled", "by a", "tuple")
 >>> print(filler)
 ('string', 'filled', 'by a ', 'tuple')
```
可以看到，组成元组的4个部分被返回。这种技术在每次想查看组成元组的单个部分时非常有用。

** 示例说明 **
从上面的示例可以看出，filter（包含字符串的元组）的处理方式好像是它的元素都呈现出来并且被字符串用来填充格式说明符，因为元组的处理方式就好像输入一个序列来满足给定的格式规范。

可以访问元组中的单个值。每个元素引用的值可以通过该语言的解除引用特性直接访问。通过在元组的名称后放置方括号并且从零起计算出要引用的元素的位置，可以解除元组中对值的引用。因此，元组中第一个元素的位置是`0`，第二个元素的位置是`1`，第三个元素的位置是`2`，以此类推走到最后一个元素：
``` python
 >>> a = ("first", "second", "third")
 >>> print("The first element of the tuple is %s" % a[0])
 The first element of the tuple is first
 >>> print("The second element of the tuple is %s" % a[1])
 The second element of the tuple is first
 >>> print("The third element of the tuple is %s" % a[2])
 The third element of the tuple is first
```
元组知道它所包含的元素的数目，可以使用内置函数`len`得到这个数目：
``` python
 >>> print("%d" % len(a))
 3
```
这将返回元组中元素的数目（此处是3），因此需要记住`len`函数从`1`开始计数，但当访问元组时，由于元组从`0`开始计数，所以必须在比`len`返回的数小`1`的位置停止访问。
``` python
 >>> print(a[len(a) - 1])
 Third
```
元组中的一个元素也可以是对另外一个元组的引用。换句话说，可以创建嵌套元组：
``` python
 >>> b = (a, "b's second element")
 >>> print(b)
 (('first', 'second', 'third'), "b's second element")
```
现在可以通过在第一组方括号后面加上另外一组方括号来访问元组a中的元素，访问a中的第二个元素与访问第一个元素的方法相同，仅需再添加一组方括号即可。

@(**试一试**)[通过一个元组访问另外一个元组]

重新创建元组a和b，以便观察如何通过一个元组访问另外一个元组。嵌套的序列有时也被称具有多维，因为它们是两层，可以想象纵向和横向延伸，就像图纸或者电子表格上的二维风格一样。再增加第三层元组可被认为是三维的，像一堆积木一样。可视化超过三维的多维数据会令人头痛，将它们看做多层的嵌套的数据会好一些。
``` python
 >>> a = ("first", "second", "third")
 >>> b = (a, "b's second element")
 >>> print("%s" %b[1])
 b's second element
 >>> print("%s" % b[0][0])
 first
 >>> print("%s" % b[0][1])
 second
 >>> print("%s" % b[0][2])
 third
```

** 示例说明 **
在每种情形下，代码的工作原理仿佛是先遵循元组b的第一个元素的引用，之后遵循第二层元组中的每个值的引用（第二层的元组最初来源于元组a）。如同执行了如下操作一样：
``` python
 >>> a = ("first", "second", "third")
 >>> b = (a, "b's second element")
 >>> layer2 = b[0]
 >>> print(layer2[0])
 'first'
 >>> print(layer2[1])
 'second'
 >>> print(layer2[2])
 'third'
```
注意，元组从被创建起就存在一个奇怪的地方。若要创建包含一个元素的元组，必须在该元素之后加一个逗号：
``` python
 >>> single_element_tuple = ("the sole element",)
```
否则，将会创建一个字符串，在之后试图访问它时容易混淆。

元组可以包含各种类型的数据，但在创建之后，就不能再改变。元组是不可变的，Python中还有几个类型是不可变的（例如，字符串在创建之后是不可变的，那些看起来改变它们的操作实际上创建了新的字符串）。

元组是不可变的，因为它们用来存储一组有序的事物，这些事物在使用时是不可以更改的。试图更改元组中的元素将导致Python报错，就像第2章末尾的错误一样。
``` python
 >>> a[1] = 3
 Traceback (most recent call last):
   File "<stdion>", line 1, in ?
 TypeError: object does not support item assignment
 >>> print("%s" % a[1])
 second
```
在试图给元组中的元素赋值时，可以看到Python返回的错误是`TypeError`，意思是该类型并不支持此操作（等号会引起元组执行一个动作）。在这个示例中，试图使用元组`a`中的第二个元素引用一个整型数`3`，但这个却作将不会发生。相反，`a`保持不变。

如果试图引用元组中并不存在的元素，将发生一个不相关错误。如果试图引用`a`中的第四个元素，将得到一条错误（记住，由于元组从`0`开始对它的元素计数，因此要用数字`3`来引用第四个元素。）
``` python
 >>> a[3]
 Traceback (most recent call last):
   File "<pyshell#27>", line 1, in <module>
   a[3]
 IndexError: tuple index out of range
```
注意，这是一个`IndexError`错误，并且对错误的解释也已给出（尽管它没有告诉超出范围的索引值，但确实可以知道自己试图用元组中并不存在的索引值访问其中的一个元素）。要在程序中修复该错误，必须找出试图访问的值以及元组中元素的数目。相对于不提供错误提示的语言，Python使用找出这些错误变得容易。

##### 3.2.2 列表——可以更改的数据序列
列表如同元组，是包含从`0`开始引用的元素的序列。列表用方括号创建：
``` python
 >>> breakfast = ["coffee", "tea", "toast", "egg"]
```

@(**试一试**)[查看列表中的元素]

列表中的单个元素的访问方法与元组类似。像元组一样，列表中的元素从`0`开始引用，并且访问顺序也是从`0`开始直到末端。
``` python
 >>> count = 0
 >>> print("Today's breakfast is %s" % breakfast[count])
 Today's breakfast is coffee
 >>> count = 1
 >>> print("Today's breakfast is %s" % breakfast[count])
 Today's breakfast is tea
 >>> count = 2
 >>> print("Today's breakfast is %s" % breakfast[count])
 Today's breakfast is toast
 >>> count = 3
 >>> print("Today's breakfast is %s" % breakfast[count])
 Today's breakfast is egg
```

** 示例说明 **
当顺序访问列表中的多个元素时，有必要使用一个名称来存储目前在列表中所处的位置。在简单的示例中，应当采取这种做法以形成一种 习惯，实际中则总是会这样做。通常，用循环方法查看序列中的每一个元素（第4章将详细讨论循环）。

本例中手动完成了对`count`引用的值加`1`的工作，以遍历早餐列表中的每个元素，列出本周中4在的特色早餐。因为递增计数，不论`count`引用的数是什么，它都是早餐列表中被访问的元素索引。

使用列表与使用元组主要的区别在于，元组在创建后不可以修改，列表在任何时刻者可以被修改：
``` python
 >>> breakfast[count] = "sausages"
 >>> print("Today's breakfast is %s" % breakfast[count])
 Today's breakfast is sausages
```
不仅可以修改列表中已经存在的元素，还可以向列表中添加需要的元素。可以用列表类型的内置方法`append`向列表末端添加元素。利用`append`方法每次只能向列表末端添加一个元素：
``` python
 >>> breakfast.append("waffles")
 >>> count = 4
 >>> print("Today's breakfast is %s" % breakfast[count])
 Today's breakfast is waffles
```
如果希望一次性地向列表末端添加多个元素，例如一个元组或者其他列表的内容，可以使用`extend`方法。添加的列表并不是整体地作为原有列表的一个元素，相反，其中的每个元素将被复制到原来的列表中。
``` python
 >>> breakfast.extend(["juice", "decaf", "oatmeal"])
 >>> print(breakfast)
 ['coffee', 'tea', 'toast', 'egg', 'waffle', 'juice', 'decaf', 'oatmeal']
```
同元组一样，不可以请求列表以外的元素，但是出错消息与元组略有不同，因为错误消息将指出是列表索引超出范围，而不是元组索引超出范围。
``` python
 >>> count = 8
 >>> print("Today's breakfast is %s" % breakfast[count])
 Trackback (most recent call last):
   File "<pyshell#18>", line 1, in <module>
   print("Today's breakfast is %s" % breakfast[count])
 IndexError: list index out of range
```
列表的长度也通过`len`函数确定。就像元组一样，长度从`1`开始，而列表的第一个元素的位置从`0`开始。总是记住这一点非常重要。

##### 3.2.3 字典——以名称索引的分组数据
字典类似于列表和元组。它是包含一组数据的另外一种容器。然而，元组和列表以数字顺序索引，字典却用选择的名称索引。这些名称可以是字母、数值、字符串或者符号，自己认为合适即可。

@(**试一试**)[创建字典]

字典用花括号创建。刚开始，可以创建最简单的字典，即空字典，并通过逐行指定名称和值对它进行实例化。
```python
 >>> menus_specials = {}
 >>> menus_specials["breakfast"] = "Canadian ham"
 >>> menus_specials["lunch"] = "tuna surprise"
 >>> menus_specials["dinner"] = "Cheeseburger Deluxe"
```

** 示例说明 **
当初次为`menus_specials`赋值时，用花括号创建了一个空字典。一旦字典被定义并且通过名称引用，将开始使用如下方式对其实例化：将希望作为索引的名称放在方括号内，将通过该索引引用的值放在等号的右端。因为值由所选择的名称索引，所以可以使用上述形式给已经定义的任意字典分配索引和值。

使用字典时，索引和值都有特殊的名称。字典中索引的名称叫做键，对应的值叫做值。为了创建一个完全指定（或者可以认为它是完全形成的）的字典（一开始就指定了键和值的字典），必须在花括号之间指定每个键以及和它对应的值，并以冒号分隔它们。例如，另外一天的特色菜可以一次性定义：
``` python
 >>> menu_specials = {"breakfast" : "sausage and eggs",
 ... "lunch" : "split pea soup and gralic bread",
 ... "dinner": "2 hot dogs and onion rings"}
```
为了打印出某个字典中所有的键与值，只需将字典的名称作为`print()`函数的参数，如下面的代码所求。为了访问字典中的值，可以将键放在方括号中。如果键是字符串，需要将键放在引号中。如果键是数值（可以用数值创建字典，这样的字典十分类似于列表和元组），仅使用数值就可以了。
``` python
 >>> print(menu_specials)
 {'lunch':'split pea soup and garlic bread', 'breakfast':'sausage and eggs',
 'dinner': '2 hot dogs and onion rings'}
 >>> print("%s" % menu_specials["breakfast"])
 sausage and eggs
 >>> print("%s" % menu_specials['lunch'])
 split pea soup and garlic bread
 >>> print("%s" % menu_specials["dinner"])
 2 hot dogs and onion rings
```
如果键是一个字符串，但是在方括号中意外地没有将键放在引号中，Python就试图将它看做一个名称，需要解除对它的引用来找到键。大部分情况下，这将引起`NameError`异常，除非凑巧找到了一个与该字符串相同的名称，但这时又可能得到一个`IndexError`错误。

@(**试一试**)[创建字典]

如果知道如何询问，字典可以告诉您它所有的键，或者所有的值。`keys`方法要求字典以视图的方式返回所有键，以便用户查找所需的键，`values`方法也将以视图的形式返回所有的值。
``` python
 >>> hungry=menu_specials.keys()
 >>> print(list(hungry))
 lunch
 breakfast
 dinner
 >>> starving=menu_specials.value()
 >>> print(list(starving))
 split pea soup and garlic bread
 sausage and eggs
 2 hot dogs and onion rings
```

** 示例说明 **
`key`和`values`方法都返回视图，可以像其他常规的视图一样使用这些视图并为其赋值。如果从`keys`方法得到视图中的项，可以使用视图中的项（也就是键），得到字典中与之匹配的值。注意，尽管一个特定键可以找出一个值，但是不能从一个值开始可靠地找到与该值关联的键。当根据书籍的仅有的值试图寻找键时，需要彻底测试该值所有可能的键，尽管如此，仍可能存在两个不同的键与相同的值关联的情况。

字典的工作原理是每个键都是不同的（不可以有完全相同的两个键），但是可以有多个重复的值：
``` python
 >>>menu={"breakfast": "spam", "lunch": "spam", "dinner": "Spam with a side of Spam"}
 >>>print(menu)
 {'lunch':'spam', 'breakfast':'spam', 'dinner':'Spam with a side of Spam'}
 >>> menu.get("lunch")
 'spam'
 >>> menu.get("breakfast")
 "spam"
```
可见，Python允许在不同的键下有多个值。然而，尝试如下代码并观察会发生什么，这段代码试图用同样的名称创建不同的键：
``` python
 >>>menu2={"breakfast": "spam", "breakfast":"ham", dinner":"Spam with a side of Spam:"}
 >>>menu2.get("breakfast")
 'ham'
```
这里发生了什么呢？尽管没有得到错误消息，代码中仍然有错误。当输入第二个叫做“breakfast”的键时，Python替换了相同名称的第一个键的值。

##### 3.2.4 像列表一样处理字符串

Python给字符串提供了一个有趣的特性。有时，能够将字符串当作单个字符的列表那样处理很有帮助。在字符串的末端有无关字符并不罕见。人们也许没有识别出它们，但计算机遇到它们时会挂起。仅需要看字符串的首字符就知道如何处理该字符串的情况也很常见。例如，如果有一个姓与名的列表，您可以使用与列表相同的语法查看名与姓的第一个字符。这种看待字符串的方法叫做分片（slicing），是Python比较有趣的一个特性。
``` python
 >>>last_names=["Douglass", "Jefferson", "Williams", "Frank", "Thomas"]
 >>> print("%s" % last_names[0])
 Douglass
 >>> print("%s"% last_names[0][0])
 D
 >>> print("%s" % last_names[1])
 Jefferson
 >>> print("%s"% last_names[1][0])
 J
 >>> print("%s" % last_names[2])
 Williams
 >>> print("%s"% last_names[2][0])
 W
 >>> print("%s" % last_names[3])
 Frank
 >>> print("%s"% last_names[3][0])
 F
 >>> print("%s" % last_names[4])
 Thomas
 >>> print("%s"% last_names[4][0])
 T
```
例如，可以根据字符串的字母顺序将字典中的元素以姓的首字母分组。并不需要做任何复杂的操作，只需要检查包含名字的字符串以哪个字母开头，并以此对名字归档即可。
``` python
 >>> by_letter = {}
 >>> by_letter[last_name[0][0]] = last_name[0]
 >>> by_letter[last_name[1][0]] = last_name[1]
 >>> by_letter[last_name[2][0]] = last_name[2]
 >>> by_letter[last_name[3][0]] = last_name[3]
 >>> by_letter[last_name[4][0]] = last_name[4]
```
通过使用字符串的分片功能，字典`by_letter`仅包含所有姓的首字母。因此，`by_letter`是根据每个姓的首字母索引的字典。也可以令`by_letter`中的每个键引用一个列表，并使用列表`append`方法创建以相同字母开头的一列名字（当然，前提是您希望拥有一个索引了更大的一组名字的字典，其中每个名字都以相同的字母开头）。

** 非常有用的字符串分片 **
如果刚刚接触编程，字符串分片最初看上去是一个不同寻常的特性。使用过C或者C＋＋这样的低级语言的程序员学习过如何将程序中的字符串看做特殊的列表（在Python中也可以对列表分片，如后面所示），对他们而言，这个我很自然。对于读者而言，一旦学习了如何在列表上控制元素上控制元素的重复，它将是一个非常方便的工具。

##### 3.2.5 特殊类型
Python包含几个特殊类型。前面已经介绍过它们，但在此仍有必要单独介绍：`None`、`True`和`False`都是特殊的内置值，可以在不同的时刻发挥作用。

`None`较特殊，因为仅有一个`None`。无论使用了多少镒，它都只是一个名称，除了它本身以外没有任何其他对象可与之匹配。如果函数没有可以返回的值，即当函数没有可以响应的动作时，它将返回`None`。

`True`和`False`是数值`0`和`1`的特殊表示。这就防止了在其他语言中比较常见的混乱，即一个语句的真值是任意的。例如，在Unix Shell中（Shell不仅是与系统交互的平台，也是一门程序语言），`0`是真，其他值都是假。而在C和Perl中，`0`是假，其余值是真。

然而，在这些情形中，没有内置的名称可以区分这些值。Python通过显示地命名这些值，使得区分这些值变得更容易。名称`True`和`False`可用于基本的比较，您将看到许多这样的示例。在第4章中将介绍这些比较如何显著地影响程序，实际上，它们可以用来在程序中做决策。
``` python
 >>> Ture
 True
 >>> False
 False
 >>> True == 1
 True
 >>> Ture == 0
 False
 >>> False == 1
 False
 >>> False == 0
 Ture
 >>> false > 0
 False
 >>> False < 1
 True
```

#### 3.3 序列的其他共有属性
元组和列表是两种类型的序列。前面也已介绍过，在某些情形下，可以像序列那样访问字符串。字符串是有意义的，因为可以将字符串中的字母看做一个序列。

尽管字典代表一组数据，但它们不是序列，因为它们没有一个从头至尾的特定顺序，而这是序列的一个特性。

##### 3.3.1 引用最后一个元素
所有的序列类型都提供了一些捷径，使得它们用起来更加方便。经常需要知道一个序列最后一个元素的内容，有两种方法可以得到该信息。一种方法是获取列表中元素的个数，之后使用该数直接访问值：
``` python
 >>> last_anmes = ["Douglass", "Jefferson", "Williams", "Frank", "thomas"]
 >>> len(last_names)
 5
 >>> last_element = len(last_names) - 1
 >>> print("%s" % last_names[last_element])
 Thomas
```
然而，这个方法分为两步。作为程序员，重复地在程序中输入这些代码非常耗时，Python提供了一个捷径，使得可以通过使用数值`-1`访问一个序列的最后个元素，使用数值`-2`访问倒数第二个元素，通过使用从数`-1`到负的列表长度（在`last_name`列表中是`-5`），可以将列表的顺序颠倒过来。
``` python
 >>> print("%s" % last_names[-1])
 Thomas
 >>> print("%s" % last_names[-2])
 Frank
 >>> print("%s" % last_names[-3])
 Williams
```

##### 3.3.2 序列的范围
您可以获取序列的一部分，从中提取一个片段，创建可以单独使用的一个副本。创建这些分级的方法叫做分片（与对字符串进行相同操作时所用的术语相同）。当从一个列表或者元组中创建一个片段时，得到的片段与创建该片段的数据类型一致，从字符串分片的示例中已经看到了这一点。例如，从列表中创建的片段是一个列表，从元组中创建的片段是一个元组，字符串的片段还是字符串。

@(**试一试**)[将序列分片]

前面已经学过如何将字符串分片，下面试着用同样的方法对元组、列表和字符串进行分片，并看看结果是什么：
``` python
 >>> slice_me = ("The", "next", "time", "we", "meet", "drinks", "are", "on", "me")
 >>> sliced_tuple = slice_me[5:9]
 >>> print(sliced_tuple)
 ('drinks', 'are', 'on', 'me')
 >>> slice_this_list = ["The", "next", "time", "we", "meet", "drinks", "are", "on", "me"]
 >>> sliced_list = slice_this_list[5:9]
 >>> print(sliced_list)
 ['drinks', 'are', 'on', 'me']
 >>> slice_this_string = "The next time we meet, drinks are on me"
 >>> sliced_string = slice_this_string[5:9]
 >>> print(sliced_string)
 'ext '
```
** 示例说明 **

在每种情形下，用冒号指定序列的一个片段指示Python创建一个新的序列，新序列恰好包含了片段中的元素。

##### 3.3.3 通过附加序列增长列表
假设希望将两个表连接在一起。我们还没看到专门用于这个目的的方法。不能用`append`方法将一个序列附加到另一个序列的末端，这样得到的结果是向列表中增加了一个分层的序列。
``` python
 >>> living_room = ("rug", "table", "chair", "TV", "dustbin", "shelf")
 >>> apartment = []
 >>> apartment.append(living_room)
 >>> apartment
 [('rug', 'table', 'chair', 'TV', 'dustbin', 'shelf')]
```
如果打算根据元组`living_room`的内容创建一个新的列表，并使用该列表创建包含`apartment`中所有元素的列表，以上所示并不是希望看到的结果。

为了复制一个序列中的所有元素，可以使用列表和元组的`extend`方法，而不是`append`方法，`extend`方法将给定序列中的每个元素插入到调用它的列表中。
``` python
 >>> apartment = []
 >>> apartment.extend(living_room)
 >>> apartment
 ['rug', 'table', 'chair', 'TV', 'dustbin', 'shelf']
```

##### 3.3.4 使用列表临时存储数据
经常需要从其他来源获取数据，例如，用户输入的数据或者另外一台计算机上的信息。为此，最好将这些数据存放在一个列表中，这样就可以在随后按照数据进入列表的顺序对其进行处理。

然而，在处理完 数据之后，不再需要将这些数据保存在于列表中，因为不再需要它们。特定时间有效的信息（例如证券报价信息、天气预报或者新闻标题等）都属于这类信息。

为了防止列表变得笨重，可以使用`pop`方法在处理完列表的一个数据之后，将其引用从列表中删除。当删除引用之后，它原来在列表中占据的位置会填上后续元素，列表减少的元素个数等于已经弹出的元素个数。

@(**试一试**)[从列表中弹出元素]

需要告诉`pop`方法所要操作的元素。如果告知它处理元素`0`，它将弹出列表中的第一项，向`pop`传递参数`1`告诉它使用位置`1`的项（列表中的第二个元素），依此类推。`pop`所操作的元素与使用方括号访问的列表元素具有相同的索引（记住，列表中第一个元素的位置为`0`）：
``` python3
 >>> todays_temperatures = [23, 32, 33, 31]
 >>> todays_temperatures.append(29)
 >>> todays_temperatures
 [23, 32, 33, 31, 29]
 >>> morning = todays_temperatures.pop(0)
 >>> print("This mornings temperature was %.02f" % morning)
 This mornings temperature was 23.00
 >>> late_morning = todays_temperatures.pop(0)
 >>> print("Todays late morning temperature was %.02f" % late_morning)
 Todays late morning temperature was 32.00
 >>> noon = todays_temperatures.pop(0)
 >>> print("Todays noon temperature was %.02f" % noon)
 Todays noon temperature was 33.00
 >>> todays_temperatures
 [31, 29]
```

** 示例说明 **

当弹出一个值时，如果操作是在秸的右端，可以将删除的元素赋给左边的值，或者仅在合适的情形下使用该值。如果没有将弹出的值赋给其他变量，也没所有使用它，它将被丢弃。

通过只使用`pop`填充字符串格式，也可以避免使用中间名称，因为`pop`将返回列表中的指定元素，可以像已经指定了一个数值或者引用一个数值的名称那样使用该元素：
``` python
 >>> print("Afternoon temperature was %.02f" % todays_temperatures.pop(0))
 Afternoon temperature was 31.00
 >>> todays_temperatures
 [29]
```
如果没有告诉`pop`要删除列表中的哪个元素（在上面的示例中是`0`），它将删除列表中的最后一个元素，而不是这里所示的第一个元素。

##### 3.3.5 处理集合
在Python中，集合与字典类似，只是它仅包含键，而没有与键相关联的值。本质上，集合是不包括重复数据的数据集。在从数据集删除重复数据时，集合非常有用。

有两种类型的集合：可变集合与不可变集合（frozenset）。两者的不同之处在于，对于可变集合，可以增加、删除、或者改变它的元素，而不可变集合的元素在它们被初始设定之后就不能再被更改。

@(**试一试**)[删除重复的元素]

本例中执行了赋值操作，并且通过把这些值赋给一个集合删除了重复的地元素：
``` python
 >>> alphabet = ['a', 'b', 'b', 'c', 'a', 'd', 'e']
 >>> print(alphabet)
 ['a', 'b', 'b', 'c', 'a', 'd', 'e']
 >>> alph2 = set(alphabet)
 {'a', 'c', 'b', 'e', 'd'}
```

** 示例说明 **
该示例接受数据集`alphabet`作为输入，并将其转换为一个集合。因为集合不允许重复的值，多余的字符`b`和`a`被删除。之后`alphabet`被赋给`alph2`，并且被打印以显示结果。

#### 3.4 本章小结

本章介绍了如何操作Python提供的多种核心类型。这些类型是元组、列表、字典、集合以及三种特殊类型：`None`、`True`和`False`。本章还介绍了可以将字符串当作序列处理的特殊方法。元组和列表是另外两种序列类型。

元组是从`0`开始以固定数值顺序索引的一个数据序列。元组中的引用在元组被创建后不能再改变，也不能再增加或者删除元素。然而，如果元组包含可变元素的数据类型，例如列表，该数据类型的元素是可以改变的。元组在序列中的数据不会改变时很有用，例如，当希望地阻止数据被意外改变时。

列表是另一种序列，除了它的元素可被修改之外，它与元组类似。列表的长度可以改变，以容纳使用`append`方法新增加的元素，另外也可以通过`pop`方法缩减列表的长度。如果希望将一个序列中的数据附加到一个列表中，可以使用列表的`extend`方法一次性将序列中的所有元素添加到列表中。

字典是另外一种有索引的数据分组。列表和元组以数值为索引，而字典通过所选的值索引。如果想研究这些索引（叫做键），可以调用`keys`方法。为了研究被引用的数据（叫做值），可以使用`values`方法。这两个方法都返回列表。

集合是项集（0个或者多个项），不允许包含重复的值。理论上，它们与字典类似，不过它们只包含键，而没有与键相关联的值。集合的一个用途是从数据集中去除冗余的值。它们也很擅长模仿有穷的数学集合。

其他的数据类型还有`True`、`False`和`None`。`True`和`False`是看待`1`和`0`的特殊方式，但当希望测试某件事为真还是为假时，显式地使用名称`True`和`False`总是正确的做法。`None`是Python内置的只与它自己相等的特殊值，当函数不能返回任何值（例如`True`、`False`、字符串或者其他值）时得到的返回值就是`None`。

** 本章要点 **

* 变量是用来引用数据的名称。
* 利用语法：变量名称＝“某值“，可以创建一个变量。
* 可以通过将一个变量赋给另一个变量来复制它的值：变量名称＝要复制的变量名称。
* 元组存储多个数据并且不可以更改。
* 列表也是数据序列，与元组不同的是，可以改变它们的值。
* 字典与列表和元组类似。它是另外一种数据容器类型。元组和列表以数值顺序索引，而字典通过所选择的名称索引。这些名称可以是字母、数值、字符串或符号，适合自己需要即可。

#### 3.5 习题
在Python Shell中完成如下任务：
1. 使用超市奶制品部的4个元素创建一个列表`dairy_section`。
2. 打印由`dairy_section`列表的第一个和最后一个元素组成的字符串。
3. 创建元组`milk_expiration`，它包含3个元素：最近一罐牛奶的过期日期的年、月和日。
4. 以字符串“This milk carton will expire on 12/10/2009”的形式输出元组`milk_expiration`中的值。
5. 创建空字典`milk_carton`。添加如下的键/值对。可以虚构值，也可以使用一罐真正的牛奶：
> * `expiration_date`：将它设为`milk_expiration`元组。
> * `fl_oz`：将它设为您所住所的牛奶罐的尺寸。
> * `Cost`：将它高为这罐牛奶的价格。
> * `brand_name`：将它高为使用的牛奶的品牌名称。
6. 打印字典`milk_carton`中所有元素的值，使用字典中的值，而不要使用元组`milk_expiration`中的数据。
7. 根据`milk_carton`的价格，显示如何计算6罐牛奶的价格。
8. 创建列表`cheeses`。列出可以想到的所有奶酪。将该列表附加到列表`dairy_section`中，并且相看`dairy_section`的内容。之后从中删除`cheeses`列表。
9. 如何计算`cheeses`列表中奶酪的个数？
10. 打印每个奶酪名称的前5个字母。

## 第II部分 Python语言和标准库

### 第4章 做出决策

到目前为止，我们学习了如何直接操作数据，以及如何通过与数据绑定的名称操作它们。对如何手动操作这些数据类型有了基本的理解后，就可以开始实践所学到的关于数据类型的知识，并使用数据做出决策。

本章将介绍Python如何利用`True`和`False`做出决策，以及如何根据一个条件是`True`还是`False`做出更复杂的决策。

本章将介绍：
* 如何创建可以使用循环重复相同操作的情形，以自动逐步遍历列表、元组和字典。
* 如何协同使用字典、列表和元组，以探究字典中的内容。
* 如何使用异常处理编写程序，以应对可能在程序内部处理的问题。

#### 4.1 比较两个值是否相等
第3章中出现了`True`和`False`，但没有介绍如何使用它们。`True`和`False`是比较两个值、问句以及执行其他一些操作的结果。然而，可以被赋值和命名的任何事物都可以用一组返回`True`和`False`的比较运算来比较。

@(**试一试**)[比较两个值是否相等]

用两个等号测试是否相等。记住，单个等号将数据绑定到一个名称，与这里希望执行的操作不同，这里将得出`True`和`False`：
``` python
 >>> 1 == 1
 True
 >>> 1 == 2
 False
```

** 示例说明 **

当进行相等性比较时，Python比较双等号两端的值。如果数值不同，结果为`False`。如果数值相同，结果为`True`。

即使数值类型不同，Python仍然能够比较它们并且给出正确的答案：
``` python
 >>> 1.23 == 1
 False
 >>> 1.0 == 1
 True
```
也可以用双等号来测试两个字符串的内容是否相同，甚至可以将该测试限定在字符串的某个局部范围内（回忆上一章中介绍的分片，它复制了所引用的字符串的部分内容，因此实际上比较的两个字符串代表了分片所涵盖的内容）：
``` python
 >>> a = "Mackintosh apples"
 >>> b = "Black Berries"
 >>> c = "Golden Delicious apples"
 >>> a == b
 False
 >>> b == c
 False
 >>> a[-len("apples"):-1] == c[-len("apples"):-1]
 True
```
在Python中，序列也可以用双等号比较。Python认为，如果每个序列中同一位置的每个元素都相同，那么两个序列相等。因此，如果有两个序列中分别包含4项，这4项的数据相同，但顺序不同，那么这两个序列不相等：
``` python
 >>> apple = ["Mackintosh", "Golden Delicious", "Fuji", "Mitsu"]
 >>> apple_trees = ["Golden Delicious", "Fuji", "Mitsu", "Mackintosh"]
 >>> apples == apple_trees
 False
 >>> apple_tree = ["Mackintosh", "Golden Delicious", "Fuji", "Mitsu"]
 >>> apples == apple_trees
 True
```
另外，字典也可以比较。像列表一样，一个字典中的每个键与值（一组）必须与另外一个字典中的键与值一一对应，其中第一个字典中的键与第二个字典中的键相等，第一个字典中的值也与第二个字典中的值相等：
``` python
 >>> tuesday_breakfast_sold = {"pancakes":10, "french toast":4, "bagels":32, "omelets":12, "eggs and sausages":13}
 >>> wednesday_breakfast_sold = {"pancakes":8, "french toast":5, "bagels":22, "omelets":16, "eggs and sausages":22}
 >>> tuesday_breakfast_sold == wednesday_breakfast_sold
 False
 >>> thursday_breakfast_sold = {"pancakes":10, "french toast":4, "bagels":32, "omelets":12, "eggs and sausages":13}
 >>> tuesday_breakfast_sold == thursday_breakfast_sold
 True
```

#### 4.2 比较两个值是否不相等
有一个运算与相等比较相反。如果将感叹号和等号一起使用，可以要求Python比较两个值是否不相等（使用与相等比较同样的规则），如果不相等，得到`True`值。

@(**试一试**)[用加号串联字符串]

尝试如下示例，观察Python如何对这些比较求值：
``` python
 >>> 3 == 3
 True
 >>> 3 != 3
 False
 >>> 5 != 4
 True
```
** 示例说明 **

如果一对数用`==`比较时得到`True`值，在这晨将得到`False`；如果两个数在用`==`比较时得到`False`，在这里将得到`True`。

这些规则同样适用于更加复杂的类型，如序列和字典：
``` python
 >>> tuesday_breakfast_sold != wednesday_breakfast_sold
 True
 >>> tuesday_breakfast_sold != thursday_breakfast_sold
 False
```
像数值一样，这些类型当用`==`比较为`True`时，在用`!=`比较时将为`False`。

#### 4.3 比较两个值的大小
相等性比较并不是找出希望知道的信息的唯一方法。有时，希望了解某物的数量是否大于另外一个，或者某个值是否小于另外一个值。Python提供了大于和小于运算，可以用`>`和`<`进行调用。这些符号与数学书上介绍的符号相同，用于比较左边的值是否大于（>）或者小于（<）右边的值。

@(**试一试**)[比较大于和小于]

``` python
 >>> 5 < 3
 False
 >>> 10 > 2
 True
```

** 示例说明 **

左边的值与右边的值进行比较。也可以比较字母。在某些条件下，这些比较运算也许会得出意外的结果，例如尝试比较字母和数值（这个问题在许多情形下不会发生，所以您的期望与Python的期望不尽相同）。字母表中字母的值大概以这样的方式排序：大写的“A”是最小的字母，之后“B”，之后是“C”一直到“Z”。随后是小写字母，其中“a”是最小的小宝字母，“z”是最大的小写字母。然而，“a”大于“Z”：
``` python
 >>> "a" > "b"
 False
 >>> "A" > "b"
 False
 >>> "A" > "a"
 >>> "b" > "A"
 True
 >>> "Z" > "a"
 False
```
如果希望比较两个包含多个字符的字符串，Python将观察每个字母，走到找到一个不同的字母为止。比较的结果将取决于不同的字母。如果两个字符串完全不同，第一个字母就将决定结果：
``` python
 >>> "Zebra" > "aardvark"
 False
 >>> "Zebra" > "Zebrb"
 False
 >>> "Zebra" < "Zebrb"
 True
```
通过使用字符串的特殊方法`lower`，可以避免比较两个相似单词由于大小写不同而引起的问题，`lower`方法可以将调用它的字符串中的所有字母都变为小写，然后返回一个新字符串。还有一个对应的`upper`方法。它们适用于Python中的所有字符串：
``` python
 >>> "Pumpkin" == "pumpkin"
 False
 >>> "Pumpkin".lower() == "pumpkin".lower()
 True
 >>> "Pumpkin".lower()
 'pumpkin'
 >>> "Pumpkin".upper() == "pumpkin".upper()
 True
 >>> "pumpkin".upper()
 'PUMPKIN'
```
注意，也可以用如下方式编写上述代码：
``` python
 >>> "Pumpkin".lower() == "pumpkin"
 True
```
由于“pumpkin”已经是小写的，就没有必要再改变它，尽管这样做可能更安全。例如。如果某人错误地输入了一个字符串，将字符串中的某个字母大写，将两者都进行大小写转换可以避免一些错误。观察如下代码：
``` python
 >>> "Pumpkin".lower() == "puMpkin"
 False
 >>> "Pumpkin".lower() == "puMpkin".lower()
 True
```
当通过名称引用字符串时，仍旧可以访问字符串通常具有的所有方法：
``` python
 >>> gourd = "Calabash"
 >>> gourd
 'Calabash'
 >>> gourd.lower()
 'calabash'
 >>> gourd.upper()
 'CALABASH'
```

** 大于等于和小于等于 **

大于和小于各有一个有用的变体，即大于等于和小于等于。以某种方式将两个符号结合使用时显得很有意义：
``` python
 >>> 1 > 1
 False
 >>> 1 >= 2
 False
 >>> 10 < 10
 False
 >>> 10 <= 10
 True
```

#### 4.4 对真值和假值取反
在创建一种情形并比较其结果时，有时希望知道结果是否为真，有时希望知道结果是否不为真。Python提供了一个操作来实现相反的情形：使用单词`not`将会对它后面的值取反。

@(**试一试**)[对测试的结果取反]

``` python
 >>> not True
 False
 >>> not 5
 False
 >>> not 0
 True
 >>> Not True
 SyntaxError: invalid syntax (<pyshell#30>, line 1)
```
注意最后一行代码中的错误。一定不要将`not`运算符大写，否则将得到一条与此处类似的错误消息。

** 示例说明 **
`not`运算符用于任何得出`True`或者`False`结果的测试中。然而，第3章中提到，任何非零值都被看做`True`，因此可以在预期之外或者不一定有意义的情形下使用`not`：
``` python
 >>> not 5 > 2
 False
 >>> not "A" < 3
 True
 >>> not "A" < "z"
 False
```

#### 4.5 观察多个比较运算的结果
也可以将多个运算的结果合并，这使得程序可以通过多个运算求真值，做出更加复杂的决策。

一种组合是`and`运算，它的含义是：“如果左边的运算、值或者对象为`True`，接着对右边求值。如果左边不为`True`，就停止运算并且输出结果`False`，不再继续运算。”

``` python
 >>> True and True
 True
 >>> False and True
 False
 >>> True and False
 False
 >>> False and False
 False
```
另外一种组合运算是`or`运算。使用`or`告诉Python对左边的表达式求值，如果它为`False`，Python将继续对右边的表达式求值。如果它为`True`，Python将停止对更多的表达式求值：
``` python
 >>> True or True
 True
 >>> True or False
 True
 >>> False or True
 True
 >>> False or False
 False
```
您也许想基于希望发生的动作将多个这样的运算放在一起。这些情形下，从最最左边的`and`或者`or`开始求值，根据之前的规则继续对后续运算求值——换言之，直到在`and`运算中求出`False`值，或者在`or`运算中求出`True`值。

** 如何做出决策 **
Python有一种非常简单的做出决策的方法。用于做出决策的保留字是`if`，它后面跟着一个判断条件是否为真的测试，该测试以冒号结束，所以在这里可以看到它被写作`if ... :`。它可用于求值为`True`和`False`的任何情形，表示“如果某条件为真，执行以下操作”：
``` python
 >>> if 1 > 2:
 ...    print("No it is not!")
 ...
 >>> if 2 > 1:
 ...    print("Yes it is!")
 ...
 Yes, it is!
```
仅当`if`和冒号之间的语句的值为`True`时，缩进的语句才会被Python访问并求值。`if`语句中的缩进表明接下来的代码虽然是程序的一部分，但只有在合适的条件发生时才被执行。对于`if ... :`语句，合适的条件是指当比较运算的结果为`True`时。

您已经看到了`Python`在代码表现中最具有特色的一面，这也是大部分人在使用Python时容易发表评论的一个方面。

在Python程序中看到冒号时，它指出Python进入了程序中与其余部分相对独立的一部分。此时，缩进变得很重要。Python通过缩进知道一个特定的代码块与周围的代码保持独立。所用的空格数很重要，面向Python的代码编辑器总是帮助保持正在编写的代码具有正确的缩进。空格数很重要，因此应该使用编辑器确定缩进，并且不要手动改变空格数。

后面将看到更多的与冒号成对出现的关键字；在这些情形下，需要注意缩进。当程序改变了缩进，导致Python无法理解时，它会显示一个错误。

也可以将一个`if ... :`语句放在另外一个`if ... :`语句中，以做出比使用`and`和`or`更加复杂的决策，因为使用`if ... :`可以在对缩进的`if ... :`语句求值之前执行任意一组需要的语句。

@(试一试)[在测试中嵌套测试]

尝试如下示例，其中一个`if ... :`语句出现在另一个当中：
``` python
 >>> omelet_ingredinents = {"egg":2, "mushroom":4, "pepper":1, "cheese":1, "milk":1}
 >>> fridge_contents = {"egg":10, "mushroom":20, "pepper":3, "cheese":2, "tomato":4, "milk":15}
 >>> have_ingredients =[False]
 >>> if fridge_contents["egg"] > omelet_ingredinents["egg"]:
 ...    have_ingredients[0] = True
 ... have_ingredients.append("egg")
 ...
 >>> print(have_ingredients)
 [True, 'egg']
 >>> if fridge_coutents["mushroom"] > omelet_ingredients["mushroom"]:
 ...    if have_ingredients[0] == False:
 ...        have_ingredients[0] = True
 ...    have_ingredients.append("mushroom")
 ...
 >>> print(have_ingredients)
 [True, 'egg', 'mushroom']
```

** 示例说明 **

当一个条件经`if ... :`测试之后，如果还有下一级缩进，Python将继续对在该缩进中放置的代码求值。如果第一个`if ... :`不为真，它下面的任何代码都不会被求值，而将被完全跳过。

然而，如果第一个`if ... :`语句为真，同级的第二个条件将被计算。比较的结果仅决定它下面缩进的代码是否即将被执行。同级别的以及上层代码不会停止，除非有一些特殊的事件发生，例如，一个错误或者一个阻止程序继续运行的条件。

如从`print()`函数看见的那样，当Python检查发现冰箱里的鸡蛋和蘑菇多于煎蛋卷配方所需的鸡蛋和蘑菇时，就会将这两项添加到`have_ingredients`变量中。

为了完成示例，可以输入如下代码（如果希望用计算机表示一个煎蛋卷的话）：
``` python
 >>> if fridge_contents["pepper"] > omelet_ingredients["pepper"]:
 ...    if have_ingredients[0] == True:
 ...        have_ingredients[0] = False
 ...    have_ingredients.append("pepper")
 ...
 >>> if fridge_contents["cheese"] > omelet_ingredients["cheese"]:
 ...    if have_ingredients[0] == False:
 ...        have_ingredients[0] = True
 ...    have_ingredients.append("cheese")
 ...
 >>> if fridge_contents["milk"] > omelet_ingredients["milk"]:
 ...    if have_ingredients[0] == True:
 ...        have_ingredients[0] = False
 ...    have_ingredients.append("milk")
 ...
 >>> if have_ingredients[0] == True:
 ...    print("I have the ingredients to make an omelet!")
 ...
 I have the ingredients to make an omelet!
```
可以以`if ... :`开头，使用`elif ... :`创建一个测试链。`elif ... :`仅当前面的条件不满足时，才允许测试多个条件。如果使用一系列的`if ... :`语句，它们将被执行。如果在`if ... :`后面使用一个`elif ... :`语句，那么`elif ... :`仅在`if ... :`语句返回`False`时被求值。
``` python
 >>> milk_price = 1.50
 >>> if milk_price < 1.25:
 ...    print("Buy two cartons of milk, they're on sale")
 ... elif milk_price < 2.00:
 ...    print("Buy one carton of milk, prices are normal")
 ... elif milk_price > 2.00:
 ...    print("Go somewhere else! Milk costs too much here")
 ...
 Buy one carton of milk, prices are normal
```
还可以插入一个贯穿`（fall-throught）`语句来处理之前的所有测试都滑的返回`True`的情形：
`else:`语句。如果`if ... :`和`elif ... :`语句都没有值为`True`的测试条件，`else:`语句将被调用：
``` python
 >>> OJ_price = 2.50
 >>> if OJ_price < 1.25:
 ...    print("Get one, I'm thirsty.")
 ... elif OJ_price <= 2.00:
 ...    print("Ummm... sure, but I'll drink it slowly.")
 ... else:
 ...    print("I don't have enough money. Never mind.")
 ...
 I don't have enough money. Never mind.
```

#### 4.6 循环
您已经看到有很多次都需要检查和比较序列或字典中的每个元素。手动完成这项工作异常乏味，而且难免出错，即使是一个打字飞快的打字员也不例外。而且，如果手动输入这些代码，将不可避免地发生输入错误，并且当正在计算的某些变量或者值在其他地方被更改时，手动输入的代码很难相应地做出改变。

为了执行重复的任务，Python提供了两种循环运算。两者很相似，实际上，它们几乎是等同的，但是每一种运算都从不同的角度考虑问题，因此应该同时掌握这两种运算。

##### 4.6.1 重复执行操作
可以启动和控制重复任务的两种运算是`while`和`for`。`while`运算测试一个条件的真值，因此表示为`while ... :`。`for`运算使用一个列表中的所有值，因此表示为`for ... in ... :`。

`while ... `运算首先检查它要测试的条件（位于`while`与`:`之前的`...`），如果条件为`True`，它将首次对其缩进的语句求值。当它到达缩进的代码块（该代码块也可以包含其他的缩进代码块）的末尾时，将再一次对测试条件求值，看其是否仍旧为`True`。如果是，再一次重复动作；然而，如果为`False`，Python将离开缩进的部分，并继续计算程序中`while ... :`之后的部分。如果在测试条件中用到了名称，在第一次循环和下一次循环之间（再下一次，等等），这个名称引用的值可能会发生变化，直到某些可以让程序停止的因素出现。

@(试一试)[使用while循环]

``` python
 >>> i = 10
 >>> while i > 0:
 print("Lift off in:")
 print(i)
 i = i - 1

 Lift off in:
 10
 Lift off in:
 9
 Lift off in:
 8
 Lift off in:
 7
 Lift off in:
 6
 Lift off in:
 5
 Lift off in:
 4
 Lift off in:
 3
 Lift off in:
 2
 Lift off in:
 1
```
** 示例说明 **
之前的代码创建了一个名为`i`的变量，并且给它赋值`10`（注意，该变量可以使用任何合法的名称）。接下来，创建了`while`循环，表明“当`i`的值大于`0`时，执行如下操作”。之后让Python打印语句`Lift off in:`，并输出`i`的当前值。最后，每次循环都将`i`减`1`，导致该序列一次又一次地执行，直到`i`的值等于`0`。

如之前所求，用`for ... in ... :`形式的循环可以实现相同的结果，它和`while ... :`非常相似，但省略了一些步骤。在第一部分`for ...`中，同样赋予一个变量名称（再一次使用`i`，这种做法很常见，因为`i`是`index`的缩写）。在第二部分`in ... :`中，提供了一个序列，例如一个列表、元组或者这里所用的`range`，可以取出`range`中的每个元素并将它的值赋给第一部分给定的变量名称：
``` python
 >>> for i in range(10, 0, -1):
 print("T-minus: ")
 print(i)
 ...
 T-minus:
 10
 T-minus:
 9
 T-minus:
 8
 T-minus:
 7
 T-minus:
 6
 T-minus:
 5
 T-minus:
 4
 T-minus:
 3
 T-minus:
 2
 T-minus:
 1
```
可以看到，这个循环与`while`循环的工作方式类似，得到了几乎相同的结果（如果没有改变打印的文本的话，它将返回与`while`完全一致的结果）。这个版本的`for`循环稍微有点复杂。如下代码所示为一个简单的版本：
``` python
 >>> for i in range(10):
 print(i)
 ...
 1
 2
 3
 4
 5
 6
 7
 8
 9
```
这里简单地告诉`for`循环不停地迭代以重复整个过程，直到`i`等于`10`。因为使用了`range`，它自动给变量加`1`，导致程序运行一次之后又循环了`9`次。

##### 4.6.2 终止循环

术语“无穷循环”指的是一段永远重复的代码。一个简单的例子是设置`while ... :`语句，让它测试一个永远为`True`的条件。例如，仅使用`True`就可以实现这种效果。观察如下代码即可，不要直接输入它们：
``` python
 >>> while True:
 ...    print("You're going to get bored with this quickly")
 ...
 You're going to get bored with this quickly
 You're going to get bored with this quickly
 You're going to get bored with this quickly
 You're going to get bored with this quickly
 You're going to get bored with this quickly
```
上面的代码会一直继续下去，走到中断它。初看起来让某个操作一直重复不太方便，但有时可能希望如此，例如，在程序中使用一段循环代码等待用户输入，当用户输入完毕后，返回等待。

然而，有时希望知道某些特定的条件是否满足，例如，一天的某个恰当的时间是否到来，水是否用完，是否没有足够的鸡蛋做煎蛋卷等等，这时循环可以被打断，即使在`while ... :`顶部没有显式的测试，或者`for ... in ... :`中正在使用的列表没终点。

可以使用`break`语句退出无穷循环。尝试下面的代码，并确保缩进与这里显示的缩进匹配：
``` python
 >>> age = 0
 >>> while True:
 how_old=input("Enter your age: ")
 if how_old=="No":
     print("Don't be ashamed of your age!")
     break
 num=int(how_old)
 age=age+num
 print("Your age is :")
 print(age)
 print("That is old!")
 ...
 Enter your age: 1
 Your age is :
 1
 That is old!
 Enter your age: 2
 Your age is :
 3
 That is old!
 Enter your age: -3
 Your age is :
 0
 That is old!
 Enter your age: 50
 Your age is :
 50
 That is old!
 Enter your age: No
 Don't be ashamed of your age!
 >>>
```
在上面的程序中，`while`总是等于`True`，因此，如果不加处理的话，`while True`语句将一直循环下去。为了解决这个问题，给用户提示了一些信息，这里提示的是年龄。只要他们输入一个数，程序就会将输入的数加到他们的年龄中，显示一个总的年龄，使得看起业他们都变老了（除非他们很机智，输入一个负数，这种情况下他们才会变年轻！）。如果他们仅仅输入数值，程序将一直运行下去。然而，如果他们输入一个字符串`No`，程序将打印“Don't be ashamed of your age!”，然后退出循环。

注意`print`语句和`break`语句的位置。如果将`print`放在`break`之后而不是之前，那么程序每次循环时它都执行，而不是仅在退出循环的时候执行。因此要注意语句放置的位置！

如果使用`break`，它仅从最近的一个循环中退出。如果有一个`while ... :`循环，它包含一个缩进的`for ... in ... :`循环，`for ... in ... :`中的`break`将不会退出`while ... :`循环。

`while ... :`和`for ... in ... :`循环在末端都可以有一个`else:`语句，但它仅在循环不是由`break`语句退出时才会被运行。这种情形下，`else:`叫做`done`或者`on_completion`之类的名称可能更合适一些，但是`else:`是一个较方便的名称，因为前面已经见到过它，并且它也不难记住。

@(试一试)[循环时使用else]

``` python
 >>> for food in ("pate", "cheese", "crackers", "yogurt"):
 ...    if food == "yogurt":
 ...        break
 ... else:
 ...     print("There is no yogurt!")
 ...
 >>> for food in ("pate", "cheese", "crackers"):
 ...    if food == "yogurt":
 ...        break
 ... else:
 ...     print("There is no yogurt!")
 ...
 There is no yogurt!
```

** 示例说明 **
每个示例中，都有一个测试判断是否还有酸奶。如果有，`while ... :`会用一个`break`终止。然而，在第二个循环中，列表中没有酸奶，因此当循环到达列表尾部时将终止，`else:`条件会被调用。

循环还有另外一个常用的特征：`continue`语句。使用`continue`可以告诉Python并不希望循环终止，而是希望跳过当前循环的剩余部分，如果当前是在`for ... in ... :`循环中，条件和列表要被重新求值以进行下一轮循环。

@(试一试)[用continue继续循环]

``` python
 >>> for food in ("pate", "cheese", "rotten apples", "crackers", "whip cream", "tomato soup"):
 ...    if food[0:6] == "rotten":
 ...        continue
 ...    print("Hey you can %s" % food)
 ...
 Hey, you can eat pate
 Hey, you can eat cheese
 Hey, you can eat crackers
 Hey, you can eat whip cream
 Hey, you can eat tomato soup
```

** 示例说明 **
因为使用了一个`if ... :`测试来判断`food`列表中每一项的第一部分是否包含字符串“rotten”，所以“rotten apples”元素会被`continue`跳过，而共余的内容将被打印出来，表示可以安全食用。

#### 4.7 处理错误

第2章和第3章中已经介绍了Python如何报告错误。错误通常包含大量与发生的错误和失败的原因有关的信息：
``` python
 >>> fridge_contents = {"egg":8, "mushroom":20, "pepper":3, "cheese":2, "tomato":4, "milk":12}
 >>> if fridge_contents["orange juice"] > 3:
 ...    print("Sure, let's have some juice!")
 ...
 Traceback (most recent call last):
   File "<pyshell#3>", line 1, in <module>
     if fridge_contents["orange juice"] > 3:
 KeyError: 'orange juice'
```
噢！目前冰箱中没有橘子法，但如果不用终止程序就能知道这一信息会好一些。

前面已经介绍了一种找出字典中出现的所有键的方法，可以使用字典的`keys`方法，然后在返回的键列表中搜索，以判断某个希望的键是否出现。然而，没有理由不采用捷径。上述代码中的最后一行显示的错误是：
``` python
 KeyError: 'orange juice'
```

这说明Python遇到错误与字典`fridge_contents`中的键相关。可以利用Python指出的错误让程序防范这一类错误。可以用特殊词`try:`告诉Python要做好出错的准备。

** 使用try：语句 **

`tyr:`语句设立了这样一种情形，其中`try:`语句后面可以跟一个`except:`语句。每个`expect:`语句都处理错误，错误也被正式地称作异常，当Python对`try:`语句中的代码求值时会抛出异常，而不是使用程序失败。首先使用`except:`处理一种类型的错误，例如在试图检查冰箱时得到 的`KeyError`错误。

有多种类型的异常，每个异常的名称都反映了发生的问题，并且也有可能同异常所发生的条件。因为字典有键与值，`KeyError`表示正在向字典请求的的键不存在。类似地，一个`TypeError`表明Python期待某种类型的数据（例如，一个字符串或者一个整型值），但是提供给它的却是另外一种不能满足要求的类型。

另外，当异常发生时，可以访问原本在交互运行程序的时候程序停止时会看到的消息。

学到更多知识后，在需要的条件下，您将能够定义自己的异常类型。

只有一行代码用于处理错误，这看起来很受限制，但第5章将介绍如何编写自己的函数，这样可以更加灵活地处理错误。
``` python
 >>> fridge_contents = {"egg":8, "mushroom":20, "pepper":3, "cheese":2, "tomato":4, "milk":13}
 >>> try:
 ...    if fridge_contents["orange juice"] > 3:
 ...        print("Sure, let's have some juice!")
 ... except KeyError:
 ...    print("Awww, there is no juice. Let's go shopping!")
 ...
 Aww, there's no juice. Lets go shopping
```
您也许发现需要打印关于错误本身更多的信息，这些信息是可以访问的。

@(试一试)[创建异常以及对异常的说明]

``` python
 >>> fridge_contents = {"egg":8, "mushroom":20, "pepper":3, "cheese":2, "tomato":4, "milk":13}
 >>> try:
 ...    if fridge_contents["orange juice"] > 3:
 ...        print("Sure, let's have some juice")
 ... except (KeyError) as error:
 ...     print("Woah! there is no %s" % error)
 ...
 Woah! There is no 'orange juice'
```

** 示例说明 **

因为在字典`fridge_contents`中没有键“orange juice”，Python抛出了一个`KeyError`异常，说明没有这样的键。除此之外，还指定了名称`error`，Python将用它引用一个字符串，该字符串包含了Python可以提供的错误信息。我们通过`as`关键字将`KeyError`的值赋给`error`。在这种情形下，字符串与已请求但未在字典`fridge_contents`中出现的键有关（这里是“orange juice”）。

有时也许会用相同的方式处理多种错误，在这种情况下，可以用一个元组包含有关的所有异常类型：

``` python
 >>> fridge_contents = {"egg":8, "mushroom":20, "pepper":3, "cheese":2, "tomato":4, "milk":13}
 >>> try:
 ...    if fridge_contents["orange juice"] > 3:
 ...        print("Sure, let's have some juice")
 ... except (KeyError, TypeError) as error:
 ...    print("Woah! There is no %s" % error)
 ...
 Woah! There is no 'orange juice'
```
如果需要处理一个异常，但是希望以什么都不做的方式处理它（原因可能是故障不严重），Python允许通过特殊词`pass`忽略这种情形：
``` python
 >>> fridge_contents = {"egg":8, "mushroom":20, "pepper":3, "cheese":2, "tomato":4, "milk":13}
 >>> try:
 ...    if fridge_contents["orange juice"] > 3:
 ...        print("Sure, let's have some juice")
 ... except (KeyError) as error:
 ...     print("Woah! There is no %s" % error)
 ... except (TypeError):
 ...     pass
 ...
 Woah! There is no 'orange juice'
```
还有一个`else:`语句可以放在`try:`代码块的末端。在没有捕获到任意异常时，它将被执行。如前所述，`else`这个名称的描述性可能不如“in case it all works”或“all_clear”这样的名称，但是到现在已经可以看到，`else:`可以处理各种情况的一种灵活的机制，表示“如果某事发生，则如何处理”。在需要时，随时可以使用它。

#### 4.8 本章小结

本章介绍了Python提供的做出决策的方法。任意得出`True`或者`False`结果的运算，都可以用`if ... :`语句中来判断一个程序是否要对一段缩进的代码求值。

缩进在Python中扮演着重要的角色。即使在交互的Python Shell中，缩进中的空格数也很重要。

本章讨论了在循环中使用序列和字典中元素的知识。通过使用循环，可以对一个列表的每个元素执行运算并且根据每个列表元素做出决策。

Python提供了两种 类型的循环，分别是`while ... :`循环和`for ... in ... :`循环。它们持续执行相似的工作，走到某个条件导致它们结束。两者的区别在于允许它们对缩进的代码块求值的条件不同。`while ... :`循环在它的测试中只测试是`True`还是`False`，而`for ... in ... :`循环将接受在`in ... :`部分提供的序列，序列中的第一个到最后一个元素将被赋给`for ...`部分中提供的值。

这两种类型的重复循环在它们的测试条件满足之前，可以通过`break`语句退出。Break语句导致正在执行的循环停止，不再对循环的代码块中其余的代码求值。然而，如果执行一个`break`语句，循环中可选的`else:`条件将不被执行。除了`break`之外，还有一个`continue`语句，它将跳过当前循环的剩余部分，然后返回到循环的顶部并对下一个测试条件求值。

本章还介绍了其他类型的做出决策的方法，即处理Python用来报错的异常。如果没有处理异常，错误会导致程序在出错的地方停下来。然而，如果将可能会导致错误的代码缩进并放到`try:`的下面，就可以阻止程序退出，甚至可以处理错误并且使程序继续运行。在`except ... :`语句中指定预计会碰到的错误，其中，提供的第一个值定义了错误的类型（如果提供的是错误类型的元组，就是多个错误类型）；也可以选择在该值的后面提供词`as`，以及用来引用包含错误信息的数据的名称。

** 本章要点： **

* 可以用两个等号（==）测试相等性。如果答案是`True`，则返回`True`。如果是`False`，则返回`False`。双等号也可以用来判断两个变量是否保存相同的数据。
* 如果希望知道两个值是否不等，可以使用不等运算符（`!=`）。在这种情形下，`True`表示被比较的两个值不相等，`False`表示被比较的值是相等的。
* 为了比较两个值的大小，可以分别使用大于（`>`）和小于(`<`)运算符。如果需要知道一个值是否大于等于或者小于等于另外一个值，可以使用大于等于运算符（`>=`）或者小于等于运算符（`<=`）。
* 如果希望程序根据一个值为`True`还是为`False`做出决策，可以使用`if`语句，它简单地表明，如果这个值为`True`，就执行下面的操作。为了让程序在一个值为`True`时执行一种操作，而在该值为`False`时执行另一种操作，可以使用`if ... elif ...`语句。
* 有时需要将一个特定的动作循环很多次。使用`while`循环时，只要条件为`True`，就会一直重复或者抚今追昔某个动作，或者照字面意思讲，当该条件为`True`时执行如下操作。
* 如果需要将某个动作循环指定的次数，可以使用`for`循环，它用一个循环计数器指定要将一个给定的动作重复多次。
* `try:`语句后面可以跟一个`except:`语句。每个`except:`语句都处理错误，错误的正式名称是“异常”。Python在计算`try:`语句中的代码时会抛出异常，而不是简单地失败。

#### 4.9 习题
在Python Shell的代码编辑器中执行下列任务：
1. 用一系列的`if ... :`语句，通过创建5个单独的测试计算从`0～4`的数值是`True`还是`False`。
2. 用一个`if ... :`语句创建一个测试，指出某个值是否包含在`0～9`之间（可以是`0`或者`9`），如果是，则打印一条信息。
3. 使用`if ... :`、`elif ... :`、`else:`，创建一个测试，检查一个名称引用的值是否在一个序列的前两个元素中。用`if ... :`测试序列的第一个元素，用`elif ... :`测试序列中第二个元素的值，然后使用`else:`语句打印一条消息，指出正在查询的元素是否存在于序列中。
4. 创建一个字典，它包含一个虚构的电冰箱中的食物，将字典命名为`fridge`。食物的名称作为键，每个食物项的值是一个字符串，描述了该食物。创建一个名称，引用包含食物名称的字符串。将该名称叫做`food_sought`。对于字典`fridge`中的每个键和值，用`for ... in ... :`循环测试冰箱中包含的每个键，将习题3中的测试修改为简单的`if ... :`测试（这里不需要`elif ... :`或者`else:`）。如果找到一个匹配，打印出包含这个键与值的消息，并使用`break`退出循环。在`for`循环的末端用一个`else ... :`语句打印当元素没有找到时的消息。
5. 修改习题3，使用`while ... :`循环创建一个单独的叫做`fridge_list`的列表，这个列表将包含`fridge.keys`给出的值。同样地，使用叫做`current_key`的变量，引用循环中由`fridge_list.pop`得到的当前元素的值。记住将`fridge_list.pop`放到`while ... :`循环的最后一行，这样循环将正常结束。在`while`循环的末尾使用与习题3的末尾相同的`else:`语句。
6. 用一个不存在的键查询习题3中创建的字典`fridge`，引起一个错误。在这样的情况下，`KeyError`可被用来判断您希望的值是否存在于列表中。修改习题3的解决方法，使用`try:`代码块而不是`for ... in ... :`。

### 第5章 函数
目前，每次希望完成一项任务时，需要输入所有的程序代码来完成工作。如果需要再次做相同的工作，可以将整个程序重新输入一遍或者将代码放在一个循环中。循环在重复操作时非常有用，但是只是略做了一些小修改，就在程序的不同部分重复写相同的循环，这并不是明智的做法。

Python的函数可以将代码段聚集到方便的分组中，在需要的时候可以再次调用它们。

本意将介绍：
* 如何创建和使用函数。
* 给出一些指导原则，帮助思考如何创建和组织程序以使用函数。
* 如何编写函数，使随后可以询问它们的工作方式和实现的功能。

#### 5.1 将程序放在单独的文件中
当本书中的示例变长时，输入整个代码块开始变成负担。一个错误将导致要重新输入整块代码。在遇到多于40行的代码要输入时，您不会再想输入相同的代码。

程序员将所写的程序作为源代码存入文件，这些文件可以被方便地打开、编辑和运行。

为了更加方便，从现在开始，您应当在Python的代码编辑器中输入正在使用的程序，并将本书的示例都放到一个文件中，以便以后引用和运行这些示例。一个可靠的建议是将该目录命名为“Learning Python”，之后能够以程序出现的章节命名它们。

可以执行两种操作使程序易于运行。所有Python文件的第一行应该如此：
``` python
 #!/usr/bin/env python 3.1
```
如果遵循本书附录中的说明，这行代码使得UNIX和Linux系统可以运行这些脚本。第二件要做的重要的事情是给所有的Python文件起一个以`.py`为扩展名的名称。在Windows系统上，这将给操作系统提供信息，以便使用操作系统将这些文件当作Python文件启动，而不是仅把它们当作普通的文本文件。例如，如果把前面章节的示例放到自己的文件中，会有一个包含如下文件的文件夹：
```
chapter_1.py
chapter_2.py
chapter_3.py
chapter_4.py
chapter_5.py
```
将第一个程序保存到文件后，代码编辑器开始以不同的颜色和样式显示程序中的某些部分以强调它们。内置的函数和保留字以一种方式处理，字符串以另外的方式处理，而一些关键字又会采用另外一种处理方式。然而，文件中的大部分文本都还是普通的黑色和白色，如图5－1所示。
![图5-1](https://i.loli.net/2019/05/04/5ccd6a69f37a3.png)
使用这些文件后，只输入一次示例即可。当输入一个例子并且保存它之后，可以用`python -i <filename>`运行它。`-i`告诉Python读取程序文件，然后允许您继续与Python交互，而不是立刻退出（这是Python通常的做法）。在代码编辑器中，可以通过从`File`菜单选择`Run with Interpreter`自动完成这种设置。

@(试一试)[利用`-i`在Python中运行程序]

为了说明如何利用`python -i`或者`Run with Interpreter`，向名为`ch5-demo.py`的文件中输入如下代码：
``` python
 #!/usr/bin/env python 3.1
     a = 10
 b = 20

 print("A added to B is %d" % (a + b))
```
当用`-i`选项调用Python时，将处于一个如下所示的Python交互会话中：
``` python
 A added to B is 30
 >>>
```

** 示例说明 **

文件`ch5-demo.py`中的代码被计算后，可以继续操作`a`与`b`的值，也可以对它们进行扩展，就像手动输入一样。当示例变长时，这将节省时间。后面的一些代码可能首先在Shell中展示，但是可以保存以便以后运行。另外一些出现在文件中的代码，可以保存和运行。之所以使用文件展示程序，原因可能是书中讨论的内容没有很好地表现一种思想，所以最好使您做一些额外的工作 ，一次又一次地输入相同的代码，或者实际与程序交互。也可能是因为程序太长，在需要对其测试时，使用文件就不用一次次地重复输入。

#### 5.2 函数：在一个名称下聚焦代码
大多数现代程序语言都提供了将代码聚焦在一个名称下的功能，不论何时使用这个名称，它包含的代码将被调用和运算，从而不需要每次都重新输入它们。

为了创建一个包含代码的命名函数，可以使用`def`，它可以定义一个代码功能块。

@(试一试)[定义一个函数]

尝试将下面的代码保存到第5章的文件`ch5.py`中。
``` python
 def in_fridge():

     try:
         count = fridge[wanted_food]
     except KeyError:
         count = 0
     return count
```

** 示例说明 **

当调用`ch5.py`（在代码编辑器中按下`F5`）时，若其中只定义了`in_fridge`函数，则不会看到任何输出。然而，该函数将定义，并且可以从已创建的交互式Python会话中调用。

为了使用`in_fridge`函数，必须确保有一个包含各种食物名称的`fridge`字典。另外，必须有一个名为`wanted_food`的字符串。使用`in_fridge`时，可以通过该字符串询问是否有某种食物。因此，在交互式的会话中，可以用该函数做如下的事情：

``` python
 >>> fridge = {'apples':10, 'oranges':3, 'milk':2}
 >>>wanted_food = 'apples'
 >>> in_fridge()
 10
 >>> wanted_food = 'oranges'
 >>> in_fridge()
 3
 >>> wanted_food = 'milk'
 >>>in_fridge()
 2
```
这不仅有用，而且十分有意义，可以减少工作量。在一个名称下聚焦代码块意味着可以简化代码，从而以更快的速度完成更多的工作。输入量减少了，出错的机率也就降低了。

函数是任意现代程序语言的核心部分，它们也是利用Python解决问题的关键。

编写程序时，函数可以看做是一个问与答的过程。当它们被调用时，经常会问它们一个问题：“有多少个？”“什么时候？”“这个存在吗？”“这个可以改变吗？”等。作为响应，函数会返回包含答案的值，例如`True`、一个序列、一个字典，或者其他类型的数据。如果不是这些值，返回的答案将是一个特殊值`None`。

即使一个函数主要做一些简单的工作，通常会有一个隐含问题需要知道。当函数完成任务后，“它成功了吗？”或者“它是如何工作的？”之类的问题通常是您调用函数的方式。


##### 5.2.1 选择名称
把函数写好的第一个指导原则是函数的名称能够反映其用途。这些名称应当指出函数的功能，如Python中的函数`print`、`type`和`len`。

当确定一个名称时，应当考虑如何在程序中调用它。如果命名一个函数，日后您以及其他人调用它时，都能很自然地理解它，这将非常好。几周之内忘记函数的具体细节是很正常的，因此日后返回来用它时，函数的名称就成为回忆它的功能的主要手段。

##### 5.2.2 在函数中描述函数
在待定函数名称之后，应当再给函数添加一个描述。Python可以用简单并有意义的方式完成这件事情。

如果将一个字符串作为函数的第一部分内容，而没用名称引用它，Python将它存储在函数中，以便以后可以引用它。这个字符串通常叫做`docstring`，是`documentation string`（文档字符串）的缩写。

函数的文档字符串用于描述函数。很少有计算机软件做了良好的说明。然而，通常情况下，由于Python提供了简单的文档字符串特性，相对于用缺乏友好和有帮助的约定的其他语言编写的程序，Python程序中有更多可用的信息。

文档字符串中文本并不必像其他代码那样遵循缩进规则，因为它仅仅是一个字符串。输入完文档字符串后，即使它可能看起来破坏了缩进，函数的后续部分也仍然必须保持正确的缩进，记住这一点非常重要。
``` python
 def in_fridge ():
   """This is a function to see if the fridge has a food.
   fridge has to be a dictionary defined outside of the function.
   the food to be searched for is in the string wanted_food"""
   try:
     count = fridge[wanted_food]
   except KeyError:
     count = 0
   return count
```
文档字符串通过函数中的名称引用，仿佛函数是字典一样。这个名称是`__doc__`，它的用法是在函数名称之后加一个英文句点，再加上`__doc__`。注意，在`doc`前后各有两个下划线（_）。

@(试一试)[显示`__doc__`]

现在应当退出上个示例进入的交互式会话，然后重新调用`ch5.py`，因为现在`in_fridge`中加入了文档字符串。此后，可以执行如下操作：
``` python
 >>> print("%s" % in_fridge.__doc__)
 This is a function to see if the fridge has a food.
 fridge has to be a dictionary defined outside of the function.
 the food to be searched for is in the string wanted_food
```

** 示例说明 **
如其他类型一样，函数也有一些属性，可以通过在函数名称后加句点，再加属性名称来使用。`__doc__`是一个字符串，像其他字符串一样，在一个交互式会话中很容易把它打印出来以便引用。

函数还有其他信息（它保存的这组信息可以使用内置函数`dir`查看）。

`dir`显示您感举的对象（例如函数）的所有属性，包括Python内部使用的属性：
``` python
 >>> dir()
 ['__annotations__', '__builtins__', '__doc__', '__loader__', '__name__', '__package__', '__spec__']
```
可以使用获得`in_fridge.__doc__`引用的数据同样的表示方法访问这些属性，但是通常并不南要直接使用其中的大部分属性，尽管使用`type`内置函数研究Python如何描述这些元素是很好的练习。

##### 5.2.3 不同的位置相同的名称
函数的一个特殊属性在于它是您见到的对引用数据的名称进行划分的第一个示例。这意味着如果函数之外有一个名称，该名称引用一个特定值，这个值可以是字符串、数值、字典、序列或者函数。这些数据享有共同的空间。

例如，如果创建了一个字符串名称，然后在下一行创建了一个字典，并用相同的名称引用这个字典，那么这个名称将不再引用字符串，而是仅引用字典：
``` python
 >>> fridge = "Chilly Ice Makers"
 >>> print(fridge)
 Chilly Ice Makers
 >>> fridge = {'apples':10, 'oranges':3, 'milk':2}
 >>> print("%s" % fridge)
 {'apples':10, 'oranges':3, 'milk':2}
```
这很合理，但是在函数中使用名称时会有所不同。函数创建了一个新的空间，其中名称可以被重新使用和创建，而不会影响到程序的其他作用域中的相同名称。所以在编写函数时，完全不用担心其他地方或者其他函数中已经用过同样的名称。

因此，编写函数时，函数有自己的一些名称，其他的函数也有自己的名称，它们是分开的。即使两个函数中某个名称完全相同，由于它们在不同的函数中，所以是完全独立实体，引用的是不同的值。

如果即将在一个已知的情形中使用一个函数，并可以确保它要用的名称已被定义，而且引用了正确的数据，函数就可以通过已经定义的名称访问这个全局数据。Python的这种能力来源于它将一个名称的可见性分隔到不同的概念区域内。每一个这样的区域叫做一个作用域。

最上面一层作用域中的任何名称在一个低层次作用域中可再次被使用，而不影响上层名称引用的数据：
``` python
 >>> special_sauce = ['ketchup', 'mayonnaise', 'french dressing']
 >>> def make_new_sauce():
 ... """This function makes a new special sauce all its own"""
 ...    special_sauce = ["mustard", "yogurt"]
 ...    return special_sauce
 ...
```
此处，最上层作用域中有一个`special_sauce`，函数`make_new_sauce`中也有一个`special_sauce`。当运行时，可以看到全局作用域中的名称没有改变：
``` python
 >>> print("%s" % special_sauce)
 ['ketchup', 'mayonnaise', 'french dressing']
 >>> new_sauce = make_new_sauce()
 >>> print(sepcial_sauce)
 ['ketchup', 'mayonnaise', 'french dressing']
 >>> print(new_sauce)
 ['mustard', 'yogurt']
```
记住，不同的函数完全可以定义相同名称的变量，该名称在两个函数中都有意义，但却引用不同的值，彼此不会产生冲突。

##### 5.2.4 添加注释
Python有一个额外的特性可以帮助记录自己的程序。输入到程序中的全部内容，即使目前为止它还未改变程序的行为（如文档字符串），Python也会处理它。即使不被使用的字符串，Python也会创建它，以便将来使用。

除了不需要的字符串，每门程序语言都有在代码中添加注释的功能，注释不会对程序有影响。它们是供代码使用者阅读的，而不是为Python准备的。

任何地方，一行里有`#`字符且它不出现在字符串中，Python将忽略它后面的所有内容，而开始对下面一行语句求值，并从此处开始读取剩余部分的程序。

@(试一试)[添加注释]

如果交互式地测试注释，可以看到Python读它们时与读字符串不同：
``` python
 >>> "This is a string"
 'This si a string'
 >>> # This is a comment
 >>>
 >>> "This is a string" # with a comment at the end
 'This is a string'
    >>> print("# Here is a pound sign within a string, being treated as a string!")
 # Here is a pound sign within a string, being treated as string!
```

** 示例说明 **
当注释单独出现时，Python忽略它并且返回，询问一下个请求，试着提示输入一个它可以计算的语句。当注释与可以计算的代码出现在同一行时，即使仅仅是个字符串，Python也知道您已经给了它指令。

注释通常出现在程序文件中。您不太可能不厌其烦地在交互式会话中输入注释，但这是在程序文件中使用它们的方法。

另外，如果想测试一个程序的变化，在会引起错误的一行（或多行）代码之前放置注释符号使其失效非常有用。然而要小心。注释会影响Python严格关注的缩进。必须非常仔细地将函数中的注释放在适当的缩进级别，因为如果不这样做，Python将注释看做结束了该函数或`if ... :`代码块，或者其他引起缩进的单位，这肯定不是希望出现的情况！

将注释保持在同样的缩进级别，可以使注释更容易阅读，因为注释用于哪部分代码是显而易见的。

##### 5.2.5 要求函数使用提供的值
在`in_fridge`示例中，函数使用的是全局作用域的值。函数`in_fridge`仅在已经定义的值上做运算，这些值的名称对于整个程序都可见。这种行为只在较小的程序中有效。

当接触到包含成百上千或更多行代码（程序的长度经常以它包含的代码行数来衡量）的大程序时，就不能再依靠特定名称的全局可用性，因为这些名称可能在您没参与时按照其他人的决定被更改掉了。相反，可以指定函数在每次被调用时处理提供给它的值。

这些值是规范或者参数，程序依靠它们完成工作。当函数被调用时，这些参数可以是引用了数据的名称，也可以是静态数据，例如像5一样的一个数或者一个字符串。所有情况下，实际数据将进入被调用函数的作用域，而不是全局作用域。

本书中的许多示例有不同的改进版本，可以把它们添加到同一个文件中，除非本书明确指示改变正在使用的函数。

不必总是将一个函数的前期版本删掉，因为下一个版本只是对它做了简单的修改。通过比较新旧两个函数，您有机会看到对该函数做的修改。

只要最新的版本在您加载时处于文件的最底部，这个最新版本将被使用。

当自己写程序时，这是一个有用的练习。没有什么会像乱动正在处理的一段代码，之后不刻如何将它改回以前可以工作的状态那样痛苦。

注意，在下面的代码中，`def`（函数的定义）已经被更改，现在它指定该函数需要两个参数，参数名称在函数名称后的元组中指定。这些参数将进入并且保持在`in_fridge`函数的作用域内，它们分别是`some_fridge`和`desired_item`。
``` python
 def in_fridge(some_fridge,desired_item):
 """This is a function to see if the fridge has a food.
 fridge has to be a dictionary defined outside of the function.
 the food to be searched for is in the string wanted_food"""
     try:
         count = some_fridge[desired_item]
     except KeyError:
         count = 0
     return count
```
当调用一个带参数的函数时，在`in_fridge`函数调用的圆括号中放置指定参数的值或者名称，参数值之间以逗号分隔。前面已经在使用函数`len`时看到了这种做法。

@(试一试)[调用带参数的函数]

再一次，通过运行`python -i ch5.py`或者使用`Run with Interpreter`重新调用一个交互式的Python会话，得到的交互式会话中定义了新的`in_fridge`函数。
``` python
 >>> fridge = {'apples':10, 'oranges':3, 'milk':2}
 >>> wanted_food = "oranges"
 >>> in_fridge(fridge, wanted_food)
 3
```

** 示例说明 **

字典`fridge`和字符串`wanted_food`作为参数传递给新的`in_fridge`函数。当进入该函数的作用域后，`fridge`引用的字典现在被名称`some_fridge`引用。同时，`wanted_food`引用的字符串`oranges`，在一进入`in_fridge`函数作用域后与名称`desired_item`关联。做完该调整后，函数有了正常工作需要的信息。

为了进一步说明工作原理，可以使用没有命名的值，即不通过名称引用的数据：
``` python
 >>> in_fridge({'cookies':10, 'broccoli':3, 'milk':2}, "cookies")
 10
```
这些值被带入`in_fridge`函数的作用域，并根据函数定义赋值给函数中使用的名称。在函数内部将不再有一个对全局作用域名称的引用。

##### 5.2.6 检查参数
打算使用的参数类型可能与函数被调用时提供的类型不同。例如，可能编写了一个函数，期待的参数是一个字典，但偶然传入一个列表，此时函数将一直运行，直到需要访问字典特有的运算。程序因为产生异常而退出。这与其他语言不同，它们尝试确保每个参数的类型是已知的，而且可以检查其正确性。

Python并不检查哪种类型的数据与函数的参数名称关联。大多数情况下，这不是问题，因为在给定数据上的操作都是某个类型的所特定的，如果名称引用的数据类型不正确，程序将不能正常地工作。

例如，如果向`in_fridge`传入数值而不是字典，python在尝试将数值当作字典访问时，将引发一个`except:`捕捉不到的错误。产生的`TypeError`错误表明Python试图操作的类型做不了Python期望它做的事情：
``` python
 >>> in_fridge(4, "cookies")
 Traceback (most recent call last):
   File "<stdin>", line 1, in ?
   File "<stdin>", line 7, in in_fridge
 TypeError: unsubscriptable object
```
这个示例传递给函数一个数值，而函数期待对一个字典进行操作。不论怎样，数值没有将名称作为键查找值的属性。数值没有键，也没有与键对应的值。在任何上下文中，Python中都不能找到`4("cookies")`，因此将引起异常。

Python用词`unsubscriptable`指出它不能像在字典中那样找到与一个键关联的值。下标`(subscripting)`是描述访问列表、元组或者字典中的元素时的术语，因此在其中任意一个上下文中都可能遇到该错误。

不需要明确定义期待的类型，而允许灵活确定希望如何处理类型的行为可给您带来好处。可以编写一个函数，处理任意期望的类型。还可以编写接受多种类型参数的函数，之后再依据传递给函数的类型确定函数应该如何运行。采取哪种方法取决于需要在程序中做什么。

为了确定某些数据的类型，记住可以使用内置函数`type`，第2章对它做了介绍。使用该函数的输出，可以在函数的开头部分验证变量类型。
``` python
 def make_omelet(omelet_type):
     """This will make an omelet. You can either pass in a dictionary
     that contains all of the ingredients for your omelet, or provide
     a string to select a type of omelet this function already knows
     about"""
     if type(omelet_type) == type({}):
         print("omelet_type is a dictionary with ingredients")
         return make_food(omelet_type, "omelet")
     elif type(omelet_type) == type(""):
         omelet_ingredients = get_omelet_ingredients(omelet_type)
         return make_food(omelet_ingredients, omelet_type)
     else:
         print("I don't think I can make this kind of omelet: %s" % omelet_type)
```
`make_olemet`的定义并不能工作，因为它还信赖于其他几个未编写的函数。编程过程中有时会这么做，先创建一些函数的名称，随后再填充它们的内容。在本章后面将看到这些函数，那时上述代码就变得完全可用了。

@(试一试)[使用`type`函数确定更多的类型]

在用`python -i`或者`Run with Interpreter`加载`ch5.py`文件之后，输入如下代码：
``` python
 >>> fridge = {'apple':10, 'oranges':3, 'milk':2}
 >>> type(fridge)
 <class 'dict'>
 >>> type({})
 <class 'dict'>
 >>> type("Omelet")
 <class 'str'>
 >>> type("")
 <class 'str'>
```
** 示例说明 **
要注意的第一件事情是`type`函数返回对象的类。在测试中可以使用这个类的对象，即它可与其他类对象进行比较。注意，Python中，类和类型是同一事物的不同名称，即它们定义了变量和值的数据类型。

@(试一试)[使用字符串比较类型]

在这里还可以使用另外一个特性。前面已经看到，对于`print`函数，Python中的话多对象可以表示成字符串。这是因为，许多对象都有内置的方法，在需要时可将它们转换成字符串。

例如，另外一种编写前面比较的方法如下：
``` python
 >>> fridge = {'apples':10, 'oranges':3, 'milk':2}
 >>> str(type(fridge))
 "<class 'dict'>"
 >>> if str(type(fridge)) == "<class 'dict'>":
 ...     print("They match!")
 ...
 They match!
```

** 示例说明 **

由于事先可以知道一个类型的字符串表示是什么样子，可以将那个字符串与一个通过`str`函数转换成字符串的对象进行比较。

##### 5.2.7 为参数设置默认值
还有一个小窍门可确保函数易于使用。函数的每个参数都要有值。如果没有给所有必需参数赋值，函数将产生一个错误，或者更糟的是，它返回了错误的数据。

为了避免这种情形，Python允许创建带默认值的函数，这些默认值赋给那些在函数调用时没有显式提供的参数。您已经见过这种行为。例如列表的`pop`方法，它既可以被告知处理列表中的一个特定元素，也可以在没有给定任何值的情况下，自动处理最后一个元素。

可以在定义函数时，在参数列表中使用赋值运算符（`=`）指定默认值。例如，如果希望`make_omelet`的变体可以默认地做出一个奶酪煎蛋卷，仅需改变它的定义，其余什么都不用作。

@(试一试)[设置默认参数]

剪切并粘贴整个`make_omelet`函数。之后，在函数的新副本中对它的定义做如下修改，它将默认地做奶酪煎蛋卷：
``` python
 def make_omelet2(omelet_type="cheese"):
```

** 示例说明 **

该定义并不改变函数其余代码的行为。它仅在函数`make_omelet2`被调用、但没有定义`omelet_type`时设置它的值。

仍然可以用一个字典或者一个不同类型的煎蛋卷指定这个参数。然而，如果`make_omelet`用这样的方式定义，可以在不指定何特定煎蛋卷的类型的情况下调用它，该函数将做出一个奶酪煎蛋卷。

对`make_omelet`做相同的操作是将`make_omelet`编写为一个以友好和直观的方式运行的函数的第一步。记住，仍然需要编写其他函数！目标是得到如下的输出：
``` python
 >>> make_omelet()
 Adding 2 of eggs to make a cheese
 Adding 2 of cheddar to make a cheese
 Adding 1 of milk to make a cheese
 Made cheese
 'cheese'
 >>> make_omelet("western")
 Adding 1 of pepper to make a western
 Adding 1 of ham to make a estern
 Adding 1 of onion to make a western
 Adding 2 of eggs to make a western
 Adding 2 of jack_cheese to make a western
 Adding 1 of milk to make a western
 Made western
 'western'
```
如果编写了一个有多个参数的函数，并且希望其中既有必需参数也有可选参数，必须将可选参数放在参数列表的末尾。因为一旦指定某个参数为可选参数，它可能出现也可能不出现。从第一个可选参数起，Python不能保证那些在可选参数右边的参数都出现。换言之，第一个默认参数后面的所有参数都变成可选参数。这是自动发生的，因此要小心使用这个特性。

##### 5.2.8 在函数中调用其他函数
在顶层或者全局作用域声明的函数可以被其他函数以及其他函数包含的函数使用。全局作用域的名称可在任何地方使用，因为最有用的函数需要在其他函数中可用。

为了使用`make_omelet`函数能像之前看到的那样工作，它信赖的其他函数应当可用，以便被`make_omelet`使用。

它的工作方式是：首先，一个函数扮演了一本食谱的角色。它被给予一个指定煎蛋卷类型的字符串，并返回一个包含所有成分及其分量的字典。该函数将被叫做`get_omelet_ingredients`，它需要一个参数，即煎蛋剪子的名称：
``` python
 def get_omelet_ingredients(omelet_name):
 """This contains a dictionary of omelet names that can be produced,
 and their ingredients"""
     # All of our omelets need eggs and milk
     ingredients = {"eggs":2, "milk":1}
     if omelet_name == "cheese":
         ingredients["cheddar"] = 2
     elif omelet_name == "western":
         ingredients["jack_cheese"] = 2
         ingredients["ham"]         = 1
         ingredients["pepper"]      = 1
         ingredients["onion"]       = 1
     elif omelet_name == "greek":
         ingredients["feta_cheese"] = 2
         ingredients["spinach"]     = 2
     else:
         print("That's not on the menu, sorry!")
         return None
     return ingredients
```
做煎蛋卷所需的第二个函数叫做`make_food`，它需要两个参数。第一个参数是包含所需成分的列表，这些成分完全从`get_omelet_ingredients`函数得来。第二个参数是食物的名称，它应当是一种煎蛋卷的类型：
``` python
 def make_food(ingredients_needed, food_name):
     """make_food(ingredients_needed, food_name)
     Takes the ingredients from ingredients_needed and makes food_name"""
     for ingredient in ingredients_needed.keys():
         print("Adding %d of %s to make a %s" %
 (ingredients_needed[ingredient], ingredient, food_name))
     print("Made %s" % food_name)
     return food_name
```
此时，所有部分都已就绪，可以使用`make_omelet`函数。它需要调用函数`get_omelet)ingredients`和`make_food`来完成工作。每个函数都提供了制作一个煎蛋卷的部分过程。`get_omelet_ingredients`函数为特有的煎蛋卷类型提供了详细而精确的说明，而通过`make_food`函数提供的信息，可以知道在将合适数量的一些成分混合之后得到哪些结果（为了演示，这里采用了一种简单的方法）。

@(试一试)[调用已完成的函数]

现在已经有了能使`make_omelet`工作的所有函数，用`python -i`或者`Run with Interpreter`命令调用`ch5.py`文件，之后在Shell中尝试如下代码：
``` python
 >>> omelet_type = make_omelet("cheese")
 Adding 2 of eggs to make a cheese
 Adding 2 of cheddar to make a cheese
 Adding 1 of milk to make a cheese
 Made cheese
 >>> print omelet_type
 cheese
 >>> omelet_type = make_omelet({"eggs":2, "jack_cheese":2, "milk":1, "mushrooms":2})
 omelet_type is a dictionary with ingredients
 Adding 2 of jack_cheese to make a omelet
 Adding 2 of mushrooms to make a omelet
 Adding 2 of eggs to make a omelet
 Adding 1 of milk to make a omelet
 Made omelet
 >>> print omelet_type
 Omelet
```

** 示例说明 **

所有函数已经就绪，可以被逐个调用，所以只需指定希望制作的煎蛋卷的名称，然后就可以使用`make_omelet`了。

##### 5.2.9 函数嵌套函数
在工作中不可能对煎蛋卷制作进行模拟，但对现实世界的情形进行部分模拟是有可能的，本小节将介绍如何改进已有的解决方案。

也许一个特定函数的工作太多，不便在一个地方定义，您希望将它分解成小的不同的片段。为此，可以将函数放在另外的函数内部，并且从那个函数中调用该函数。这样复杂函数变得更有意义。例如，`get_omelet_ingredients`可以完全包含在`make_omelet`函数内部，并且不能用于程序的其余部分。

限制该函数的可见性是有意义的，因为该函数只能用于制作煎蛋卷。如果编写一个程序，其中也包含制作其他食物的指令，煎蛋卷的成分将不能用于制作其他类型的食物，即使像炒蛋或者梳芙厘这样与煎蛋卷类似的食物。每种新食物都需要自己的功能相同的函数。然而，`make_food`函数仍然有意义，可用于任意类型的食物。

在另外一个函数中定义一个函数就像在顶层定义它一样。唯一的不同之处是它与包含它的函数中的其他代码在相同的级别缩进。这种情况下，所有代码看起来很类似：
``` python
 def make_omelet(omelet_type):
     """This will make an omelet. You can either pass in a dictionary
     that contains all of the ingredients for your omelet, or provide
     a string to select a type of omelet this function already knows
     about"""
     def get_omelet_ingredients(omelet_name):
         """ This contains a dictionary of omelet names that can be produced,
 and their ingredients"""
         ingredients = {"eggs":2, "milk":1}
         if omelet_name == "cheese":
             ingredients["cheddar"] = 2
         elif omelet_name == "western":
             ingredients["jack_cheese"] = 2

     ingredients["ham"]      = 1
             ingredients["pepper"]  = 1
             ingredients["onion"]   = 1
         elif omelet_name == "greek":
             ingredients["feta_cheese"] = 2
         else:
             print("That's not on the menu, sorry!")
             return None
         return ingredients
     if type(omelet_type) == type({}):
         print("omelet_type is a dictionary with ingredients")
         return make_food(omelet_type, "omelet")
     elif type(omelet_type) == type(""):
         omelet_ingredients = get_omelet_ingredients(omelet_type)
         return make_food(omelet_ingredients, omelet_type)
     else:
         print("I don't think I can make this kind of omelet: %s" % omelet_type)
```
使用函数之前定义函数非常重要。如果试图在定义一个函数之前就调用它，那么在调用时Python不知道函数的存在，因此不能调用它！当然，这将导致一个错误并引起一个异常。因此，在文件的开始处定义函数，这样一直到最后都可以使用它们。


##### 5.2.10 用自己的词语标记错误
如果需要指出发生了一个特定的错误，那么可能希望使用已经见过的一个错误指出正在调用的函数哪里出错了。

与`try:`和`except:`关键字对应的是`raise ... :`命令。使用`raise ... :`命令的好时机是，在编写了一个接受多个参数的函数，而其中一个参数类型错误时，非常适合使用`raise ... :`命令。

可以检查传递进来的参数，并使用`raise ... :`指出提供了错误类型的参数。当使用`raise ... :`时还提供了一条`except ... :`语句可以捕获并显示的错误信息，即关于该错误的解释。

下面的代码修改了`make_omelet`函数的结尾部分，将一个打印出的错误（适合运行程序的人阅读）替换为一个`raise ... :`语句，这样即可以通过函数处理错误，也可以将该错误打印出来。
``` python
 if type(omelet_type) == type({}):
     print("omelet_type is a dictionary with ingredients")
     return make_food(omelet_type, "omelet")
 elif type(omelet_type) == type(""):
     omelet_ingredients = get_omelet_ingredients(omelet_type)
     return make_food(omelet_ingredients, omelet_type)
 else:
     raise TypeError("No such omelet type: %s" % omelet_type)
```
完成该修改后，`make_omelet`在遇到问题时，可以显示关于该类错误的精确信息，同时仍旧为使用者提供信息。

#### 5.3 函数的层次
现在已经了解了函数是什么以及它们是如何工作的，考虑它们的调用方式以及Python如何记录调用层次非常有用。

当程序调用一个函数时，或者一个函数调用一个函数时，Python在其内部创建了一个叫做栈的列表，有时也叫做调用栈。当调用一个函数时，Python将停止片刻，记住程序调用函数时所处的位置，之后将该信息贮藏到它的内部列表。之后进入函数并且执行它。例如下，如下代码阐明了Python如何记录它是如何进入以及离开函数的：
``` python
 [{'top_level': 'line 1'}, {'make_omelet': 'line 64'}, {'make food': 'line 120'}]
在最上层，Python从第一行开始记录。之后，当函数`make_omelet`在第64行被调用时，也对其进行了记录。再后来，`make_food`被`make_omelet`调用。当`make_food`函数结束时，Python确定它在第64行，于是返回到第64行并继续执行。这个示例中的行数是虚构的，但是您可以了解其中的意思。
这个列表叫做栈，形象地表示出了进入函数的方式。可以想象直到退出时，一个函数位于栈顶部，当去掉它时，栈的长度缩减了1。

** 如何解读深层的错误 **

当程序中有一个错误发生时，如果引起一个未捕获的错误，您将看到一个比之前见过的更加复杂的错误。例如，假设传递了一个包含列表而不是一个数值的字典。这将导致一个如下所求的错误：
``` python
 >>> make_omelet({"a":1, "b":2, "j":["c", "d", "e"]})
 omelet_type is a dictionary with ingredients
 Adding 1 of a to make a omelet
 Adding 2 of b to make a omelet
 Traceback (most recent call last):
   File "<stdin>", line 1, in ?
   File "ch5.py", line 96, in make_omelet
     return make_food(omelet_type, "omelet")
   File "ch5.py", line 45, in make_food
     Print("Adding %d of %s to make a %s" % (ingredients_needed[ingredient], ingredient, food_name))
 TypeError: int argument required
```
当从文件进入一个函数后，Python将指出您在栈中的位置（这意味着错误发生时有多少层以及栈中的每层在程序哪一行被调用），因此可以打开有问题的文件来确定发生了什么。

当调用更多的函数或者使用函数调用其他函数，创建了深层的栈（可以将它想象为长一些的列表）时，就获得了使用栈跟踪（这是引发一个错误或者引起一个异常时，Python对输出使用的通用名称）的经验。前面的栈跟踪尝试为3，可以看到在第45行，当调用`make_food`时，参数类型有问题。现在可以回去修复它。

如果认为这个问题会经常发生，可以将`make_food`调用括在一个`try ... :`代码块中，这样`TypeError`错误将不会终止程序。然而，如果能在函数中处理掉这个错误，就更好了。

在使用明显错误的类型或字典成员的情况下，Python将引起一个`TypeError`，我们通常没必要执行额外的操作。然而，希望如何处理特定的情形取决于您。

栈跟踪是栈的可读形式，可以检查它们来确定问题所在。栈跟踪显示了问题发生时的所有情况，只要引发异常，Python就会生成栈跟踪。

#### 5.4 本章小结
本章介绍了函数。函数将Python中的若干语句聚焦在同一个名称下，以在需要的时候调用它。在定义函数时，可以指定该函数带有参数，这样在调用它时，函数就可以对指定的参数值进行操作。

函数的参数名称与该函数一起定义，它们在函数名称后面用括号括起来。不需要参数时，括号仍然出现，只是为空而已。

当函数被调用时，每个函数创建了自己的作用域，在其中可以访问全局范围内的名称，还可以访问函数体内创建和赋值的名称。如果一个全局名称在一个特定函数内被赋值，当用全局名称引用它时，它的值不发生变化，只是在该函数体内发生变化。

如果一个函数 在另外一个函数内定义，它可以访问定义它的函数内的所有名称，还有全局范围的所有名称。记住，这种可见性取决于函数在哪里定义，而不取决于它在哪里被调用。

函数可以在其他函数内被调用。这样可以使用程序易于理解。函数将通用的任务用一个简短的名称表示，减少了重复输入。

定义了参数的函数通过值来调用，提供的每个值都要赋给函数参数列表中的名称。传递给函数的第一个参数赋值给第一个名称，第二个参数赋给第二个名称，依此类推。给函数传递参数时，每一个参数要么是必要的，要么是可选的。定义函数时，可选 参数必须位于必需参数后面，可以赋予它们默认值。

可以使用`raise ... :`特征通知发生了错误，这些错误可以被`except ... :`接收和处理。这就可以从函数提供反馈，它不仅提供错误类型，还提供了对错误进行描述的字符串，从而使该错误可以被处理。

本章还介绍了栈。当`raise ... :`或者程序中的其他错误引发了一个错误条件时，错误的位置不仅通过发生错误的函数名称来描述，还通过涉及到函数名称以及它们的调用位置来描述。如果一个函数足够有用，可在不同的地方使用它，且它只在其中一个地方出问题，可以通过栈跟踪缩小问题源。

** 本章要点 **

* 通过`python -i`（或者`Run with Interpreter`）运行Python程序，可以创建一些较长的程序，而不用直接向Shell中输入代码。
* 通过将代码片段另存为函数，使它们可在当前或者以后的程序中重复使用，可以节省时间。
* 文档字符串以三引号（"""）开头，它可以定义函数的用途，为自己和将来的程序员留下注释。
* 可以在函数中用`__doc__`显示文档字符串。
* 通过`dir()`可以看到一个对象的所有属性。
* 可以通过`#`向代码中添加注释。Python忽略同一行中该符号后面的内容。注释允许您留下记录，若干月后需要再次查看代码或其他编程人员需要阅读代码时，可以更快地理解当初编写的代码。
* `type()`函数可以显示一个对象的类型。

#### 5.5 习题
1. 编写一个名为`do_plus`的函数，它接收两个参数，并且用“＋”将它们相加。
2. 增加类型检查，以确认参数的类型要么是整形，要么是字符串。如果参数不正确，招聘一个`TypeError`。
3. 这个题目的工作量较大，请随意将它分为几部分。第4章中，编写一个循环制作煎蛋卷。它做了从检查成分到把它们从冰箱中取出并做成一个煎蛋卷的全部工作。以该循环为原型，更改`make_omelet`函数，编写一个名为`make_omelet_q3`的函数。它应该从下述方面对`make_omelet`进行修改，使得它更加贴切描述一个真实的厨房：
> a. 将冰箱作为第一个参数传递给新的`make_omelet`。应当检查冰箱的类型，确保它是一个字典。

> b. 增加一个函数检查冰箱，并且将即将用到的成分从冰箱中减去。将这个函数命名为`remove_from_fridge`。该函数首先检查冰箱中是否有足够多的成分制作煎蛋卷，检查完毕后，再将这些成分从冰箱中取出以制作煎蛋卷。用错误类型`LookupError`作为要招聘的错误的类型。

> c. 将从冰箱中取出的食物放到一个字典中，由函数`remove_from_fridge`函数返回，赋给一个名称，将该名称传递给`make_food`。毕竟，并不希望将不打算使用的食物从冰箱中取出。

> d. 制作一个不同的默认煎蛋卷，而不是奶酪煎蛋卷。向函数`get_omelet_ingeredients`中添加这个煎蛋卷的成分。
4. 更改`make_omelet`，在订购沙门氏菌煎蛋卷时，使用`get_omelet_ingredients`函数抛出一个`TypeError`错误。尝试订购一个沙门氏菌煎蛋卷，并查看产生的栈跟踪。

### 第6章 类与对象

到目前为止，已经介绍了编程所需的大多数构建模块。您已经使用了数据，使用名称引用数据（程序员通常将这些名称称为变量），还在循环和函数中使用过数据。这三个元素的使用是编写程序以及用计算机解决问题的基础。可以使用名称来存储和引用值，并对它们进行操作。循环可以重复处理列表中的每个元素（或每隔一个元素、两个元素等的元素）。最后，函数可将一组代码整合到一个名称下，这样可在任何需要的时刻和位置调用它。

本章将介绍：
* Python如何将函数和数据整合在一起，并通过一个对象的名称访问它们。
* 如何 和为什么使用类与对象，以及它们如何使编程人员易于在多种情形下编写和使用程序。

#### 6.1 考虑编程

到目前为止，本书已经介绍了Python的基础知识，现在要在Python中创建一个对对象的描述，您已有足够的知识获得两个视图。每一个是数据视图，除了在顶层或者全局作用域的数据外，可以根据需要使用和清除它们。另一个是函数视图，它们没有固有的数据，而只操作提供给它们的数据。

##### 6.1.1 对象的含义

Python中的任何一条数据都是对象。每个对象都由3部分组成：标识、类型和值。对象的标识代表该对象在内存中的存储位置（因此是不可更改的），对象的类型表明它可以拥有的数据和值的类型。在对象中，可变类型的值可以更改，不可变类型的值不能更改。

简单此的解释是参考本书中已经介绍的（或者即将介绍）的对象。例如，整型、字符串、列表等都是对象。可以在程序中很方便地使用这些对象，但是将关系紧密的对象整合在一起岂不更有意义？这也是类的由来。类允许定义一组对象，并将它们封闭到一个方便的空间中。

##### 6.1.2 已经了解的对象

下面即将介绍的方法使您可以考虑包含数据和函数的完整对象。字符串是前面已经接触过的对象。一个字符串不仅包含文本，也有关联的方法，这使得字符串不仅代表文本，还提供了一些功能，例如将整个字符串变成大写或者小写。下面简单回顾已经学到的知识。一个字符串主要的是指输入的文本：
``` python
 >>> omelet_type = "cheese"
```
除了经常处理的数据，即文本“Cheese”，字符串这种对象还拥有方法，方法经常被叫做行为。每一个字符串都有一些方法，如返回小写的字符串的`lower`方法，以及返回一个完全大写的字符串的`upper`方法：
``` python
 >>> omelet_type.lower()
 'cheese'
 >>> omelet_type.upper()
 'CHEESE'
```
其他可用的方法还有内置在元组、列表和字典对象中的方法，例如字典的`keys`方法，在前面已经使用过该方法：
``` python
 >>> fridge = {"cheese":1, "tomato":2, "milk":4}
 >>> for x in fridge.keys():
         print(x)
 ['tomat', 'cheese', 'milk']
```
使用`dir`函数可以列举出一个对象的所有属性和方法：
``` python
 dir(fridge)
['__class__', '__contains__', '__delattr__', '__delitem__', '__doc__',
'__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__',
'__gt__', '__hash__', '__init__', '__iter__', '__le__', '__len__',
'__lt__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__',
'__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__',
'clear', 'copy', 'formkeys', 'get', 'items', 'keys', 'pop', 'popitem',
'setdefault', 'update', 'values']
```
`dir`函数可以显示字符串或者Python中其他任何对象的所有数据方法，简言之，它可以显示这些对象所包含的每个名称。`Dir`函数能够以字母表的顺序列出正在检查的对象中所有可用的名称，它将以下划线开头的名称放在结果的最开始。按照约定，以下划线开头的名称是对象的私有属性，它们是不可见。即，不能直接使用它们，但是Python将决定权留给了开发人员，所以您可以交互地查看这些属性以学习它们：
``` python
 >>> type(omelet_type.__len__)
 <class 'method-wrapper'>
```
这很有趣。可以调用该方法，并观察它输出的结果：
``` python
 >>> omelet_type.__len__()
 6
```
这个方法返回与内置函数`len`一样的结果。当一个函数内置到一个对象中时，它叫做这个对象的“方法”。

实际上，函数`len`就是利用方法`__len__`工作的：函数`len`向这个内置方法询问对象的长度。对象的设计者可定义长度的计算方式，使得对于定义了`__len__`方法的任何对象，内置函数`len`都能够正确运行。

其余的以下划线形状的名称也都具有特殊含义。可以在Python Shell中探究它们。Python Shell通过显示试图调用的对象内的名称，帮助研究一个字符串对象的方法，但它不显示以下划线开头的内部名称。您可以使用`dir`函数实现该功能。

##### 6.1.3 展望：如何使用对象

我们希望能够以自然的方式使用对象。例如，一旦定义了`Omelet`类之后，它便可以产生对象，在查看源代码时，这些对象以自然的方式工作。稍后就会尝试编写实现该操作的代码（下一节中将看到如何操作）：
``` python
 >>> o1 = Omelet()
 >>> o1.show_kind()
 'cheese'
```
我们希望将冰箱当做对象使用，而不仅仅把它看做一个字典。如果使用它就像使用一个真正的冰箱一样，就太合适不过了，我们可以向其中增加食物、从中取出食物、检查食物，以及一次增加或者取出多种食物等。

换言之，创建一个对现实世界的某物进行模拟的对象时，应该使熟悉该现实事物的人们能够比较轻松地认知和理解它们。


#### 6.2 定义类

当思考包含几百行Python代码的小程序如何运行时，经常可以发现程序将数据组织成组的形式——当访问某个数据时，将影响与该数据一起协作的数据。经常会碰到有朴素依赖关系的完整数据列表，如列表1的第一个元素与列表2和列表3中的第一个元素匹配，依此类推。有时，必须通过创造性地将这些列表组合起来才能解决这个问题。Python运用了创建用作占位符的整个类的概念，类起了占位符的作用。当一个类被调用时，它创建了绑定到一个名称的对象。

##### 6.2.1 如何创建对象
将对象绑定到一外名称后，使用该名称可以访问已定义的数据和函数。编写一个类的代码之前，首先要声明该类。通过`class`关键字声明类。

@(试一试)[定义一个类]

定义一个类比较简单，主要是使用关键字`class`，并在后面紧跟一个名称来完成。定义类的方式与定义函数的方式类似，只不过不在类定义之后放置包含项目的元组（在类的定义之后放置包含项目的元组将创建一个要继承的类，第10章将介绍这方面的内容）。
``` python
 class Fridge:
     """This class implements a fridge where ingredients can be
     added and removed individually, or in groups."""
```

** 示例说明 **

从类的定义开始，缩进于其中的所有代码在该类创建的对象中都可用。在第5章介绍函数时已经见过这一点，类似的规则同样适用于类。在类中可以自由选择内置文档字符串，就像在函数中一样。它们的表现方式相同，并且非常有用，提供了了解类信息的简单方法。

如前面的例子所求，应当试着创建`Fridge`类。注意此处使用了大写的“`F`”。类的名称以大写字母开头是Python程序员的惯例。当类的名称有多个单词时，另一种惯例是将这些词连在一起，但是每个词以大写字母开头以方便阅读。例如，模拟一个冰箱和制冷器的类可被命名为`FridgeAndFreezer`。

@(试一试)[由类创建对象]

尝试将`Fridge`类输入到文件`ch6.py`中（或者类似的文件中），之后用`python -i`或者命令`Run with Interpreter`调用该文件，如第5章所示。

「LatestType Page-107」
##### 6.2.2 对象和它们的作用域

#### 6.3 本意小结

#### 6.4 习题

### 第7章 缓和程序

#### 7.1 模块

##### 7.1.1 导入可用模块

##### 7.1.2 通过已有模块创建新模块

##### 7.1.3 从命令行开始使用模块

##### 7.1.4 改变导入方式

#### 7.2 包

#### 7.3 模块和包

##### 7.3.1 将所有内容引入当前作用域

##### 7.3.2 重新导入模块和包

#### 7.4 测试模块和包的基础知识

#### 7.5 本章小结

#### 7.6 习题

### 第8章 文件和目录

#### 8.1 文件对象

##### 8.1.1 编写文本文件

##### 8.1.2 向文件中追加文本

##### 8.1.3 读文本文件

##### 8.1.4 文件异常

#### 8.2 路径和目录

#### 8.3 OS中的异常

##### 8.3.1 路径

##### 8.3.2 目录内容

##### 8.3.3 获取文件信息

##### 8.3.4 重命名、移动、复制和删除文件

##### 8.3.5 示例：轮换文件

##### 8.3.6 创建和删除目录

##### 8.3.7 通配

#### 8.4 本意小结

#### 8.5 习题


### 第9章 Python语言的其他特性

#### 9.1 lambda和filter：简单匿名

#### 9.2 Map：短路循环

#### 9.3 在列表中做出决策——列表解析

#### 9.4 为循环生成迭代器

#### 9.5 使用字典的特殊字符串替换

#### 9.6 重要模块

##### 9.6.1 getopt——从命令行中得到选项

##### 9.6.2 使用一个以上的进程

##### 9.6.3 线程——在相同的进程中完成多个工作

#### 9.7 本意小结

#### 9.8 习题


### 第10章 创建模块

#### 10.1 研究模块

##### 10.1.1 导入模块

##### 10.1.2 查找模块

##### 10.1.3 理解模块

#### 10.2 创建模块和包

#### 10.3 使用类

##### 10.3.1 定义面向对象编程

##### 10.3.2 创建类

##### 10.3.3 扩展已有的类

#### 10.4 完成模块

##### 10.4.1 定义模块特定的错误

##### 10.4.2 选择导出哪些内容

##### 10.4.3 为模块建立文档

##### 10.4.4 测试模块

##### 10.4.5 将模块作为程序运行

#### 10.5 创建一个完整的模块

#### 10.6 安装模块

#### 10.7 本意小结

#### 10.8 习题


### 第11章 文本处理

#### 11.1 文本处理的用途

##### 11.1.1 搜索文件

##### 11.1.2 日志剪辑

##### 11.1.3 邮件筛选

#### 11.2 使用OS模块导航文件系统

#### 11.3 使用正则表达式和re模块

#### 11.4 本意小结

#### 11.5 习题

## 第III部分 开始使用Python

### 第12章 测试

#### 12.1 断言

#### 12.2 测试用例和测试套件

#### 12.3 测试装置

#### 12.4 用极限编程整合

##### 12.4.1 用Python实现搜索实用程序

##### 12.4.2 一个更加强大的Python搜索

#### 12.5 软件生命周期中的正规测试

#### 本意小结

### 第13章 使用Python编写GUI

#### 13.1 Python的GUI编程工具箱

#### 13.2 Tkinter简介

#### 13.3 用Tkinter创建GUI小组件

##### 13.3.1 改变小组件的尺寸

##### 13.3.2 配置小组件选项

##### 13.3.3 使用小组件

##### 13.3.4 创建布局

##### 13.3.5 填充顺序

##### 13.3.6 控制小组件的外观

##### 13.3.7 单选按钮和复选框

##### 13.3.8 对话框

##### 13.3.9 其他小组件类型

#### 13.4 本意小结

#### 13.5 习题

### 第14章 访问数据库

#### 14.1 使用dbm持久字典

##### 14.1.1 选择dbm模块

##### 14.1.2 创建持久字典

##### 14.1.3 访问持久字典

##### 14.1.4 dbm与关系数据库的适用场合

#### 14.2 使用关系数据库

##### 14.2.1 编写SQL语句

##### 14.2.2 定义表

##### 14.2.3 建立数据库

#### 14.3 使用Python的数据库API

##### 14.3.1 下载各个模块

##### 14.3.2 创建连接

##### 14.3.3 使用游标

##### 14.3.4 使用事务并提交结果

##### 14.3.5 检查模块的功能和元数据

##### 14.3.6 处理错误

#### 14.4 本意小结

#### 14.5 习题

### 第15章 使用Python处理XML

#### 15.1 XML的含义

##### 15.1.1 层次标记语言

##### 15.1.2 一组标准

#### 15.2 模式/DTD

##### 15.2.1 文档模型的用途

##### 15.2.2 是否需要文档模型

#### 15.3 文档类型定义

##### 15.3.1 DTD示例

##### 15.3.2 DTD不完全是XML

##### 15.3.3 DTD的局限性

#### 15.4 模式

##### 15.4.1 示例模式

##### 15.4.2 模式是纯粹的XML

##### 15.4.3 模式具有层次

##### 15.4.4 模式的其他优点

#### 15.5 XPath

#### 15.6 HTML是XML的子集

##### 15.6.1 HTML DTD

##### 15.6.2 HTML Parser

#### 15.7 Pathon中可用的XML库

#### 15.8 SAX的含义

##### 15.8.1 基于流

##### 15.8.2 事件驱动

##### 15.8.3 DOM的含义

##### 15.8.4 内存中访问

#### 15.9 使用SAX或者DOM的理由

##### 15.9.1 能力权衡

##### 15.9.2 内存考虑

##### 15.9.3 速度考虑

#### 15.10 Python中可用的SAX和DOM解析器

##### 15.10.1 xml.SAX

##### 15.10.2 xml.dom.minidom

#### 15.11 XSLT简介

##### 15.11.1 XSLT是XML

##### 15.11.2 转换和格式语言

##### 15.11.3 函数式、模板驱动

#### 15.12 lxml简介

#### 15.13 元素类

#### 15.14 使用lxml解析

#### 15.15 本章小结

#### 15.16 习题

### 第16章 网络编程

#### 16.1 理解协议

##### 16.1.1 比较协议和程序语言

##### 16.1.2 Internet协议栈

##### 16.1.3 Internet协议简介

#### 16.2 发送电子邮件

##### 16.2.1 E-mail文件格式

##### 16.2.2 MIME消息

##### 16.2.3 使用SMTP和发送邮件

#### 16.3 检索Internet邮件

##### 16.3.1 使用mailbox解析本地邮筒

##### 16.3.2 使用poplib从POP3服务器获取邮件

##### 16.3.3 使用imaplib从IMAP服务器获取邮件

##### 16.3.4 安全的POP3和IMAP

##### 16.3.5 Webmail应用程序不是E-mail应用程序

#### 16.4 套接字编程

##### 16.4.1 套接字简介

##### 16.4.2 绑定到外部主机名

##### 16.4.3 镜像服务器

##### 16.4.4 镜像客户端

##### 16.4.5 套接字服务器

##### 16.4.6 多线程服务器

##### 16.4.7 Python聊天服务器

##### 16.4.8 设计Python聊天服务器

##### 16.4.9 Python聊天服务器协议

##### 16.4.10 Python聊天客户端

##### 16.4.11 基于select的单线程多任务

#### 16.5 其他主题

##### 16.5.1 协议设计的多种考虑

##### 16.5.2 对等架构

#### 16.6 本意小结

#### 16.7 习题

### 第17章 用C扩展编程

#### 17.1 扩展模块概述

#### 17.2 构建并安装扩展模块

#### 17.3 从Python向C传递参数

#### 17.4 从C向Python返回值

#### 17.5 LAME项目

#### 17.6 LAME扩展模块

#### 17.7 在C代码中使用Python对象

#### 17.8 本意小结

#### 17.9 习题


### 第18章 数值编程

#### 18.1 Python语言中的数值

##### 18.1.1 整数

##### 18.1.2 长整数

##### 18.1.3 浮点数

##### 18.1.4 格式化数值

##### 18.1.5 作为数值的字符

#### 18.2 数学

##### 18.2.1 算术运算

##### 18.2.2 内置数学函数

#### 18.3 复数

#### 18.4 数组

#### 18.5 本意小结

#### 18.6 习题


### 第19章 Diango简介

#### 19.1 框架的定义以及使用框架的理由

#### 19.2 Web框架的其他功能

#### 19.3 Django发展史

#### 19.4 理解Django的架构

##### 19.4.1 项目初始设置

##### 19.4.2 创建视图

#### 19.5 使用模板

#### 19.6 使用模板和视图

##### 19.6.1 模型

##### 19.6.2 创建模型的第一步——配置数据库设置

#### 19.7 创建模型：创建一个应用程序

#### 19.8 本意小结

#### 19.9 习题


### 第20章 Web应用程序与Web服务

#### 20.1 REST：Web架构

##### 20.1.1 REST的特性

##### 20.1.2 Register操作

#### 20.2 HTTP：REST的实际应用

##### 20.2.1 可见的Web服务器

##### 20.2.2 HTTP请求

##### 20.2.3 HTTP响应

#### 20.3 CGI：将脚本变为Web应用程序

##### 20.3.1 Web服务器与CGI脚本的协议

##### 20.3.2 CGI的特殊环境变量

##### 20.3.3 通过HTML表单接收用户输入

#### 20.4 HTML表单的有限词汇

#### 20.5 访问表单值的安全性

#### 20.6 构建wiki

##### 20.6.1 Bitty Wiki核心库

##### 20.6.2 Bitty Wiki的Web接口

#### 20.7 Web服务

#### 20.8 REST Web服务

##### 20.8.1 REST快速入门：在Amazon.com上寻找廉价商品

##### 20.8.2 WishListBargainFinder简介

##### 20.8.3 向Bitty Wiki提供REST API

##### 20.8.4 使用REST Web服务实现搜索和替换功能

#### 20.9 XML-RPC

##### 20.9.1 XML-RPC请求

##### 20.9.2 XML-RPC中的数据表示

##### 20.9.3 XML-RPC响应

##### 20.9.4 错误处理机制

##### 20.9.5 通过XML-RPC展示Bitty Wiki API

##### 20.9.6 基于XML-RPC Web服务的wiki搜索和替换

#### 20.10 SOAP

##### 20.10.1 SOAP快速入门

##### 20.10.2 SOAP请求

##### 20.10.3 SOAP响应

##### 20.10.4 错误处理机制

##### 20.10.5 展示一个Bitty Wiki的SOAP接口

##### 20.10.6 基于SOAP Web服务的wiki搜索和替换

#### 20.11 为Web服务API创建文档

##### 20.11.1 人类可读的API文档

##### 20.11.2 XML-RPC自省API

##### 20.11.3 WSDL

#### 20.12 选择Web服务标准

#### 20.13 Web服务礼仪

##### 20.13.1 Web服务的使用者礼仪

##### 20.13.2 Web服务的创建者礼仪

##### 20.13.3 将Web应用程序作为Web服务使用

#### 20.14 本章小结

#### 20.15 习题


### 第21章 集成Java与Python

#### 21.1 在Java应用程序中编写脚本

#### 21.2 比较各种Python实现

#### 21.3 安装Jython

#### 21.4 运行Jython

##### 21.4.1 交互地运行Jython

##### 21.4.2 运行Jython脚本

##### 21.4.3 控制Jython脚本

##### 21.4.4 创建可执行命令

#### 21.5 独立运行Jython

#### 21.6 打包基于Jython的应用程序

#### 21.7 集成Java和Jython

##### 21.7.1 在Jython中使用Java类

##### 21.7.2 从Jython访问数据库

##### 21.7.3 通过Jython编写Java EE servlet

##### 21.7.4 选择Jython解释器

#### 21.8 使用Jython进行测试

#### 21.9 嵌入Jython解释器

#### 21.10 处理C-Python和Jython之间的差异

#### 21.11 本章小结

#### 21.12 习题


## 第IV部分 附 录

### 附录A 习题答案

### 附录B 在线资源

### 附录C Python 3.1的新特性

### 附录D 术语表


















全文第【86】页


上传图片的免费实用图床网站：
[https://sm.ms](https://sm.ms/)

在Markdown中引用图片的方式的文章：
https://www.jianshu.com/p/c7618a53454f
