# Python编程入门经典

![python log](https://i.loli.net/2019/04/25/5cc162f5430fa.jpg)

## 作者简介
James Payne居住在佛罗里达州马盖特市，他是Developer Shed公司的主编，从7岁起就开始写作和编程。James精通多门语言，已经撰写了400余篇文章，囊括了几乎每一种主流编程语言。James的工作是使用Python为金融业开发专有软件，在业余时间 他喜欢涉猎Django方向的知识。

## 致谢
我感谢在Developer Shed的同事：Jack和Jay Kin持续的敌意使我备受鼓舞；Charles Fagundes使我成为一名编辑，而不仅仅是一个作者；Keith Lee为我提供了编写代码的支持；特别要感谢Jenny Ruggieri，他使我得到了这份工作，所以有了这本书的面世。最后，还要感谢所有为这本书的前期版本付出艰辛劳动的人们，他们的工作是本书的基础。还要感谢编辑Carol Long、Jenny Watson、Ed Connor以及Chris McAvoy，他们帮助我在最终期限前完成本书。

我还想感谢Guido Van Rossum，没有他，也就没有Python语言可写。

## 前言
欢迎使用Python 3.1！
我使用Python已有10年左右，每一个新版本都使我越来越喜欢这门语言。版本3.1也不例外。如果您是Python的初学者，不必担心，我会一路引领着您。相反，如果您是一名希望尝试新版本的Python老手，可以不必在已掌握的知识上浪费时间，而是直接学习所需要的知识，因为本书的结构十分清晰。

之所以写这本书，是因为我热爱Python。我非常 喜爱它！我想和您一起分享我对Python的热爱。您可能也会像我一样越来越喜爱它。

### 本书读者对象
如果您具备计算机知识，并且想学习一门有趣的程序语言来更好地控制计算机，那么本书适合您。

如果您是系统管理员，希望学习一门优秀的语言来更好地管理和配置系统和网络，那么本书适合您。

如果您已经了解Python，但是想知道版本3.1中有哪些很酷的新功能，那么本书适合您。

总之，本书适合于所有热衷于使用功能最丰富且十分易用的最新版本Python 3.1进行编程的诸。

### 本书主要内容
本书主要介绍Python 3.1。Python 3.1发布于2009年，是Python程序语言的最新主版本。由于Python是一门跨平台的语言。本书中的内容和示例适用于任何平台（除非特别指出的例外情况）。在可能独立于平台的情况下，本书中的示例都尽量设计成跨平台的。

此外，由于Python 3.1相对较新，并非所有支持库都被更新到可以在Python 3.x下工作。在这种情形下，如果某些理论需要详细解释，本书将使用Python 2.6代替Python 3.1。

### 本书结构
就像所有入门书籍一样，本书首先对语言进行了介绍。从这里开始，会接触到语言的核心，进而接触到更加高级的专门主题。本书分为如下4个部分。

#### 第I部分——初步了解Python
如标题所示，第I部分让您初步了解Python。

##### 编程基础和字符串
本章首先介绍Python，探讨Python是什么，为什么它如此有用和强大。另外，还探讨Python的开发历史和最新的版本，后者正是本书的讨论重点。您会了解到Python所涉及的范围，以及Python可能参与的应用开发领域。最后，您将开始操作自己的第一种数据类型：字符串。

##### 数值与运算符
本章会介绍数值和运算符的基本知识。您将会学习不同类型的数值，如何执行简单的和复杂的公式，以及如何使用各种运算符。还将学到运算符的优先级以及数值的格式化。

##### 变量
编程语言最终帮助程序员管理不同类型的信息，换言之，就是管理数据。理解数据类型并且知道Python如何表示它们对于Python编程非常必要。本章将帮助您理解在Python中表示不同数据类型的最佳方式。

#### 第II部分——Python语言和标准库
当然，使用一门语言最需要的是了解语言本身，熟悉它的语法和模块。本部分首先介绍数据类型和变量，并逐步介绍其他概念，直到获得开发功能完善的Python程序所需的全部知识。

注意，应该按顺序阅读本部分的章节，因为每一章都建立在前一章的基础之上。

##### 做出决策
最终，程序将需要在某个位置做出决策：是选择这条路径，还是选择另一条路径？如果选择那条路径，将会发生什么？在本章中将学到如何比较数据，例如判断某个值是否比另一个值大，并且将学习如何利用循环来完成重复性的任务。

##### 函数
本章将介绍函数编程，这将帮助您扩展Python知识。函数允许使用者利用强大的概念，例如参数传递和代码重用。本章将介绍如何利用函数使编写的代码更加高效和灵活。

##### 类和对象
本章将介绍对象的概念。您将学习如何定义类和如何在类中创建对象和编写方法，还将学到有关对象作用域的知识。

##### 组织程序
当程序变大时，需要把它们分成单独的几部分。本章将讨论Python模块，并探索包的概念。包并不复杂，它仅是若干模块的集合。

##### 文件和目录
日常编程中一个重要的部分是学习如何处理文件和目录。文章着重介绍通常如何创建、修改和处理文件。另外，还将介绍如何从文件中获得数据，以及如何与各种各样的目录交互。

##### Python语言的其他特性
本章将介绍Python语言提供的其他特征，包括如何使用列表做出决策，如何使用字典进行字符串替换，以及一些有特色的模块。

##### 创建模块
通过允许重用代码片段，模块能够帮助节省时间。它能减少发生错误的机率，因为当前用到的模块可能之前已经被测试和使用过很多次。本章将介绍如何创建自己的模块，以及如何导入并处理已存在的模块，这些已经存在的模块使得Python在应用中功能非常强大。

##### 文本处理
在编程过程中，可以利用文本做很多事情，而且本质上，文本是与用户进行有效沟通的关键。毕竟，如果没有文本，就只能使用图片了。本章将介绍如何用多种方法处理文本，包括利用正则表达式、搜索文件以及搜索特定类型的文件等。

#### 第III部分——开始使用Python
现在您已经知道了Python是什么，以及如何利用这门语言进行工作，接下来应该做什么呢？本部分探究了您会遇到或者想了解的许多编程主题。可以顺序阅读本部分的各章，也可以按其他任意顺序阅读。因为它们是彼此独立的。

##### 测试
在把程序交付给用户之前，对程序进行测试，这是保证它能正常工作的唯一途径。本章不仅会介绍正确测试程序的一些基本概念，还会介绍一些可用的测试工具和测试框架。

##### 使用Python编写GUI
目前为止，本书中的程序都是通过命令行方式工作。本章将介绍GUI编程的概念。您将使用Tkinter创建几个GUI程序，Tkiner是Python程序员最常用的GUI工具包。

##### 访问数据库
数据库存储了程序可以使用的各种信息。它也可以作为存储信息的地方，以便日后可以从中检索出特定任务所需要数据。本章将介绍各种类型的数据库以及如何利用它们进行工作。

##### 使用Python处理XML
XML是处理Internet数据的强大工具。本章将介绍XML的基础知识，包括模式与DTD之间的区别、基本的语法、如何创建和验证XML以及一些高级的主题（例如使用lxml）。

##### 网络编程
Internet已经潜移默化地进入了我们的日常生活，并逐渐变成必需品，而不是一种特权。本章将介绍如何使用程序发送E-mail，以及如何允许用户通过Web进行交流。

##### 用C扩展编程
本章深入介绍如何使用C语言编程，包括如何利用C的框架和模块，C的基础知识，以及如何从Python向C传递参数，并在之后将值返回给Python。

##### 数据编程
本书的开始部分简单介绍了数值，现在是进一步钻研的时候了。本章将深入介绍整形、浮点型、复数和数组的全部知识，以及如何使用内置的数学函数和模块。

##### Django简介
Django是用Python编写的Web应用程序框架，它利用了模型－视图－控制器模式。Django最初被用来管理新闻Web站点，但由于简单易用而变得流行起来，它使得程序员可以用简单的方式创建复杂的Web站点，包括以数据库为中心的Web站点。本章将介绍Django的基础知识。

##### Web应用程序和Web服务
本章将介绍Web应用程序和Web服务的基础知识，例如REST架构，以及如何处理HTTP请求和响应。

##### 集成Java与Python
本章将介绍Java的基础知识，这样可以在研究如何结合Python和Java之前，打好坚实的基础。还将介绍各种帮助在Python中使用Java的模块，以及如何创建简单但有效的应用程序。

#### 第IV部分：附录
本书结尾的附录可以进一步扩展您对Python的了解，激发您对Python的学习兴趣。
* 习题答案
* 在线资源
* Python 3.1的新特性
* 术语表

### 使用本书的条件
使用本书的有一些条件。在此给出下面列出的推荐，因为Python本身可在多种不同的平台上运行。然而，本书的前几章假定您可以使用GUI，例如在Windows、Mac OS X、UNIX和Linux上的X Window等系统上可用的GUI。自然地，一些章节（例如介绍GUI的那一章）也需要GUI，而如果有网络连接，涉及网络的那些章节会更有意义。

下面是建议的最低配置需求：
* 一台PC机，运行Linux、BSD UNIX或Windows系统，频率在500MHz以上；或者运行Mac OS X版本10.2或更新版本的G3或更新的Macintosh。
* 至少256M内存。
* 所用平台具有图形用户界面。
* 对所用计算机有必要的权限，以安装必要的软件。
* 可以访问TCP/IP网络，例如Internet或者校园网。
* 可以通过Internet下载所需软件。

### 源代码
在阅读本书提供的代码时既可以亲自输入所有代码，也可以使用随书提供的代码文件。本书所有代码均可以从[http://www.wrox.com](http://www.wrox.com)（或[http://www.tupwk.com.cn/downpage](http://www.tupwk.com.cn/downpage)）网站下载。进入该网站后，请根据本书的书名查找本书（读者既可以使用搜索框进行查找，也可以使用书名列表进行查找），然后单击本书详细内容页面上提供的Download Code链接，就可以下载本书提供的所有代码。

**注意：**
由于许多书籍名称与本书类似，因此也可以通过ISBN进行查找，本书英文版的ISBN为：978-0--470-41463-7。
下载代码后，可以利用一种压缩工具解压代码。此外，还可以通过访问网站[http://www.wrox.com/dynamic/books/download.aspx](http://www.wrox.com/dynamic/books/download.aspx)中提供的Wrox代码下载页面来获取本书提供的代码，也可以下载Wrox出版的其他书籍提供的代码。

### 勘误表
为了避免本书文字和代码中存在的错误，我们已经竭尽全力。然而，就如世界上不存在完美无缺的事物，本书仍然可能存在错误。如果您在我们编写的书籍中发现了诸如拼写错误或代码缺陷等问题，请告诉我们，我们对些表示感谢。利用勘误表反馈错误信息，可以为其他读者节省大量时间，同时，我们也能够受益于您的帮助，编写出质量更高的专业著作。

如果需要参考本书的勘误表，请在网站[http://www.wrox.com](http://www.wrox.com)中用搜索框或书名列表查找本书书名。然后，在本书的详细内容页面上，单击Book Errata链接。在随后显示的页面中，可以看到与本书相关的所有勘误信息，这些信息是由读者提交、并由Wrox的编辑们加上的。通过访问[www.wrox.com/misc-pages/booklist.shtml](www.wrox.com/misc-pages/booklist.shtml)，还可以看到Wrox出版的所有书籍的勘误表。

如果没有在Book Errata页面上找到自己发现的错误，那么请转到页面[www.wrox.com/contact/techsupport.shtml](www.wrox.com/contact/techsupport.shtml)，针对您所发现的每一项错误填写表格，并将表格发给我们，我们将对表格内容进行认真审查，如果确实是我们书中的错误，那么我们将在该书的Book Errata页面上标明该错误信息，并在该书的后续版本中改正相关错误。

### 关于p2p.wrox.com
如果您希望能够与作者进行讨论，或希望能够参与读者的共同讨论，那么请加入[p2p.wrox.com](p2p.wrox.com)的论坛。这个论坛是一个基于Web的系统，您可以在论坛发表与Wrox出版的书籍有关的技术信息，并与其他读者和技术用户进行讨论。论坛提供了订阅功能，可以将与您所选主题相关的新帖子定期发送到您的电子邮箱。Wrox的作者、编辑、业界专家以及其他读者都会参与论坛中的讨论。

您可以在[http://p2p.wrox.com](http://p2p.wrox.com)参与多个论坛的讨论，这些论坛不仅能够帮助您列好地理解本书，还有助于您更好地开发应用程序。如果希望加入论坛，请按照以下步骤执行：
> (1)进入[http://p2p.wrox.com](http://p2p.wrox.com)页面，单击Register链接。
> (2)阅读使用条款，然后单击Agree。
> (3)填写必要的信息（以及想要提供的可选信息），然后单击Submit。
> (4)随后会收到一封电子邮件，邮件中说明了如何验证账号并完成整个加入过程。

**注意：**
`要阅读论坛信息，无须加入P2P。但是如果需要发表主题或发表回复，那么必须加入论坛。`

成功加入论坛后，就可以发表新主题了。此外，还可以回复其他主题。您在任何时间都可以阅读论坛信息。如果需要论坛将新的信息发送到自己的电子邮箱，那么可以单击论坛列表中论坛名称旁的Subscribe to this Forum图标完成该功能设置。

如果需要获得更多与Wrox P2P相关的信息，请阅读P2P FAQs，这样可以获得大量与P2P和Wrox出版的书籍相关的具体信息。阅读FAQs时，请单击P2P页面上的FAQs链接。

## 第I部分——初步了解Python

### 第1章 编程基础和字符串
本章简单地介绍Python编程实践。Python是一门丰富的语言，包含许多特性，因而学好基础知识是深入学习Python的前提条件。第1章～第3章通过易于理解的段落和简单的示例介绍了常见的编程思想。

对Python感兴趣的有经验的编程人员可以略读本章，并留意其中的示例，直到每3章为止，都可以借助于已有的对其他语言的知识阅读这些章节。

本章将介绍：
* 编程的一些指导原则。
* 关于初步接触程序语言Python的一些说明。
本章末的练习提供了对初步学到的基础知识进行实践的机会。

#### 1.1 编程与使用计算机的区别
编程时第一件需要了解的事情就是控制计算机。有时，计算机并没有按照人们的意愿工作，当它第一次没能如您所愿后，在第二次、第三次仍然会做与第一次相同的事情，直到对它进行修改。

个人计算机发发展已背离了可靠性原则，并朝不可信的软件套软件的方向发展。这就导致人们认为计算机就您一头具有恶意且任性的野兽，当试图让它完成某些事的时候，它会不断地增加人们的额外的工作量并折磨着使用者。然而，学过编程之后，就会知道如何应对这种情况，也许还会发现自己比所有软件的某些编写者还要聪明。

使用Python这种解释型的语言编程，意味着并不需要了解太多的计算机内部细节，如硬件、内存或者长长的0/1串。这时编程就与平常阅读和写作一样，只不过是用一种不同的简单的语言来书写。Python是一门语言，就像所讲的英语或其他语言一样，它对讲同种语言的人而言是有意义的。学习程序语言比学习人类语言甚至更简单，因为化并不是用于讨论、争论、打电话、表演、拍电影以及任何形式的日常交流活动。它们用来制订规则，并确保规则被执行。计算机已被塑造成异常灵活的工具，被广泛地用于人们日常生活中的各种商业活动和任务，但它们依旧是由可理解、可控制的基本部件组成的。

##### 1.1.1 编程的一致性
尽管计算机已消然地囊括了各式各样的设计理念，并日趋复杂。但其基本原理仍然相对简单。定义计算机如何工作的内部机制从上世纪50年代晶体管被第一次用于计算机起，就没有发生过太大的变化。

在那个时代，这种简单的核心意味着计算机可以而且应该具有高度一致性。对于程序员而言，这意味着，在任何时候让计算机跳高（比喻，并非真能跳高），就必须告诉它要跳多高，落在哪里，这样它才能完成跳跃动作，并且在指定的时间内，它将会一次次地重复相同的动作。如果没有改动程序，程序就不应随意地停止或改变工作方式。

##### 1.1.2 程序的可控性
编制一台计算机与编制一个计划是截然不同的。现实生活中，当要求他人做事时，有时候不得不做一番斗争以确保他们按照自己的意愿行事。例如，假如您计划了一个30个的聚会，并指定其中的两个人负责带土豆和蘸酱，但他们却带了饮料，这就失去了控制。

计算机则不存在这种问题，它会严格按照指示工作。如您所料，这意味着必须注意一些细节，以确保计算机确实做了要求它做的事。

Python语言的一个目标就是实现模块化编程，这就使得可以通过每一个子项目作为一个部件，并通过确保部件以易于理解的方式运行来实现更大的项目。这也是面向对象编程的主要目标。这种编程模式的主要原理是通过编制可靠的部件，使这些部件组装之后依然可以运行，且易于理解和使用。这就给予了程序员对程序每一部分运行方式的控制力，使得当要解决的问题发生变化时，知道如何扩展已有的程序。

##### 1.1.3 程序要应对变化
程序运行于计算机之上，并用于解决现实问题。现实世界中，计划和环境总是频繁地改变。这些不断变迁的环境使程序员很难有机会编写出技巧性、实用性和灵活性均趋于完美的程序。通常，只能达到其中的两个目标。这些不得不应对的变化应当都会程序员如何 更加小心地编写程序。如果足够小心，就可以编写出这样的程序，当用户的要求超出它的能力范围，它可以很友好地退出，并且通知它的使用者自己已终止工作。最好可以编出能够指出失败位置并解释失败原因的程序。Python提供了许多有用的特征，使得程序员可以描述出导致程序无法正常工作的原因。

##### 1.1.4 小结
综上所述，这些初步的规则意味着您即将被引进编程的大门，在一个自己控制的环境里，告诉计算机要做的工作。还会意识到，意外时有发生，但这些错误是可以通过某些机制加以控制的，这些机制可以让您知道如何对导致错误的条件进行处理，包括如何让程序从问题中恢复并继续运行。

#### 1.2 准备工作
在开始用Python编程之前，首先要下载并安装Python 3.1访问[www.python.org/download](www.python.org/download)并选择Python的最新版本。这会进入一个说明页面，告诉如何下载最适合本地计算机的Python版本。例如，如果正在运行Windows操作系统，该页面可能会建议下载Windows X86 MSI Installer(3.0)。

程序是以源代码的形式编写的。源代码中包含了使用程序语言编写的指令，当计算机读到源代码并对其进行处理时，程序里的指令将会变成计算机执行的操作。

就像作家和编辑有编写杂志、书籍以及在线出版物的专用工具一样，程序员也需要专门的工具。作为Python的初学者，最合适的编程工具莫过于Python IDLE图形用户界面了。

下载结束后，双击以运行程序。最好接受Python的所有默认提示。这个过程大概需要几分钟，具体时间取决于所使用的系统。

安装完毕之后，也许想测试Python是否被正确地安装。单击Windows的Start菜单，找到All programs，会看到Python 3.0的图标已经出现在菜单中，选择IDLE（Python GUI），等待程序加载。

一旦IDLE启动，输入“Test, test, testing”，并按下回车键。如果Python运行正常，它会返回
```
 'Test, test, testing'
```
这些字母都是蓝色的，并且带单引号（稍后将解释原因）。恭喜，您已成功安装了Python，并且正式步入了成为编程大师的征途。

##### 1.2.1 在非Windows系统上安装Python 3.1
如果使用Mac并运行Mac OS X操作系统，很幸运，它已经预装了Python。不过，它安装的可能不是最新版本的Python。为了安全性以及兼容性的目的，建议访问[www.python.org/download/mac](www.python.org/download/mac)，检查所用的Mac OS X版本是否适合正在安装的Python版本。

装有Linux系统的计算机可能已经安装好Python，但同样可能不是最新版本。这里仍然建议去Python的官方Web站点找到最新版本（当然，要适合所用的系统）。Web站点[www.python.org/download](www.python.org/download)上介绍了如何下载适合您的计算机的Python版本。

##### 1.2.2 使用Python Shell
在开始编写程序之前，需要学习如何使用Python Shell试验程序。现在，可以认为Python Shell是一种查看运行中的Python代码的方式。通过Shell可以进入Python的一个运行实例中，并可以向其中填写代码；同时，Python会执行要求它做的任何工作，并会显示它是如何对程序的环境做出响应的。由于程序通常是在一定的上下文环境——由程序员根据自己的需求量身打造——中运行，使用Shell的好处是它可以让程序员在自己创建的上下文环境中进行实验。

成功安装Python 3.1后，可以开始使用Shell的基本功能做一些实验。例如，可以输入：
``` python
 >>> "Hello World. You will never see this."
```
注意刚才输入Shell的语句实际上什么都不做，Python的环境也没有任何变化。Python会判断输入的语句让它做什么。在本例中，仅需要Python读取所输入的文本。

尽管从技术上说Python没有对输入的文本执行任何操作，但它会给出某种指示，表明自己已读过输入的语句。Python通过显示输入的文本（字符串）表明它已经读过了。字符串是Python的一种数据类型，在Python中，每种数据类型都有不同的显示方式。在逐步深入地阅读本书的过程中，读者会看到Python是如何显示每种不同的数据类型的。

#### 1.3 开始使用Python——字符串
此时，您可以自由使用Shell的基本功能进行实验。输入一些文本，并用引号括住它们。初学者可以输入如下语句：
``` python
>>> "This text really won't do anything"
"This text really won't do anything"
```
您应该立刻注意到，当输入一个引号（"）时，Python Shell改变了之后输入的所有字符的颜色，走到输入第二个引号以结束当前输入的语句。当然，前面的解释是成立的。它什么都不做：它 会改变Python的环境，正在运行的Python实例仅判断输入的语句是否让Python做一些事情。本例中，仅仅让它读入所写的文本，但这些并不会改变环境。

然而，可以看到Python表示它看到了输入。它以字符串的形式显示了输入，即用引号把输入的文本括起来。当学习了其他数据类型后，会发现Python显示不同数据类型的方式是不同的。

##### 1.3.1 字符串概述
字符串是Python语言的一种数据类型。顾名思义，数据类型是指某种特定类型的数据所适合的类别。输入到计算机中的数据会被划分为某种数据类型，不管它们是数值还是字母。定义数据类型使得计算机可以断定如何处理输入的数据。例如，如果想让程序在屏幕上显示数学公式 1+1 ，必须告诉它输入的是文本。否则，程序会将输入解释为数学公式，并进行相应的计算。

在后续的章节中，读者将会了解到越来越多的不同的数据类型，并理解定义数据类型的重要性。目前，知道字符串是由任意字符构成的数据类型即可，一个字符呆能是一个字母、数值、符号或标点符号。因此，下面所列都是字符串的示例。
``` python
 "Hello, how are you?"
 "1+1"
 "I ate 4 bananas"
 "!@#$%^&*()"
```

##### 1.3.2 为什么需要引号
当向Python输入一个字符串时，首先要输入一个引号。至于应该使用单引号（'）、双引号（"）还是三个引号（'''），要取决于想完成的目标。大多数情况下会使用单引号，因为它最容易输入（不需要按下Shift键）。然而，请记住，单引号和双引号以及三层引号是等价的。

尝试输入一些字符串。每当输入一个语句后，按下回车键让Python计算输入的语句。

@(<Inbox>)[用不同的引号输入字符串, 用加号串联字符串, 更多字符串格式, 对不同的数值使用type, 创建虚数, 在字符串中包含不同的数字, 在字符串中将%符号转义, 基本算术, 使用取余运算, 打印结果, %f格式说明符, 使用数学运算, 使用数字格式, 出错, 将数字格式化为八进制和十六进制, 给名称赋值, 创建和使用元组, 通过一个元组访问另外一个元组, 查看列表中的元素, 创建字典]

输入如下字符串，记住引号的类型（单引号或双引号）和行的末端（到达行的末端时使用回车键）：
``` python
 >>> "This is a string using a double quote"
 'This is a string using a double quote'
 >>> 'This is a string with a single quote'
 'This is a string with a single quote'
 >>> """This string has three quotes
 look at what it can do !"""
 'This string has three quotes\nlook at what it can do!'
 >>>
```
在上面的示例中，尽管每个句子看起来都不一样，但计算机用同样的方式解释它们：作为字符串。下面将介绍使用3种不同引号的真正目的。

##### 1.3.3 为什么有3种类型的引号
有3种类型的引号的原因很简单。假定就像刚才所做的那样，要在句子中用一个缩写。如果向Shell中输入语句“I can't believe it's not butter.”，不会有什么问题，但是当实际上程序用到刚才输入的 字符串时，就会得到出错的消息。为了解释这种现象，下一节将介绍`print()`函数。

##### 1.3.4 使用print()函数
Python（以及其他程序语言）中的函数是开发人员用来节省时间以及使程序更有效率的工具。他们将可以重复使用的代码存储在函数中，然后在需要的时候调用这些函数，而不是一遍遍地编写相同的代码。目前不要太担心函数，在后面会对它们进行更详细的介绍。

`print()`函数用来在屏幕上打印文本。在Python Shell中尝试如下的示例：
``` python
 >>> print("Hello World!")
```
按下回车键后，可得到如下输出：
``` python
 Hello World!
```
 这里有几个地方需要注意。首先，当进入`print()`函数时，会弹出如图1-1所示的窗口，显示函数中各种可用的选项。其次，后续行中的文本再次显示为蓝色，但这次，文本周围并无引号。这是因为与之前的示例有所不同，这一次Python实际上对数据做了一些操作。
 ![图1-1](https://i.loli.net/2019/04/25/5cc1669f34d24.png)
 图 1-1

 恭喜，您已经编写了自己的第一个程序。

##### 1.3.5 理解不同的引号
 现在知道了如何使用`print()`函数，可以练习使用本章前面提到的各种不同类型的引号了。尝试之前的示例：
``` Python
 >>> print('This is a string using a single quote!')
 This is a string using a single quote!
 >>> print("This is a string using a double quote!")
 This is a string using a double quote!
 >>> print("""This string has three quotes!
 Look at what it can do!""")
 This string has three quotes
 Look at what it can do!
```
可以看到，在示例所示的这些情况中单引号（'）和双引号（"）是可以互换的。然而，若想使用缩写，例如don't，或者想引用某人的言论，观察会发生什么：
``` Python
 >>> print("I said, "Dont't do it")
```
当按下回车键执行该函数时，会得到错误消息：`SyntaxError: invalid syntax(<pyshell#10>, line 1)`。您也许会感到奇怪，单引号和双引号不是可以互换吗？大部分情况下是这样的。然而，将它们混合在一起时，经常会出现语法错误，表示错误地输入了代码，并且Python不会知道您的意图何在。

实际上，Python看到输入的第一个双引号后，把它解释为字符串的开头。当它在单词`Don't`之前碰到双引号时，会将该引号看做字符串结束符。因而，后面的字母对Python是没有意义的，因为它们不是当前字符串的一部分。直到遇到字母t之前的那个单引号时，字符串才重新开始。

有一个简单的解决办法，叫做转义。再试一下前面的代码，在字符串中加入一个转义字符：
``` Python
 >>> print("I said, \"Dont't do it")
 I said, "Don't do it
```
这一次，代码可以工作了。当Python见到反斜杠（\），也就是转义字符时，知道应当把双引号看做一个字符，而不是某种数据类型的指示符。但是，也许您已经注意到了，这行代码还存在最后一个问题。看到输出结果最后丢失了一个双引号吗？为了使用Python将语句末尾的双引号打印出来，只需要再增加一个转义字符以及一个双引号即可，如下所示：
``` Python
 >>> print("I said, \"Dont't do it\"")
 I said, "Don't do it"
```
最后，花点时间讨论一下三引号。之前简单介绍过它的用法。从该示例可看出，利用三引号可以输入多行文本，在输入结束三引号之前这些文本不会被处理。这种技术在不想将大量数据打印到一行以及想在代码中换行时非常有用。接下来的示例使用这种方法写了一首诗：
``` Python
 >>> print("""Roses are red
 Violets are blue
 I just printed multiple lines
 And you did too!""")
 Roses are red
 Violets are blue
 I just printed multiple lines
 And you did too!
```
还可以利用换行（\）转义字符在多行中打印文本，换行符是最常用到的转义字符。这里对其做一简单介绍，在后续章节中会深入地讨论它。尝试如下代码：
``` Python
 >>> print("Roses are red \n Violets are blue \n
 I just printed multiple
 lines \n And you did too!")
 Roses are red
 Violets are blue
 I just printed multiple lines
 And you did too!
```
可以看到，结果是一样的。采用哪种方法取决于自己，但是换行符可能更有效率并且更易于理解。

#### 1.4 串联两个字符串
每个程序员都会遇到要把两个或多个字符串连接在一起的情况，这叫做串联（concatenation）。例如，假设有一个包含了雇员的名和姓的数据库。某些时候可能希望半这些名字作为完整的记录打印，而不是将名和姓分开。Python中，每个这样的项都会被看做一个单独的字符串，如下所示：
``` Python
 >>> "John"
 'John'
 >>> "Everyman"
 'Everyman'
```

@(**试一试**)[用加号串联字符串]

有许多将不同的字符串串联起来的方法。第一种是数学方法：
``` Python
 >>> "John" + "Everyman"
 'JohnEveryman'
```
也可以不用+号，而采用下面这种方法：
``` Python
 >>> "John" "Everyman"
 'JohnEveryman'
```
从这些示例可以看出，字符串被串联起来了；然而，Python逐字读这个语句，因而两个字符串之间没有空格（请记住：Python现在将它们看做一个字符串，而不是两个！）。如何处理这种情况？有两种解决方法。第一种是在第一个字符串后加入一个空格，如下所示：
``` Python
 >>> "John " "Everyman"
 John Everyman
```
然而，并不推荐使用这种方法，因为将来需要阅读这段代码时，很难确定是否存在John的后面加了空格。另外一种方法是简单地使用一个分隔符，例如：
``` Python
 >>> "John" + " " + "Everyman"
 'John Everyman'
```
使用这种方法而不是简单地输入一个空格的其他原因与数据库存储有关，第14章中将讨论这方面的内容。请注意，可以使用任意的分隔符，例如：
``` Python
 >>> "John" + "." + "Everyman"
 'John.Everyman'
```
##### 用print函数连接字符串
默认情况下，当要在一句话中打印多个字符串时，print()函数会非常周全地插入空格。这里没有必要使用空格分隔符。相反，只需要用逗号将不同的字符串隔开即可。
``` Python
 >>> print("John", "Everyman")
 John.Everyman
```

#### 1.5 用不同的方法串联字符串
另外一种指定字符串的方法是使用格式说明符。它通过插入一个特定的字符序列工作，这个字符序列被Python解释为占位符，并将由程序员提供的值 替换。初看起来，这种方法很复杂，不是非常有用，但格式说明符可以控制要显示的信息的格式，还可以提供许多有用的技巧。

@(**试一试**)[用加号串联字符串]

在最简单的情形下，可以对朋友John Q.做同样的事情：

##### 示例说明
%s是针对字符串的格式说明符。在本书对数据类型进行不断讨论的过程中，还会遇到更多的格式说明符，它们分别对应于特定的数据类型。在字符串中，每个格式说明符都担当相应类型的占位符。字符串外面的%符号表明它后面的所有值会被插入到字符串中相应的格式说明符处。

注意圆括号，它告诉字符串后面的序列包含用于填充格式说明符的值。

一种简单的理解方式是%s是一个存储器，存放着圆括号中的值。如果想处理更多的值，只需加入另外一个格式说明符即可，例如：
``` python
 >>> "John %s%s" %("Every", "Man")
 John Everyman
```
这些序列是Python编程的一部分，同样地，在本书的后续章节中会对其做更详细的介绍。目前，只需知道字符串中的每一个格式说明符在提供给它的序列中都必须有一个元素与之对应即可。序列中的每一项都是用逗号分隔开的字符串。

如果是向其中存放数据，为什么要把它们叫做格式说明符呢？原因是它们有多种功能，作为存储器只是其功能之一。下面的示例不仅说明了如何向格式说明符中存放数据，还说明了如何用它指定要显示的数据格式。

@(**试一试**)[更多字符串格式]

这个示例告诉格式说明符处理多个字符。尝试如下代码，并观察结果：
``` python
 >>> "%s %s %10s" % ("John", "Every", "Man")
 'John Every           Man'
 >>> "%-5s %s %10s" % ("John", "Every", "Man")
 John     Every          Man
```
##### 示例说明
在第一行代码中，单词Man出现时，离前面的单词很远，这是因为在最后一个格式说明符中添加了10，表示一个长度为10的字符串。如果字符串没有10个字符（它仅包含3个字符，即M-a-n），它就会在前一个单词与Man中间加入7个空格。

在输入的第二行代码中单词Every被空格隔开的方式与其他单词不同。原因与第一行代码相同，只不过这次空格是在左边，而不是右边。将负号放在格式说明符的右边，这个格式会出现在单词的右边。如果使用了一个非负的数值，它出现在左边。

#### 1.6 本章小结
本章学习了如何安装Python，以及如何使用Python GUI(IDLE)，这个GUI是用Python编写的程序，专门用于编辑Python程序。除了编辑文件，这个Shell还允许用Python的简单编程语句进行实验。

本章通过使用Shell介绍了有关字符串处理的基本知识，包括字符串串联，如何使用格式说明符对字符串进行格式化，甚至如何在同样的%s格式说明符中存储字符串。另外，还学习了如何使用多种类型引号，包括单引号、双引号和三引号，并且了解了\n换行转义字符的含义。

最后，学习了第一个函数print()，并且编写了自己的第一个程序Hello World，初学编程时第一个编写Hello World程序在程序员中间是一个历史悠久的传统，这与演奏吉他首先要学习“Smoke on the Water”一样——它们都是必学的第一课。

##### 本章要点：
* 编程的一致性。所有程序都是为了特定的用途而创建的，程序的使用者不仅希望程序能够实现预定的用途，而且希望程序每次的工作方式都相同。如果用户单击一个按钮，有一个打印对话框弹出，那么这个按钮应当总以相同的方式工作。
* 编程的可控性。程序员控制着自己的应用程序可以执行以及不可以执行的操作。即使程序的某些方面对于普通的观察者而言是随机的，但实际上它们也是由程序员创建的参数控制的。
* 程序要应对变化。通过不断的测试，可以确保程序对用户做出适当的响应，即使用户让程序做一些其能力范围之外的事情。
* 字符串是一种数据类型，简单讲，是一类数据。这些字符串允许以多种方式与用户进行交互，例如，向窗口打印文本，接受用户输入的文本等等。一个字符串可由任意的字母、数值或者特殊字符组成。

#### 1.7 习题
1. 在Python Shell中，输入字符串：“Rock a by baby, `\n\ton the top, \t\when the windblows\n\t\t\t the cradle will drop”`。可以使用不同数目的\n和\t转义序列进行实验，看看它们的数目对屏幕上的显示有什么影响。甚至可以尝试把它们放在不同的位置。可能的输出是什么？

2. 在Python Shell中，使用与练习1中相同的字符串，但是这一次使用print()函数显示该字符串。再一次尝试不同数目的\n和\t转义序列。结果会有什么不同？

### 第2章 数值与运算符
人们天生使用数值。婴儿从开始爬行到最终站起来都使用数值估计距离。随着时间 的推移，人们扩大了数值的使用范围，开始更加有意识地使用数值，例如购买饮料或制定每月的预算。不论是一岁还是九十岁，都对数值有一定程序的了解。实际上，数值是一个如此熟悉的概念，以至于很难注意到在不同的上下文中有多种使用数值的方式。

本章介绍数值以及Python处理数值的一些方法，包括基本算术以及针对不同类型数值的特殊的字符串格式说明符。

本章将介绍：
* Python使用的各种基本数值类型。
* 使用数值的方法。
* 如何显示以及混合各种类型的数值。

#### 2.1 不同类型的数值
如果使用过电子制表软件，会注意到制表软件并不把数值看做单纯的数值，而是看做不同类型的数值。电子制表软件根据不同的单元格格式，用不同的方法显示数值。例如，当处理美元数据时，电子制表软件将1美元显示为1.00。然而，如果想知道自己的车行驶的英里数，很可能以十分之一英里为单位记载，例如10.2英里。当说出想为一个新房子付多少钱时，很可能想到最接近的千位数。在数值的大端，电表账单以千瓦时为单位记录了读表数，千瓦时是指每小时1000瓦。

这对Python意味着，当想使用数值时，有时需要意识到并不是所有的数值都是相关联的（就像本章中讲到的虚数一样），并且有时必须谨慎地决定使用什么样的数值以及要用这些数值做什么。然而，一般情况下，有两种使用数值的方式：第一种是告诉Python重复一个特定的动作，第二种是用数值代表现实世界中的事物（即在程序中尝试对现实世界中的事物建模）。在Python中进行计数时，很少需要将数值看做简单数值之外的其他事物。然而，当尝试解决现实世界中的问题，例如涉及货币、科学、汽车、电等的问题，会发现自己更加清楚如何使用数值。

##### Python中的数值
Python提供了三种类型的可用数值：整型、浮点型和虚数。

在之前的版本中，Python用不同的方法处理大数。介于`-2 147 483 648`和`+2 147 483 647`之间的数被认为是整型。更大的数被提升为长整型。现在这两种类型已经合并，所以整型用于表示整数，无论这个整数是正数还是负数。

要确定数值的分类，可以使用Python中内置的一个特殊函数type。当使用type时，Python会告诉正在使用数据的类型。下面用几个示例进行说明。

@(**试一试**)[对不同的数值使用type]

在Python Shell中可以输入不同数值，type将指出Python如何看待这些数值：
``` python
 >>> type(1)
 <class 'int'>
 >>> type(2000)
 <class 'int'>
 >>> type(999999999999)
 <class 'int'>
 >>> type(1.0)
 <class 'float'>
```
##### 示例说明

尽管日常生活中，`1.0`与`1`相同，但Python自动将`1.0`看做一个浮点数；没有`.0`，数值`1`被当作整数`1`来处理（在小学学到的整数），这是另一种数值类型。

本质上，浮点数与整数的特殊区别在于浮点数有小数部分。像1.01、2.34、0.02324这样的数，以及其他包含小数部分的任意数值都被当作浮点数（虚数例外，它们有单独的规则）。这种数值类型可以用来处理货币或者具有可分性质的事物，例如汽油或者一对袜子（经常发现只剩下一只袜子，是不是这样？）。

##### 棘手的数值
工程领域、金融领域以及其他领域的专家需要处理非常大以及非常小的数（小到有一堆小数位），他们需要比内置类型（例如浮点型）更高的精度和一致性。如果要在编程中探索这些学科，应该使用可用的模块，第7章将介绍模块，它们用来处理与感兴趣的领域有关的问题。至少，在需要使用高精度浮点数时，有必要研究如何使用为处理这些数值编写的模块，这些模块的使用方法不同于默认行为。

Python提供的最后一种数值类型是面向工程师和数学家的。它就是虚数，在学校中应该学习过这种数。虚数定义为`-1`的平方根。尽管叫做虚数，它在对现实工程情形进行建模以及其他领域（例如物理和纯数学领域）都有许多实际的应用。虚数被内置到Python中，因此可以被经常使用计算机解决问题的用户方便地使用。如果您恰巧是这类用户，就会高兴地发现自己并不孤单，Python可以帮助您完成自己的目标。

@(**试一试**)[创建虚数]

除了不能与浮点数混合之外，虚数与浮点数很相似。虚数尾部有一个字母`j`：
``` python
 >>> 12j
 12j
```
##### 示例说明
当在数值之后使用字母j，并且数值和字母不是这字符串（即不在引号中）时，Python知道要将输入的数值看做虚数。出现在字符串以外的字母都必须有特殊含义，例如，这个修饰符指定了数值的类型，或者是一个已命名变量（见第3章），或者是另外一个特殊名称。否则，一个字母单独出现会导致出错！

可以将虚数与非虚数结合起来，创建一个复数：
``` Python
 >>> 12j + 1
 (1+12j)
 >>> 12j + 1.01
 (1.01+12j)
 >>> type (12j + 1)
 <class 'complex'>
```
可以看到，当试图混合虚数以及其他数值时，它们没有相加（相减、相乘或相除），而是以创建复数的方式保持独立。复数有实部和虚部，但是如何使用它们超出了本章的讨论范围，如果需要使用它们，可以在学习第6章以后探索复数模块（再一次出现这个词！）。模块的名称是cmath，代表complex math。复数将在第19章做进一步讨论。

#### 2.2 程序文件
现在，您应该可以比较熟悉地使用Python Shell，并在其中编写不同代码。前面用它实现示例，但现在将以一种不同的方式使用它。不同于简单地输入那些在GUI关闭之后会消失的单行代码，现在将创建和保存实际的文件，这些文件可以被再次打开和使用。

本章后续部分鼓励使用Python Shell和记事本创建自己的文件。

@(**试一试**)[创建虚数]

向记事本中输入下面的文本：
``` python
 print("This is a basic string")
 print("We learned to join two strings using " + "the plus operation")
```
现在已经向编辑器中添加了代码，尝试保存它。选择File菜单的Save As命令（如图 2-1 所示。）

![图2-1](https://i.loli.net/2019/04/25/5cc1670bb0496.png)

图 2-1

此时将出现一个弹出菜单，提示输入文件名和文件的存储目录。Python文件使用`.py`扩展名，因此要始终确保将`.py`加到文件名之后，否则记事本会将文件保存为其默认类型`.txt`。将这个文件命名为`Test.py`。接下来，定位到Python的安装目录。通常，安装路径以`C:/Python31/`开头。单击`Save`按钮，就把文件保存到了指定位置。

** 提示 **
在选择文件名并保存文件之后，可以重新打开它。要运行`Test.py`，在Python Shell中选择`File | Open`，选定要运行的文件（此处是`Test.py`）。Python编辑器将打开。单击`Run`，选择`Run Module`（见图 2-2），然后满怀期待地关注自己的第一个运行的程序。

![图2-2](https://i.loli.net/2019/04/25/5cc169019a79d.png)

图 2-2

要注意一些情况。首先，初次打开`Test.py`文件时，Python使用不同的颜色突出显示代码。这使得函数和数据类型（以及其他许多与编程有关的方面）更易于辨认。例如，`print()`函数的颜色是紫色的，而包含值的字符串是绿色的。

运行这个模块时，不再看到代码，而是看到它的结果在屏幕上以蓝色文本写出：
``` python
 This is a basic string
 We learned to join two strings using the plus operator
```
用不同的字符串再多做几次这样的操作，把它们保存在不同的文件中。每个会话现在都是可用的，之后可以引用它们。

##### 2.2.1 使用不同的类型
除了基本的整形外，其他数值类型也可能增长到具有过多的数位，从而变得难以阅读和理解。所以，经常看到这些数值在生成之后，以类似于科学计数法的格式出现。Python也允许以这种格式输入数值，所以这是一条双向路。使用非常大的整型数和浮点型数有许多障碍。这个主题涉及很多细节，并且不是学习Python必须理解的。如果想对一般意义上的浮点数有更多了解，并且了解它们对计算机而言意味着什么，[http://docs.sun.com/source/806-3568/ncg_goldberg.html](http://docs.sun.com/source/806-3568/ncg_goldberg.html)是一篇非常优秀的参考文化，尽管其中的解释只对了解计算机和数值的人有意义。然而，不要因此就不去阅读，它也许是您将来某个时刻想了解的知识。

最常用的是整型和浮点型。从某些地方（例如日期、时间或者某人的年龄信息等）得到数值的情况很常见。当以数值的形式得到数据后，还需要显示数据。

通常的方法是将数值放到字符串中。可以使用第1章中用到的格式说明符方法。直觉上，可能认为应当能够使用`+`将数值包含到一个字符串中，但实际上这是不行不通的，因为它们是不同的类型，而`+`运算符只能用于同类型数据：例如，两个字符串，两个数值，或者两个其他对象和类型等。有一个例外是浮点数和整型数可以相加。除此以外，应当认为不同类型的数据是不能用`+`运算符结合起来的。

您可能会感到奇怪，为什么字符串的格式说明符中可以有数值，但是`+`却不可以。原因是`+`运算符依赖于要相加的实际项中包含的信息。在Python中使用的任何东西都可以看做具有属性的对象，并且所有的属性结合在一起定义了这个对象。每个对象最重要的属性是它的类型，现在对于类型，最重要的是理解，一些自然而然可以理解的操作（例如`+`操作）只能用于两个可兼容类型的对象。大部分情形下，除了数值以外，应该把可兼容类型看做同一类型。

** 提示 **

如果确实想对数值和字符串执行`+`操作（这经常是自己可以决定的风格问题），可以使用一个内置函数`str`，该函数在可行的情况下把数值转换为字符串。这样就可以完成将字符串和数值相加，从而形成一个单独的字符串这样的操作。可以对大多数对象使用`str`函数，因为大多数对象都有一个作为字符串显示的方法。然而，为了保持一致，现在仍然使用字符串格式说明符。

@(**试一试**)[在字符串中包含不同的数字]

在第1章中使用格式说明符将两个字符串连接在一起时，用到了格式说明符`%s`，它的含义是“一个字符串”。由于数值和字符串有不同的类型，必须使用不同的说明符将数值包含到字符串中：
``` python
 >>> "Including an integer works with %%d like this: %d" % 10
 'Including an integer works with %d like this: 10'
 >>> "An integer converted to a float with %%f: %f" % 5
 'An integer converted to a float with %f: %f: 5.000000'
 >>> "A normal float with %%f: %f" % 1.2345
 'A normal float with %f: 1.234500'
 >>> "A really large number with %%E: %E" % 6.789E10
 'A really large number with %E: 6.789000E+10'
 >>> "Controlling the number of decimal places shown: %.02f" % 25.101010101
 'Controlling the number of decimal places shown: 25.10'
```
如果不知道在哪里使用格式说明符，注意最后一个示例看起来与打印货币数值的方法很相似，实际上，任何处理元和分的程序都至少要有这种处理数值和字符串的能力。

** 示例说明 **

任何时候，当为字符串提供格式说明符时，可能会有一些选项可以用来控制该说明符如何显示与它相关联的值。在第1章中已经看到与`%s`相关的选项，该选项可以控制显示的字符数。数值说明符也是一种 约定，指出特定类型的数值应该如何显示。当使用任意数值格式说明符时，这些约定控制着显示的结果。

@(**试一试**)[在字符串中将%符号转义]

之前已经给出了另外一个小窍门。如果想在程序中打印字符串`%d`，可以在Python字符串中连续使用两个`%`符号。这仅当在同一字符串中还有其他Python可以替换的有效格式说明符时才是需要的。
``` python
 >>> print("The %% behaves differently when combined with other letters, like this: %%d %%s %%f %d" % 10)
 The % behaves differently when combined with other letters, like this: %d %s %f 10
```

** 示例说明 **

注意，Python注意字母的组合，它将在一个字符串中既有格式说明符又有双百分号时正确地工作。

##### 2.2.2 基本算术
在程序中使用数值进行基本算术运算的情况是很常见的。加法、减法、除法和乘法都是内置的。加法和减法通过`+`和`-`号执行。

@(**试一试**)[基本算术]

在Python Shell提示中可以输入基本的算术表达式，将它当作一个计算器来使用。像计算器一样，Python接受一组操作，当按下`Enter`键后，它将计算输入的表达式，并给出结果：
``` python
 >>> 5 + 300
 305
 >>> 399 + 3020 + 1 + 3456
 6876
 >>> 300 - 59994 + 20
 -59674
 >>> 4023 - 22.46
 4000.54
```

** 示例说明 **
简单的算术运算起来和预期的一样。除了`+`和`-`，乘法通过`*`执行，除法通过`/`执行。由于浮点数整数的区别，乘法和除法在Python中并没有想象的那么直截了当。

在Python早先的版本中，当数值变大时，将从整型被提升为长整型。然而，Python 3.1中合并了这两种类型，所以不再需要做这样的提升。观察下面的数值以及当这些数值达到一定大小时Python是如何提升它们的：
``` python
>>> 2000403030 * 392381727
784921594607432810
>>> 2000403030 * 3923817273929
7849215963933911604870
>>> 2e304 * 3923817273929
inf
>>> 2e34 * 3923817273929
7.8476345478579995e+46
```
注意，尽管Python可以处理非常大的数，但是一些操作的结果仍会超过Python的容纳能力。Python在遇到无法处理的大数时将返回inf，这是infinity（无穷大）的缩定。

在Python 3.1之前，除法更值得注意。在没有帮助的情况下，Python不能够通过除法将一种数转化为另一种数。只有当至少有一个操作数是浮点数（数后有一个小数点）时才显示浮点型结果。如果两个普通的整型或者长整型数（无论是其中的哪种情况，都缺少小数部分，包括`.0`）相除，余数将被舍弃。这个问题已经被解决了，目前的Python将显示小数，除非告诉它不要这样做。观察如下输出：
``` python
 >>> 44 /11
 4.0
 >>> 5.0 / 2.5
 2.0
 >>>324/101
 3.2079207929792981
 >>> 324.5/102.9
 3.1535471331389697
```
可以看到，如果将一个整数与另外一个整数相除，将显示一个浮点数，即使在没有余数的情况下也是如此。同样地，一个整数除以一个浮点数将返回一个浮点数。然而要注意，即使整型被显示为浮点型，如前面示例中的`4.0`和`2.0`，但实际上它仍旧是整型。不过，`324/101`的结果被转换成一个浮点数。

@(**试一试**)[使用取余运算]

Python还有一个基本运算应当注意：取余运算。Python一个新增的功能是允许查看一则除法的完整结果（如前面的公式`324/101`中所示）。以前，如果想知道余数，必须要用取余运算符，因为Python只显示结果的整数部分。对于`324/101`，Python将显示3。不过在某些情况下，仍然仅需要除法结果的余数部分。为了确定这部分结果，必须要用取余运算符，符号是`%`。不必困惑，`%`只有在用于数值的时候才代表取余数。当使用字符串时，它仍然表示格式说明符的含义。同样的操作在不同的上下文中有不同的含义，这叫做重载，是一种非常有用的功能，但是当某些操作通过设计而具有不同行为时请不要惊讶。
``` python
 >>> 5 / 3
 1.666666666666667
 >>> 5 % 3
 2
```

** 示例说明 **

上面的代码表示`5`除以`3`得`1.666666666666667`，而在第二个示例中，当`5`除`3`时余数为`2`。取余运算符一个非常有用的任务是确定某个数是否可以被另外一个数整除，例如，决定序列中的某些项是否可以均匀地填充到另外一个序列中（第3章会介绍更多关于序列的知识）。这里有一些示例可以尝试：
``` python
 >>> 123 % 44
 35
 >>> 334 % 13
 9
 >>> 625 % 4
 0
```

##### 2.2.3 一些惊喜
当处理普通的浮点值时要小心，例如钱数。Python中的一些地方很令人迷惑。例如，当以看似直接的数学方式操作某些数时，得到的结果后面将有一些多余的值，如下所示：
``` python
 >>> 4023 - 22.4
 4000.599999999999
```
尾部的9会令人烦恼，但它们仅仅反映了Python的高精度。然而，当打印或者执行数学运算时，这个我实际上将得到精确的结果。

@(**试一试**)[打印结果]

尝试实际打印出结果，将上面具有不同寻常结果的数学公式的结果显示给用户，例如，在某个程序内部就可能采取这种做法：

``` python
 >>> print("%f" % (4023 -22.4))
 4000.600000
```

** 示例说明 **
前面介绍浮点数除法时提到，在Python 3.0中会输出整个公式。在计算公式`5/3`时，会得到`1.666666666667`。但是也许并不想向用户显示这么长的一串数值。可以用`%f`格式𧪈符将答案截短。

@(**试一试**)[%f格式说明符]

尝试下面的代码，观察Python处理浮点运算的不同方法，以及如何利用格式化方法操作结果：
``` python
 >>> print("%f" % (5/3))
 1.666667
 >>> print("%.2f" % (5/3))
 1.67
 >>> print("%f" % (415 * 20.2))
 8383.000000
 >>> print("%0.f" % (415 * 20.2))
 8383
```
浮点数非常容易让人糊涂。对浮点数的完整讨论超出了本书的范围，但是如果熟悉计算机和数值并且想更多地了解浮点数，可以阅读[http://docs.sun.com/source/806-3568/ncg_glodberg.html](http://docs.sun.com/source/806-3568/ncg_glodberg.html)上的论文。论文里的解释应该可以帮助完善这里的讨论。

#### 2.3 使用数值
如前面的示例所示，可以利用诸如格式说明符的方法将数值包含到字符串中，并用`print()`函数显示出来。重要的一点是必须确定如何显示这些数值，以便它们可以表示想让它们表示的含义，这要取决于对应用程序的了解程度。

##### 2.3.1 求值顺序
进行数学运算时，可能会看到`4*3+1/4-12`这样的表达式。面临的一个问题是确定如何求这种表达式的值，以及自己求值的方法是否与Python的求值方法相同。最安全的做法总是把数学表达式用括号括起来，这就是使得先求哪些数学运算的值变得清楚。

Python以如下方式对这些基本的数学运行求值：先计算乘法和除法，后计算加法和减法，但即使这样也有令人困惑的时候。

@(**试一试**)[使用数学运算]

当考虑一组数学运算时，将它们写下来（或者用键盘输入）看起来最直接，然而以后查看这些运算时容易感到迷惑。尝试如下示例，设想它们没有括号：
``` python
 >>> (24 * 8)
 192
 >>> (24 * (8 + 3))
 264
 >>> (24 * (8 + 3 + 7.0))
 432.0
 >>> (24 * (8 + 3 + 7.0 + 9))
 648.0
 >>> (24 * (8 + 3 + 7.0 + 9))/19
 34.10526305789474
 >>> (24 * (8 + 3 + 7 + 9)) / 19
 34.10526315789474
 >>> (24 * (8 + 3 + 7 + 9))%19
 2
```
在示例中要注意，使用浮点数时，整个公式会改为使用浮点数，而去掉所有浮点数会导致Python将所有数都看做整型，除非结果是浮点型的。

** 示例说明 **

上面的示例以类似于正常求值顺序的方式组合在一起，但是使用圆括号可以肯定哪组代数运算将首先被求值。最里面的运算最先被求值，最外面的运算最后被求值。在一结圆括号内，以正常顺序求值。

##### 2.3.2 数值格式
当准备在字符串中包含数值时，有很大的灵活性。下面的“试一试”部分给出了一些示例。

为了显示钱数，使用格式说明符将小数点后的位数限制为两位。

@(**试一试**)[使用数字格式]

例如，尝试下面的示例。这里把一个数值作为钱数打印：
``` python
 >>> print("$%.02f" % 30.0)
 $30.00
```
也可以用类似的格式表示小于1美分的值，例如当列出单独销售的小件商品时。如果要打印的数值多于即将打印的位数，看看Python将怎么做：
``` python
 >>> print("$%.03f" % 30.00123)
 $30.001
 >>> print("$.03f" % 30.00163)
 $30.002
 >>> print("%.03f" % 30.1777)
 30.178
 >>> print("%.03f" % 30.1113)
 30.111
```

** 示例说明 **
正如所见，如果指定的格式比要求Python显示的精度更高，Python不会截断当前的数。它将适当地进行数学上的四舍五入操作。

##### 2.3.3 可能会发生的错误
输入这些示例时，可能会犯错。显然，输入一个不同的数时，Python帮不了任何忙，得到的结果肯定会与本书不同。然而，对于作为格式说明符输入的字母对Python没有意义的情况，或者在提供给一个字符串格式说明符的序列中没有足够多的数值时，Python会试图给出尽可能多的信息，指出发生了什么问题，开发人员可以根据这些信息修复错误。

@(**试一试**)[出错]

为了理解错误发生后，接下来会发生什么，这里给出一些可以尝试的示例。从第4章开始将介绍它们完整的含义，但此时应当知道：
``` python
 >>> print("%.03f" % (30.1113, 12))
 Trackback (most recent call last):
   File"<input>", line 1, in ?
 TypeError: not all arguments converted during string formatting
```

** 示例说明 **

在上述代码中，序列中的元素（总共两个）多于字符串中的格式说明符（仅一个），因此Python给出一条帮助消息。这个错误将导致正在运行的程序停止运行，因此这通常是一个出错条件，或者称为异常。这里，词`arguments`指的是格式说明符，但通常用来代表使某个对象工作所需要的参数。当调用需要指定若干值的函数时，每个期望的值就叫做一个参数。

这是程序员认为理所当然的事；这种专门的技术语言可能不会立刻显得有意义，但是熟悉它之后就会感觉正确了。尽管为了减少困惑，在本书的前10章中，将把`arguments`当作参数，因为没有人会有争议，它们仅仅是用于设置在特定时刻要用到的条件。编程时，`arguments`和`parameters`是可以互换的。

下面列出了另外一个可能发生的错误：
``` python
 >>> print("%.03f, %f %d" % (30.1113, 12))
 Trackback (most recent call last):
   File"<input>", line 1, in ?
 TypeError: not enough arguments for format string
```
现在知道了Python中argument所代表的含义，错误消息的含义就是很显明了。代码中使用了一个格式说明符，但在伴随的序列中并没有一个值可以与之匹配，因此，没有足够多的参数。

如果尝试将字符串和数值相加，也将会出错：
``` python
 >>> "This is a string" + 4
 Trackback (most recent call last):
   File"<pyshell#13>", line 1, in <module>
 TypeError: Can't convert 'int' object to str implicitly
```
错误消息不难理解，因为前面已经介绍了执行这种操作的条件。不过下面给出了清晰的表述：Python清楚地告诉您哪些事它被告知去做但却做不了，因此需要自己解决问题（提示：可以使用str函数）。
```python
 >>> "This is a string""" + str(4)
 'This is a string4'
```

##### 2.3.4 几个不寻常的例子

Python还为数值提供了另外一个值得了解的特性，以便在遇到时可以理解它。通常我们使用十进制，即基数为10的计数系统。它包含0～9共10个数字。大于9的数字由0～9的各种组合表示。然而，计算机通常用八进制（octal)以及十六进制（hexadecimal）表示它们实际处理的二进制数。这些系统给程序员提供了一种了解数据字节的简单方法，数据经常由一到两个8位组成。

另外，不管是八进制还是十六进制都不能显示负数。用这种方法描述的数值叫做无符号数，与有符号数对应。`+`号和`-`是不同的。通常地，数值被认为是正数，但如果一个数是有符号的，它也可以是负数。如果一个数值是无符号的，它一定是正数。如果要求以无符号格式字符串显示负数，将得到预想不到的结果。

@(**试一试**)[将数字格式化为八进制和十六进制]

```Python
 >>> print('Octal uses the letter "o" lowercase. %d %o' % (10, 10))
 Octal uses the letter "o" lowercase. 10 12
```
将数值10提供给字符串时，第二个数却打印为12，看起来这像是个错误。然而八进制仅仅有8个数值（0～7），因此`0～10`用八进制表示依次是`0、1、2、3、4、5、6、7、10、11、12`。
```Python
 >>> print('Hex uses the letter "x" or "X". %d %x %X' % (10, 10, 10))
 Hex uses the letter "x" or "X". 10 a A
```
还有另外一个地方需要解释。十六进制使用`0～15`的数字，但是因为`9`这之后就没有数字了，所以十六进制用了字母`a～f`。如果使用格式说明符`%x`，这些字母是小写的；如果使用`%X`，它们则是大写的。因此，十进制的`0～19`用十六进制表示为：`0、1、2、3、4、5、6、7、8、9、a、b、c、d、e、f、10、11、12、13`。

#### 2.4 本章小结
本章介绍了Python中的数值，但是没有涵盖数值的所有方面。我们看到并使用了3种 Python内置的数字：整型数、浮点型数以及虚数。本章还介绍了如何用字符串格式说明符在字符串中包含数值，并且使用不同风格格式化了这些数值。

要重点记住，数值的格式（数值在字符串中的显示方式）并不会改变其值。即使打印成整型，浮点数仍然是浮点数，反之亦然。

本章执行了主要的内置的数学运算：加、减、乘、除以及取余。还介绍了如果整型和浮点型混合，结果为浮点型，如果两个整型数相除，可能也将适当地返回一个浮点型数。如果将整型或者浮点型数与虚数结合起来做数学运算，结果将是一个复数，复数分别有实部和虚部。本章还示范了`type`函数，该函数可以确定数值的类型。

最后，人们通常使用十进制数，而Python很容易将数值转换为八进制或者十六进制。

** 本章要点： **
* Python中有3种数值类型。它们分别是：整型数，即整数（正数和负数）；浮点型数，即带小数值的数；虚数，即`-1`的平方根，经常用于工程和物理计算。
* 当用于字符串时，`+`操作符可以将两个或多个字符串串联。例如，语句`print("Hello," + "how are you?")`的结果是一句话：“Hello, how are?”。
* 可以使用`str`函数将数值转换为字符串。
* 将两个整形数相除有时可能得到一个浮点型数（例如，3/2）。用一个浮点数除一个整型数，总会得到一个浮点数。
* 取余运算符（`%`）用来返回一则除法中的余数。例如，`5%2`将返回`1`.
* 计算中使用括号可以帮助确保以正确的顺序求值。

#### 2.5 习题
在记事本中完成前3个习题，并将结果保存于文件`ch2_exercises.py`中。在Python中，可以打开文件，选择Run Moudle运行它们。
1. 在Python Shell中，将`5`和`10`相乘。并尝试其他数值。
2. 打印数字6~14的八进制形式。
3. 打印数字9~19的十六进制形式。
4. 尝试从Python解释器中引出其他错误，例如故意将`print`拼错为`pinrt`。注意，在Python Shell的文件上工作时，它以不同方式显示`print`和`pinrt`。

### 第3章 变量
在前两章中，您学习了Python如何 看待字符串、整型、浮点型和虚数，以及如何创建和显示它们。本章将给出更多的示例，说明这些数据类型的用法。

本章将介绍：
* 使用名称存储已经了解的以及即将介绍的类型。
* 如何处理还未学习的不同类型的对象，如变量以及不同的新类型，学习本章后您将更加熟悉列表、无组和字典。
* 引用的概念及示例。
* 学习本章的重点是，应当新手输入示例代码并且更改它们，观察会发生什么。

#### 3.1 引用数据——使用数据的名称
在程序中总是地写字符串和数值是非常困难的，因为这迫使程序员记住所有的字符和数值等。计算机的内存使得它可以比人记住更多的细节，利用计算机的这种能力是编程中一个很大的部分。然而，为了更灵活简单地使用数据，可以给数据命名，之后可以用名称引用这些数据。

@(**试一试**)[给名称赋值]

这些名称一般叫做变量，表明它们引用的数据可以变化，而名称保持不变。您会看到变量也叫做名称（name），这是Python的叫法。
``` python
 >>> first_string = "This is a string"
 >>> second_string = "This is another string"
 >>> first_number = 4
 >>> second_number = 5
 >>> print("The first variables are %s, %s, %d, %d" % (first_string, second_string, first_number, second_number))
 The first variables are This is a string, This is another string, 4, 5
```

** 示例说明 **

可以用等号（=）将一个值（字符串或整型数）与名称关联。所用的名称并不与所指的数据直接相关（如果将一个数据命名为“number”，并不意味着它实际保存了一个数值。）
``` python
 >>> first_string = 245
 >>> second_number = "This isn't a number"
 >>> print(first_string)
 245
 >>> print(second_number)
 "This isn't a number"
```
注意，仅希望将一个变量的值打印出来时并不需要使用引号。如果在`print()`函数中将一个变量用引号括起来，函数会打印出这个变量的名称，而不是它的内容，这是因为程序把它看做一个字符串而不是一个变量。命名数据的好处是可以赋予它一个有着某种含义的名称。给数据起一个有意义的名称非常有必要，它可以说明数据所包含的内容，或者数据在程序中的使用方式 。如果打算清点家里所有的灯泡，您也许希望有一段程序包含壁橱中的灯泡数量，另外还有一段程序包含正在使用的灯泡的数量：
``` python
 >>> lightbulbs_in_closet = 10
 >>> lightbulbs_in_lamps = 12
```
使用灯泡时，把它们从壁橱中移到灯中，还可以给今年已经扔掉的灯泡数起一个名称，这样在年终，就会知道买了多少灯泡，瑞在有多少，以及使用过多少；当想知道还有多少灯泡时，只需要引用`lightbulbs_in_closet`或者`lightbulbs_in_lamps`即可。

当名称与其存储的值相关联时，就创建了一个非正式的索引，这样就可以查询并且记住信息存储的位置，从而便于在程序中使用它们。

##### 3.1.1 使用名称修改数据
如果数据是一个数值或者是一个字符串，可以通过已经知道的一些可用的操作修改它们。

@(**试一试**)[给名称赋值]

我们学过的关于数值和字符串的所有操作都可用于变量名，这样可以像处理它们所引用的数值那样处理它们：
``` python
 >>> proverb = "A penny saved"
 >>> proverb = proverb + " is a penny earned"
 >>> print(proverb)
 A penny saved is a penny earned
 >>> pennies_saved = 0
 >>> pennies_saved = pennies_saved + 1
 >>> print(pennies_saved)
 1
 print(pennies_saved + 1)
 2
```
** 示例说明 **
无论何时，在等号的右端使用已命名的值时，即使同样的名称出现在等号的左端，Python仍将这些名称看做它们所引用的值。当Python遇到这样的情况时，它首先对右边的名称求值并计算结果，然后将结果赋给左边的名称。这样，名称同时出现在等号两端时就不再引起混乱，Python会执行正确的操作。

##### 3.1.2 复制数据
给数据起的名称仅仅是个名称，是表示要访问的数据的一种方法。这意味着可以用多个名称引用同一个数据：
``` python
 >>> pennies_saved=1
 >>> pennies_earned = pennies_saved
 >>> print(pennies_earned)
 1
```
当再次使用`=`号时，就给名称赋予了一个已创建的新值，而另一个名称仍然指向原来的值。
``` python
 >>> pennies_saved = pennies_saved + 1
 >>> print(pennies_saved)
 2
 >>> print(pennies_earned)
 1
```

##### 3.1.3 禁用的名称以及一些规则
Python把一些名称作为特殊的内置词，它保留这些词用于特殊用途以防止出现多义性。下面列出了Python的保留词，不可以将它们用作数据的名称：
``` python
 and, as, assert, break, class, continue, def, del, elif, else,
 except, exec, False, finally, for, from, global, if, import, in,
 is, lambda, not, None, or, pass, print, raise, return, try, True,
 while, with, yield
```
另外，数据的名称不能以数值或者多数非字母的字符开头（例如逗号、加减号和斜杠等），但下划线例外。下划线是合法的，甚至在某些情形下有特殊含义（特别是用于类和模块时，详见第6章以及后续章节）。

在本章后面的讨论中将会看到许多这样特殊的保留字。在使用Python完成各式各样的任务时，它们非常重要。

#### 3.2 使用更多的内置类型
除了字符串和数值之外，Python还提供了另外4种重要的基本类型：无组、列表、集合和字典。这4种类型有许多共同点，因为它们都允许在一个名称下面组织多条数据。因为具有这种组织性，每个类型都允许在它们中查找元素。这些组织在一起的数据通过圆括号`()`、方括号`[]`和花括号`{}`表示。
> 在写程序或者读别人的程序时，如果看到一组元素，注意所使用的括号的类型是很重要的。`{}`、`[]`和`()`的区别非常重要。

##### 3.2.1 元组——不可更改的数据序列
在第1章和第2章中为字符串中的多个格式说明符赋值时，看到了元组（tuple）的应用。元组是值的序列，其中每个值都可以被单独访问，元组是Python的基本类型。在创建时就可以识别出元组，因为它们被圆括号包围：
``` python
 >>> print("A %s %s %s %s" % ("string", "filled", "by a", "tuple"))
 A string filled by a tuple
```

@(**试一试**)[创建和使用元组]

元组包含对数据的引用，例如对字符串和数值的引用。然而，虽然它们引用数据，但是仍然可以像其他类型的数据一样为它们命名：
``` python
 >>> filler = ("string", "filled", "by a", "tuple")
 >>> print("A %s %s %s %s" % ("string", "filled", "by a", "tuple"))
 A string filled by a tuple
```
注意，可以通过在`print()`函数中简单地调用元组，打印出其中的数据。尝试如下代码并观察结果：
``` python
 >>> filler = ("string", "filled", "by a", "tuple")
 >>> print(filler)
 ('string', 'filled', 'by a ', 'tuple')
```
可以看到，组成元组的4个部分被返回。这种技术在每次想查看组成元组的单个部分时非常有用。

** 示例说明 **
从上面的示例可以看出，filter（包含字符串的元组）的处理方式好像是它的元素都呈现出来并且被字符串用来填充格式说明符，因为元组的处理方式就好像输入一个序列来满足给定的格式规范。

可以访问元组中的单个值。每个元素引用的值可以通过该语言的解除引用特性直接访问。通过在元组的名称后放置方括号并且从零起计算出要引用的元素的位置，可以解除元组中对值的引用。因此，元组中第一个元素的位置是`0`，第二个元素的位置是`1`，第三个元素的位置是`2`，以此类推走到最后一个元素：
``` python
 >>> a = ("first", "second", "third")
 >>> print("The first element of the tuple is %s" % a[0])
 The first element of the tuple is first
 >>> print("The second element of the tuple is %s" % a[1])
 The second element of the tuple is first
 >>> print("The third element of the tuple is %s" % a[2])
 The third element of the tuple is first
```
元组知道它所包含的元素的数目，可以使用内置函数`len`得到这个数目：
``` python
 >>> print("%d" % len(a))
 3
```
这将返回元组中元素的数目（此处是3），因此需要记住`len`函数从`1`开始计数，但当访问元组时，由于元组从`0`开始计数，所以必须在比`len`返回的数小`1`的位置停止访问。
``` python
 >>> print(a[len(a) - 1])
 Third
```
元组中的一个元素也可以是对另外一个元组的引用。换句话说，可以创建嵌套元组：
``` python
 >>> b = (a, "b's second element")
 >>> print(b)
 (('first', 'second', 'third'), "b's second element")
```
现在可以通过在第一组方括号后面加上另外一组方括号来访问元组a中的元素，访问a中的第二个元素与访问第一个元素的方法相同，仅需再添加一组方括号即可。

@(**试一试**)[通过一个元组访问另外一个元组]

重新创建元组a和b，以便观察如何通过一个元组访问另外一个元组。嵌套的序列有时也被称具有多维，因为它们是两层，可以想象纵向和横向延伸，就像图纸或者电子表格上的二维风格一样。再增加第三层元组可被认为是三维的，像一堆积木一样。可视化超过三维的多维数据会令人头痛，将它们看做多层的嵌套的数据会好一些。
``` python
 >>> a = ("first", "second", "third")
 >>> b = (a, "b's second element")
 >>> print("%s" %b[1])
 b's second element
 >>> print("%s" % b[0][0])
 first
 >>> print("%s" % b[0][1])
 second
 >>> print("%s" % b[0][2])
 third
```

** 示例说明 **
在每种情形下，代码的工作原理仿佛是先遵循元组b的第一个元素的引用，之后遵循第二层元组中的每个值的引用（第二层的元组最初来源于元组a）。如同执行了如下操作一样：
``` python
 >>> a = ("first", "second", "third")
 >>> b = (a, "b's second element")
 >>> layer2 = b[0]
 >>> print(layer2[0])
 'first'
 >>> print(layer2[1])
 'second'
 >>> print(layer2[2])
 'third'
```
注意，元组从被创建起就存在一个奇怪的地方。若要创建包含一个元素的元组，必须在该元素之后加一个逗号：
``` python
 >>> single_element_tuple = ("the sole element",)
```
否则，将会创建一个字符串，在之后试图访问它时容易混淆。

元组可以包含各种类型的数据，但在创建之后，就不能再改变。元组是不可变的，Python中还有几个类型是不可变的（例如，字符串在创建之后是不可变的，那些看起来改变它们的操作实际上创建了新的字符串）。

元组是不可变的，因为它们用来存储一组有序的事物，这些事物在使用时是不可以更改的。试图更改元组中的元素将导致Python报错，就像第2章末尾的错误一样。
``` python
 >>> a[1] = 3
 Traceback (most recent call last):
   File "<stdion>", line 1, in ?
 TypeError: object does not support item assignment
 >>> print("%s" % a[1])
 second
```
在试图给元组中的元素赋值时，可以看到Python返回的错误是`TypeError`，意思是该类型并不支持此操作（等号会引起元组执行一个动作）。在这个示例中，试图使用元组`a`中的第二个元素引用一个整型数`3`，但这个却作将不会发生。相反，`a`保持不变。

如果试图引用元组中并不存在的元素，将发生一个不相关错误。如果试图引用`a`中的第四个元素，将得到一条错误（记住，由于元组从`0`开始对它的元素计数，因此要用数字`3`来引用第四个元素。）
``` python
 >>> a[3]
 Traceback (most recent call last):
   File "<pyshell#27>", line 1, in <module>
   a[3]
 IndexError: tuple index out of range
```
注意，这是一个`IndexError`错误，并且对错误的解释也已给出（尽管它没有告诉超出范围的索引值，但确实可以知道自己试图用元组中并不存在的索引值访问其中的一个元素）。要在程序中修复该错误，必须找出试图访问的值以及元组中元素的数目。相对于不提供错误提示的语言，Python使用找出这些错误变得容易。

##### 3.2.2 列表——可以更改的数据序列
列表如同元组，是包含从`0`开始引用的元素的序列。列表用方括号创建：
``` python
 >>> breakfast = ["coffee", "tea", "toast", "egg"]
```

@(**试一试**)[查看列表中的元素]

列表中的单个元素的访问方法与元组类似。像元组一样，列表中的元素从`0`开始引用，并且访问顺序也是从`0`开始直到末端。
``` python
 >>> count = 0
 >>> print("Today's breakfast is %s" % breakfast[count])
 Today's breakfast is coffee
 >>> count = 1
 >>> print("Today's breakfast is %s" % breakfast[count])
 Today's breakfast is tea
 >>> count = 2
 >>> print("Today's breakfast is %s" % breakfast[count])
 Today's breakfast is toast
 >>> count = 3
 >>> print("Today's breakfast is %s" % breakfast[count])
 Today's breakfast is egg
```

** 示例说明 **
当顺序访问列表中的多个元素时，有必要使用一个名称来存储目前在列表中所处的位置。在简单的示例中，应当采取这种做法以形成一种 习惯，实际中则总是会这样做。通常，用循环方法查看序列中的每一个元素（第4章将详细讨论循环）。

本例中手动完成了对`count`引用的值加`1`的工作，以遍历早餐列表中的每个元素，列出本周中4在的特色早餐。因为递增计数，不论`count`引用的数是什么，它都是早餐列表中被访问的元素索引。

使用列表与使用元组主要的区别在于，元组在创建后不可以修改，列表在任何时刻者可以被修改：
``` python
 >>> breakfast[count] = "sausages"
 >>> print("Today's breakfast is %s" % breakfast[count])
 Today's breakfast is sausages
```
不仅可以修改列表中已经存在的元素，还可以向列表中添加需要的元素。可以用列表类型的内置方法`append`向列表末端添加元素。利用`append`方法每次只能向列表末端添加一个元素：
``` python
 >>> breakfast.append("waffles")
 >>> count = 4
 >>> print("Today's breakfast is %s" % breakfast[count])
 Today's breakfast is waffles
```
如果希望一次性地向列表末端添加多个元素，例如一个元组或者其他列表的内容，可以使用`extend`方法。添加的列表并不是整体地作为原有列表的一个元素，相反，其中的每个元素将被复制到原来的列表中。
``` python
 >>> breakfast.extend(["juice", "decaf", "oatmeal"])
 >>> print(breakfast)
 ['coffee', 'tea', 'toast', 'egg', 'waffle', 'juice', 'decaf', 'oatmeal']
```
同元组一样，不可以请求列表以外的元素，但是出错消息与元组略有不同，因为错误消息将指出是列表索引超出范围，而不是元组索引超出范围。
``` python
 >>> count = 8
 >>> print("Today's breakfast is %s" % breakfast[count])
 Trackback (most recent call last):
   File "<pyshell#18>", line 1, in <module>
   print("Today's breakfast is %s" % breakfast[count])
 IndexError: list index out of range
```
列表的长度也通过`len`函数确定。就像元组一样，长度从`1`开始，而列表的第一个元素的位置从`0`开始。总是记住这一点非常重要。

##### 3.2.3 字典——以名称索引的分组数据
字典类似于列表和元组。它是包含一组数据的另外一种容器。然而，元组和列表以数字顺序索引，字典却用选择的名称索引。这些名称可以是字母、数值、字符串或者符号，自己认为合适即可。

@(**试一试**)[创建字典]

字典用花括号创建。刚开始，可以创建最简单的字典，即空字典，并通过逐行指定名称和值对它进行实例化。
```python
 >>> menus_specials = {}
 >>> menus_specials["breakfast"] = "Canadian ham"
 >>> menus_specials["lunch"] = "tuna surprise"
 >>> menus_specials["dinner"] = "Cheeseburger Deluxe"
```

** 示例说明 **
当初次为`menus_specials`赋值时，用花括号创建了一个空字典。一旦字典被定义并且通过名称引用，将开始使用如下方式对其实例化：将希望作为索引的名称放在方括号内，将通过该索引引用的值放在等号的右端。因为值由所选择的名称索引，所以可以使用上述形式给已经定义的任意字典分配索引和值。

使用字典时，索引和值都有特殊的名称。字典中索引的名称叫做键，对应的值叫做值。为了创建一个完全指定（或者可以认为它是完全形成的）的字典（一开始就指定了键和值的字典），必须在花括号之间指定每个键以及和它对应的值，并以冒号分隔它们。例如，另外一天的特色菜可以一次性定义：
``` python
 >>> menu_specials = {"breakfast" : "sausage and eggs",
 ... "lunch" : "split pea soup and gralic bread",
 ... "dinner": "2 hot dogs and onion rings"}
```
为了打印出某个字典中所有的键与值，只需将字典的名称作为`print()`函数的参数，如下面的代码所求。为了访问字典中的值，可以将键放在方括号中。如果键是字符串，需要将键放在引号中。如果键是数值（可以用数值创建字典，这样的字典十分类似于列表和元组），仅使用数值就可以了。
``` python
 >>> print(menu_specials)
 {'lunch':'split pea soup and garlic bread', 'breakfast':'sausage and eggs',
 'dinner': '2 hot dogs and onion rings'}
 >>> print("%s" % menu_specials["breakfast"])
 sausage and eggs
 >>> print("%s" % menu_specials['lunch'])
 split pea soup and garlic bread
 >>> print("%s" % menu_specials["dinner"])
 2 hot dogs and onion rings
```
如果键是一个字符串，但是在方括号中意外地没有将键放在引号中，Python就试图将它看做一个名称，需要解除对它的引用来找到键。大部分情况下，这将引起`NameError`异常，除非凑巧找到了一个与该字符串相同的名称，但这时又可能得到一个`IndexError`错误。

@(**试一试**)[创建字典]

如果知道如何询问，字典可以告诉您它所有的键，或者所有的值。`keys`方法要求字典以视图的方式返回所有键，以便用户查找所需的键，`values`方法也将以视图的形式返回所有的值。
``` python
 >>> hungry=menu_specials.keys()
 >>> print(list(hungry))
 lunch
 breakfast
 dinner
 >>> starving=menu_specials.value()
 >>> print(list(starving))
 split pea soup and garlic bread
 sausage and eggs
 2 hot dogs and onion rings
```

** 示例说明 **
`key`和`values`方法都返回视图，可以像其他常规的视图一样使用这些视图并为其赋值。如果从`keys`方法得到视图中的项，可以使用视图中的项（也就是键），得到字典中与之匹配的值。注意，尽管一个特定键可以找出一个值，但是不能从一个值开始可靠地找到与该值关联的键。当根据书籍的仅有的值试图寻找键时，需要彻底测试该值所有可能的键，尽管如此，仍可能存在两个不同的键与相同的值关联的情况。

字典的工作原理是每个键都是不同的（不可以有完全相同的两个键），但是可以有多个重复的值：
``` python
 >>>menu={"breakfast": "spam", "lunch": "spam", "dinner": "Spam with a side of Spam"}
 >>>print(menu)
 {'lunch':'spam', 'breakfast':'spam', 'dinner':'Spam with a side of Spam'}
 >>> menu.get("lunch")
 'spam'
 >>> menu.get("breakfast")
 "spam"
```
可见，Python允许在不同的键下有多个值。然而，尝试如下代码并观察会发生什么，这段代码试图用同样的名称创建不同的键：
``` python
 >>>menu2={"breakfast": "spam", "breakfast":"ham", dinner":"Spam with a side of Spam:"}
 >>>menu2.get("breakfast")
 'ham'
```
这里发生了什么呢？尽管没有得到错误消息，代码中仍然有错误。当输入第二个叫做“breakfast”的键时，Python替换了相同名称的第一个键的值。

##### 3.2.4 像列表一样处理字符串

Python给字符串提供了一个有趣的特性。有时，能够将字符串当作单个字符的列表那样处理很有帮助。在字符串的末端有无关字符并不罕见。人们也许没有识别出它们，但计算机遇到它们时会挂起。仅需要看字符串的首字符就知道如何处理该字符串的情况也很常见。例如，如果有一个姓与名的列表，您可以使用与列表相同的语法查看名与姓的第一个字符。这种看待字符串的方法叫做分片（slicing），是Python比较有趣的一个特性。
``` python
 >>>last_names=["Douglass", "Jefferson", "Williams", "Frank", "Thomas"]
 >>> print("%s" % last_names[0])
 Douglass
 >>> print("%s"% last_names[0][0])
 D
 >>> print("%s" % last_names[1])
 Jefferson
 >>> print("%s"% last_names[1][0])
 J
 >>> print("%s" % last_names[2])
 Williams
 >>> print("%s"% last_names[2][0])
 W
 >>> print("%s" % last_names[3])
 Frank
 >>> print("%s"% last_names[3][0])
 F
 >>> print("%s" % last_names[4])
 Thomas
 >>> print("%s"% last_names[4][0])
 T
```
例如，可以根据字符串的字母顺序将字典中的元素以姓的首字母分组。并不需要做任何复杂的操作，只需要检查包含名字的字符串以哪个字母开头，并以此对名字归档即可。
``` python
 >>> by_letter = {}
 >>> by_letter[last_name[0][0]] = last_name[0]
 >>> by_letter[last_name[1][0]] = last_name[1]
 >>> by_letter[last_name[2][0]] = last_name[2]
 >>> by_letter[last_name[3][0]] = last_name[3]
 >>> by_letter[last_name[4][0]] = last_name[4]
```
通过使用字符串的分片功能，字典`by_letter`仅包含所有姓的首字母。因此，`by_letter`是根据每个姓的首字母索引的字典。也可以令`by_letter`中的每个键引用一个列表，并使用列表`append`方法创建以相同字母开头的一列名字（当然，前提是您希望拥有一个索引了更大的一组名字的字典，其中每个名字都以相同的字母开头）。

** 非常有用的字符串分片 **
如果刚刚接触编程，字符串分片最初看上去是一个不同寻常的特性。使用过C或者C＋＋这样的低级语言的程序员学习过如何将程序中的字符串看做特殊的列表（在Python中也可以对列表分片，如后面所示），对他们而言，这个我很自然。对于读者而言，一旦学习了如何在列表上控制元素上控制元素的重复，它将是一个非常方便的工具。

##### 3.2.5 特殊类型
Python包含几个特殊类型。
















全文第【58】页


上传图片的免费实用图床网站：
[https://sm.ms](https://sm.ms/)

在Markdown中引用图片的方式的文章：
https://www.jianshu.com/p/c7618a53454f
